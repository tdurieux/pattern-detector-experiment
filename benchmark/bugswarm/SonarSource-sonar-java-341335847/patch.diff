diff --git a/README.md b/README.md
index f0e34950d9..bac52ccc5a 100755
--- a/README.md
+++ b/README.md
@@ -10,7 +10,7 @@ SonarJava is a code analyzer for Java projects. Information about the SonarJava
 Features
 --------
 
-* 390+ rules (including 140+ bug detection)
+* 430+ rules (including 140+ bug detection)
 * Metrics (complexity, number of lines etc.)
 * Import of [test coverage reports](https://docs.sonarqube.org/display/PLUG/Code+Coverage+by+Unit+Tests+for+Java+Project)
 * [Custom rules](https://docs.sonarqube.org/display/PLUG/Custom+Rules+for+Java)
@@ -20,9 +20,9 @@ Useful links
 
 * [Project homepage](https://redirect.sonarsource.com/plugins/java.html)
 * [Issue tracking](https://jira.sonarsource.com/browse/SONARJAVA/)
-* [Available rules](https://nemo.sonarqube.org/coding_rules#languages=java|repositories=squid)
+* [Available rules](https://rules.sonarsource.com/java)
 * [Google Group for feedback](https://groups.google.com/forum/#!forum/sonarqube)
-* [Demo project analysis](https://nemo.sonarqube.org/overview?id=org.sonarsource.sonarqube%3Asonarqube)
+* [Demo project analysis](https://next.sonarqube.com/sonarqube/dashboard?id=org.sonarsource.sonarqube%3Asonarqube)
 
 Have question or feedback?
 --------------------------
@@ -97,12 +97,15 @@ Launch ruling test:
     cd its/ruling
     mvn clean install -DskipTests=false
 
-This test gives you the opportunity to examine the issues created by each rule and make sure they're what you expect. You can inspect new/lost issues checking web-pages mentioned in the logs at the end of analysis:
+This test gives you the opportunity to examine the issues created by each rule and make sure they're what you expect. Any implemented rule is highly likely to raise issues on the multiple projects we use as ruling code base.
 
-    INFO  - HTML Issues Report generated: /path/to/project/sonar-java/its/sources/src/.sonar/issues-report/issues-report.html
-    INFO  - Light HTML Issues Report generated: /path/to/project/sonar-java/its/sources/src/.sonar/issues-report/issues-report-light.html
+* For newly implemented rule, it means that a first build will most probably fail, caused by differences between expected results (without any values for the new rule) and the new results. You can inspect these new issues by searching for files named after your rule (`squid-SXXXX.json`) in the following folder:
 
-If everything looks good to you, you can copy the file with the actual issues located at:
+        /path/to/project/sonar-java/its/ruling/target/actual/...
+
+* For existing rules which are modified, you may expect some differences between "actual" (from new analysis) and expected results. Review carefully the changes which are shown and update the expected resources accordingly.
+
+All the  `json` files contain a list of lines, indexed by file, expliciting where the issues raised by a specific rule are located. If/When everything looks good to you, you can copy the file with the actual issues located at:
 
     its/ruling/target/actual/
 
diff --git a/its/performancing/pom.xml b/its/performancing/pom.xml
index e1fecba249..40ebd6d6a0 100755
--- a/its/performancing/pom.xml
+++ b/its/performancing/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java-its</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-performancing</artifactId>
diff --git a/its/plugin/plugins/java-extension-plugin/pom.xml b/its/plugin/plugins/java-extension-plugin/pom.xml
index 41b02106c0..f3b8f0ff6d 100755
--- a/its/plugin/plugins/java-extension-plugin/pom.xml
+++ b/its/plugin/plugins/java-extension-plugin/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>it-java-plugin-plugins</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-extension-plugin</artifactId>
diff --git a/its/plugin/plugins/pom.xml b/its/plugin/plugins/pom.xml
index 7f44edb760..18d117b997 100755
--- a/its/plugin/plugins/pom.xml
+++ b/its/plugin/plugins/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>it-java-plugin</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-plugin-plugins</artifactId>
diff --git a/its/plugin/pom.xml b/its/plugin/pom.xml
index 62b517f40e..bb756a7fcb 100755
--- a/its/plugin/pom.xml
+++ b/its/plugin/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java-its</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-plugin</artifactId>
diff --git a/its/plugin/projects/java-parse-error/src/main/java/ParseError.java b/its/plugin/projects/java-parse-error/src/main/java/ParseError.java
new file mode 100755
index 0000000000..fd3e1b7ffa
--- /dev/null
+++ b/its/plugin/projects/java-parse-error/src/main/java/ParseError.java
@@ -0,0 +1,4 @@
+class A {
+  void foo() {
+
+}
diff --git a/its/plugin/projects/suppress-warnings/src/main/java/NoSonar.java b/its/plugin/projects/suppress-warnings/src/main/java/NoSonar.java
index 3829be1551..3caf29dc80 100755
--- a/its/plugin/projects/suppress-warnings/src/main/java/NoSonar.java
+++ b/its/plugin/projects/suppress-warnings/src/main/java/NoSonar.java
@@ -1,5 +1,6 @@
 public class NoSonar {
-  private void foo() {
+  // java-extension:example
+  private void foo() {// NOSONAR
     // Squid:S1197
     int var[]; //NOSONAR
   }
diff --git a/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtClassLevelWithRule.java b/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtClassLevelWithRule.java
index 7d28c41b76..e3889511dc 100755
--- a/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtClassLevelWithRule.java
+++ b/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtClassLevelWithRule.java
@@ -1,6 +1,7 @@
 @SuppressWarnings("squid:S1197")
 public class SuppressWarningsAtClassLevelWithRule {
   int var[];
+  @SuppressWarnings({"java-extension:example"})
   final void method(int a) {
     // Squid:S1197
     int var[];
diff --git a/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtFieldLevelWithCheckSytleRule.java b/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtFieldLevelWithCheckSytleRule.java
deleted file mode 100755
index 62b6a13cdd..0000000000
--- a/its/plugin/projects/suppress-warnings/src/main/java/SuppressWarningsAtFieldLevelWithCheckSytleRule.java
+++ /dev/null
@@ -1,18 +0,0 @@
-public class SuppressWarningsAtFieldLevelWithCheckSytleRule {
-  @SuppressWarnings("checkstyle:com.puppycrawl.tools.checkstyle.checks.coding.ArrayTrailingCommaCheck")
-  int[] var1 = new int[]{
-      1,
-      2,
-      3,
-      4,
-      5,
-    };
-
-  int[] var2 = new int[]{
-      1,
-      2,
-      3,
-      4,
-      5
-    };
-}
diff --git a/its/plugin/tests/pom.xml b/its/plugin/tests/pom.xml
index 83d841c10d..0578ca07e2 100755
--- a/its/plugin/tests/pom.xml
+++ b/its/plugin/tests/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>it-java-plugin</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-plugin-tests</artifactId>
diff --git a/its/plugin/tests/src/test/java/com/sonar/it/java/suite/JavaTest.java b/its/plugin/tests/src/test/java/com/sonar/it/java/suite/JavaTest.java
index 71ba050658..2aa47fc151 100755
--- a/its/plugin/tests/src/test/java/com/sonar/it/java/suite/JavaTest.java
+++ b/its/plugin/tests/src/test/java/com/sonar/it/java/suite/JavaTest.java
@@ -37,8 +37,10 @@
 import org.sonar.wsclient.issue.IssueClient;
 import org.sonar.wsclient.issue.IssueQuery;
 import org.sonarqube.ws.WsComponents;
+import org.sonarqube.ws.WsMeasures;
 
 import static com.sonar.it.java.suite.JavaTestSuite.getComponent;
+import static com.sonar.it.java.suite.JavaTestSuite.getMeasure;
 import static com.sonar.it.java.suite.JavaTestSuite.getMeasureAsInteger;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assume.assumeTrue;
@@ -253,4 +255,19 @@ public void java_aware_visitor_rely_on_java_version() {
     // no java version specified, got issue on java 7 code
     assertThat(getMeasureAsInteger("org.example:example-scanner", "violations")).isEqualTo(1);
   }
+
+  @Test
+  public void collect_feedback_on_server() {
+    SonarScanner scan = SonarScanner.create(TestUtils.projectDir("java-parse-error"))
+      .setProperty("sonar.projectKey", "java-parse-error")
+      .setProperty("sonar.projectName", "java-parse-error")
+      .setProperty("sonar.projectVersion", "1.0-SNAPSHOT")
+      .setProperty("sonar.java.collectAnalysisErrors", "true")
+      .setProperty("sonar.sources", "src");
+    orchestrator.executeBuild(scan);
+
+    WsMeasures.Measure sonarjava_feedback = getMeasure("java-parse-error", "sonarjava_feedback");
+    assertThat(sonarjava_feedback).isNotNull();
+    assertThat(sonarjava_feedback.getValue()).startsWith("[{\"message\":\"Parse error at line 5 column 1");
+  }
 }
diff --git a/its/plugin/tests/src/test/java/com/sonar/it/java/suite/SuppressWarningTest.java b/its/plugin/tests/src/test/java/com/sonar/it/java/suite/SuppressWarningTest.java
index 7dad09f0d5..31eaa4fe15 100755
--- a/its/plugin/tests/src/test/java/com/sonar/it/java/suite/SuppressWarningTest.java
+++ b/its/plugin/tests/src/test/java/com/sonar/it/java/suite/SuppressWarningTest.java
@@ -45,7 +45,6 @@
       .addPlugin(FileLocation.byWildcardMavenFilename(new File("../../../sonar-java-plugin/target"), "sonar-java-plugin-*.jar"))
       .restoreProfileAtStartup(FileLocation.ofClasspath("/profile-suppress-warnings.xml"));
     orchestratorBuilder.addPlugin(FileLocation.of(TestUtils.pluginJar("java-extension-plugin")));
-    orchestratorBuilder.addPlugin(FileLocation.ofClasspath("/sonar-checkstyle-plugin-2.4.jar"));
     ORCHESTRATOR = orchestratorBuilder.build();
   }
 
@@ -60,7 +59,7 @@ public void suppressWarnings_nosonar() throws Exception {
       .setProperty("sonar.profile", "suppress-warnings");
     ORCHESTRATOR.executeBuild(build);
 
-    assertThat(parseInt(getMeasure("org.example:example", "violations").getValue())).isEqualTo(3);
+    assertThat(parseInt(getMeasure("org.example:example", "violations").getValue())).isEqualTo(4);
   }
 
   @CheckForNull
diff --git a/its/plugin/tests/src/test/resources/profile-suppress-warnings.xml b/its/plugin/tests/src/test/resources/profile-suppress-warnings.xml
index 96319b2f8f..410e0c3dc7 100755
--- a/its/plugin/tests/src/test/resources/profile-suppress-warnings.xml
+++ b/its/plugin/tests/src/test/resources/profile-suppress-warnings.xml
@@ -9,8 +9,8 @@
       <priority>MAJOR</priority>
     </rule>
     <rule>
-      <repositoryKey>checkstyle</repositoryKey>
-      <key>com.puppycrawl.tools.checkstyle.checks.coding.ArrayTrailingCommaCheck</key>
+      <repositoryKey>java-extension</repositoryKey>
+      <key>example</key>
       <priority>MINOR</priority>
     </rule>
   </rules>
diff --git a/its/plugin/tests/src/test/resources/sonar-checkstyle-plugin-2.4.jar b/its/plugin/tests/src/test/resources/sonar-checkstyle-plugin-2.4.jar
deleted file mode 100755
index e9a8be7cdc..0000000000
Binary files a/its/plugin/tests/src/test/resources/sonar-checkstyle-plugin-2.4.jar and /dev/null differ
diff --git a/its/pom.xml b/its/pom.xml
index 7e6681841d..80e20bda70 100755
--- a/its/pom.xml
+++ b/its/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-its</artifactId>
diff --git a/its/ruling/pom.xml b/its/ruling/pom.xml
index 0f02d69277..8098acc33f 100755
--- a/its/ruling/pom.xml
+++ b/its/ruling/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java-its</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-ruling</artifactId>
diff --git a/its/ruling/src/test/java/org/sonar/java/it/JavaRulingTest.java b/its/ruling/src/test/java/org/sonar/java/it/JavaRulingTest.java
index aa635c3742..087b04e8ef 100755
--- a/its/ruling/src/test/java/org/sonar/java/it/JavaRulingTest.java
+++ b/its/ruling/src/test/java/org/sonar/java/it/JavaRulingTest.java
@@ -236,7 +236,8 @@ private static void executeBuildWithCommonProperties(Build<?> build, String proj
       .setProperty("dump.old", effectiveDumpOldFolder.resolve(projectName).toString())
       .setProperty("dump.new", FileLocation.of("target/actual/" + projectName).getFile().getAbsolutePath())
       .setProperty("lits.differences", litsDifferencesPath(projectName))
-      .setProperty("sonar.java.xfile", "true");
+      .setProperty("sonar.java.xfile", "true")
+      .setProperty("sonar.java.failOnException", "true");
     BuildResult buildResult;
     if (buildQuietly) {
       // if build fail, ruling job is not violently interrupted, allowing time to dump SQ logs
diff --git a/its/ruling/src/test/resources/commons-beanutils/squid-RedundantThrowsDeclarationCheck.json b/its/ruling/src/test/resources/commons-beanutils/squid-RedundantThrowsDeclarationCheck.json
index 467a861cc8..e4dd0ce70e 100755
--- a/its/ruling/src/test/resources/commons-beanutils/squid-RedundantThrowsDeclarationCheck.json
+++ b/its/ruling/src/test/resources/commons-beanutils/squid-RedundantThrowsDeclarationCheck.json
@@ -7,12 +7,6 @@
 ],
 'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java':[
 839,
-839,
-840,
-840,
-1965,
 1965,
-1966,
-1966,
 ],
 }
diff --git a/its/ruling/src/test/resources/commons-beanutils/squid-S126.json b/its/ruling/src/test/resources/commons-beanutils/squid-S126.json
new file mode 100755
index 0000000000..e93e2b09bc
--- /dev/null
+++ b/its/ruling/src/test/resources/commons-beanutils/squid-S126.json
@@ -0,0 +1,46 @@
+{
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/BasicDynaBean.java':[
+303,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/DynaProperty.java':[
+305,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/FluentPropertyBeanIntrospector.java':[
+142,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/LazyDynaBean.java':[
+487,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/LazyDynaList.java':[
+550,
+682,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/PropertyUtilsBean.java':[
+484,
+1235,
+1382,
+1473,
+1588,
+2056,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/WeakFastHashMap.java':[
+342,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/converters/AbstractConverter.java':[
+440,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/converters/DateTimeConverter.java':[
+231,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/expression/DefaultResolver.java':[
+87,
+124,
+149,
+186,
+208,
+243,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/locale/converters/DateLocaleConverter.java':[
+354,
+],
+}
diff --git a/its/ruling/src/test/resources/commons-beanutils/squid-S3923.json b/its/ruling/src/test/resources/commons-beanutils/squid-S1871.json
similarity index 96%
rename from its/ruling/src/test/resources/commons-beanutils/squid-S3923.json
rename to its/ruling/src/test/resources/commons-beanutils/squid-S1871.json
index dd2cb55e25..8993963fdc 100755
--- a/its/ruling/src/test/resources/commons-beanutils/squid-S3923.json
+++ b/its/ruling/src/test/resources/commons-beanutils/squid-S1871.json
@@ -1,5 +1,5 @@
 {
 'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/expression/DefaultResolver.java':[
-147,
+149,
 ],
 }
diff --git a/its/ruling/src/test/resources/commons-beanutils/squid-S2129.json b/its/ruling/src/test/resources/commons-beanutils/squid-S2129.json
index 0255979209..dd87a82451 100755
--- a/its/ruling/src/test/resources/commons-beanutils/squid-S2129.json
+++ b/its/ruling/src/test/resources/commons-beanutils/squid-S2129.json
@@ -28,8 +28,10 @@
 394,
 406,
 427,
+688,
 ],
 'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/LazyDynaBean.java':[
+123,
 127,
 129,
 131,
@@ -56,6 +58,10 @@
 351,
 360,
 365,
+458,
+],
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/locale/converters/BigIntegerLocaleConverter.java':[
+230,
 ],
 'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/locale/converters/ByteLocaleConverter.java':[
 223,
diff --git a/its/ruling/src/test/resources/commons-beanutils/squid-S3366.json b/its/ruling/src/test/resources/commons-beanutils/squid-S3366.json
new file mode 100755
index 0000000000..d1e2f961a9
--- /dev/null
+++ b/its/ruling/src/test/resources/commons-beanutils/squid-S3366.json
@@ -0,0 +1,5 @@
+{
+'commons-beanutils:commons-beanutils:src/main/java/org/apache/commons/beanutils/LazyDynaMap.java':[
+106,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S126.json b/its/ruling/src/test/resources/guava/squid-S126.json
new file mode 100755
index 0000000000..8440604d81
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S126.json
@@ -0,0 +1,140 @@
+{
+'com.google.guava:guava:src/com/google/common/cache/LocalCache.java':[
+2202,
+2735,
+],
+'com.google.guava:guava:src/com/google/common/cache/Striped64.java':[
+237,
+271,
+],
+'com.google.guava:guava:src/com/google/common/collect/AbstractMapBasedMultimap.java':[
+382,
+397,
+],
+'com.google.guava:guava:src/com/google/common/collect/AbstractRangeSet.java':[
+86,
+],
+'com.google.guava:guava:src/com/google/common/collect/CollectPreconditions.java':[
+32,
+],
+'com.google.guava:guava:src/com/google/common/collect/GeneralRange.java':[
+192,
+207,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableCollection.java':[
+182,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableMap.java':[
+316,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableRangeMap.java':[
+250,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableRangeSet.java':[
+91,
+275,
+341,
+378,
+583,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableSet.java':[
+162,
+243,
+324,
+],
+'com.google.guava:guava:src/com/google/common/collect/Iterables.java':[
+365,
+806,
+],
+'com.google.guava:guava:src/com/google/common/collect/MapMakerInternalMap.java':[
+2428,
+2530,
+],
+'com.google.guava:guava:src/com/google/common/collect/Maps.java':[
+2172,
+2326,
+2475,
+3536,
+],
+'com.google.guava:guava:src/com/google/common/collect/MinMaxPriorityQueue.java':[
+784,
+],
+'com.google.guava:guava:src/com/google/common/collect/Multimaps.java':[
+832,
+],
+'com.google.guava:guava:src/com/google/common/collect/Multisets.java':[
+703,
+787,
+918,
+],
+'com.google.guava:guava:src/com/google/common/collect/ObjectArrays.java':[
+169,
+],
+'com.google.guava:guava:src/com/google/common/collect/Ordering.java':[
+322,
+695,
+],
+'com.google.guava:guava:src/com/google/common/collect/RegularContiguousSet.java':[
+163,
+],
+'com.google.guava:guava:src/com/google/common/collect/RegularImmutableSet.java':[
+60,
+],
+'com.google.guava:guava:src/com/google/common/collect/RegularImmutableSortedSet.java':[
+117,
+154,
+],
+'com.google.guava:guava:src/com/google/common/collect/TreeMultiset.java':[
+593,
+638,
+682,
+688,
+699,
+739,
+745,
+760,
+],
+'com.google.guava:guava:src/com/google/common/collect/TreeRangeMap.java':[
+606,
+],
+'com.google.guava:guava:src/com/google/common/collect/TreeRangeSet.java':[
+569,
+],
+'com.google.guava:guava:src/com/google/common/escape/Escapers.java':[
+186,
+],
+'com.google.guava:guava:src/com/google/common/eventbus/EventBus.java':[
+216,
+],
+'com.google.guava:guava:src/com/google/common/io/ByteSource.java':[
+222,
+361,
+],
+'com.google.guava:guava:src/com/google/common/io/Files.java':[
+765,
+],
+'com.google.guava:guava:src/com/google/common/math/DoubleUtils.java':[
+98,
+],
+'com.google.guava:guava:src/com/google/common/math/IntMath.java':[
+376,
+],
+'com.google.guava:guava:src/com/google/common/math/LongMath.java':[
+470,
+],
+'com.google.guava:guava:src/com/google/common/net/InetAddresses.java':[
+184,
+198,
+389,
+885,
+],
+'com.google.guava:guava:src/com/google/common/util/concurrent/AbstractFuture.java':[
+204,
+],
+'com.google.guava:guava:src/com/google/common/util/concurrent/AggregateFuture.java':[
+222,
+],
+'com.google.guava:guava:src/com/google/common/util/concurrent/ServiceManager.java':[
+656,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S1751.json b/its/ruling/src/test/resources/guava/squid-S1751.json
index 86651d2bb8..8e18c6fa1c 100755
--- a/its/ruling/src/test/resources/guava/squid-S1751.json
+++ b/its/ruling/src/test/resources/guava/squid-S1751.json
@@ -1,7 +1,4 @@
 {
-'com.google.guava:guava:src/com/google/common/collect/ComputingConcurrentHashMap.java':[
-165,
-],
 'com.google.guava:guava:src/com/google/common/reflect/TypeToken.java':[
 1024,
 ],
diff --git a/its/ruling/src/test/resources/guava/squid-S2234.json b/its/ruling/src/test/resources/guava/squid-S2234.json
new file mode 100755
index 0000000000..be436daec2
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S2234.json
@@ -0,0 +1,5 @@
+{
+'com.google.guava:guava:src/com/google/common/collect/Sets.java':[
+588,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S3366.json b/its/ruling/src/test/resources/guava/squid-S3366.json
new file mode 100755
index 0000000000..70bef52602
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S3366.json
@@ -0,0 +1,12 @@
+{
+'com.google.guava:guava:src/com/google/common/collect/FluentIterable.java':[
+80,
+],
+'com.google.guava:guava:src/com/google/common/collect/LinkedHashMultimap.java':[
+323,
+324,
+],
+'com.google.guava:guava:src/com/google/common/util/concurrent/AbstractFuture.java':[
+155,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S3626.json b/its/ruling/src/test/resources/guava/squid-S3626.json
new file mode 100755
index 0000000000..f17409d866
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S3626.json
@@ -0,0 +1,8 @@
+{
+'com.google.guava:guava:src/com/google/common/collect/ComputingConcurrentHashMap.java':[
+165,
+],
+'com.google.guava:guava:src/com/google/common/io/Files.java':[
+742,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S4248.json b/its/ruling/src/test/resources/guava/squid-S4248.json
new file mode 100755
index 0000000000..3ec2556a5b
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S4248.json
@@ -0,0 +1,8 @@
+{
+'com.google.guava:guava:src/com/google/common/net/InternetDomainName.java':[
+510,
+],
+'com.google.guava:guava:src/com/google/common/net/PercentEscaper.java':[
+100,
+],
+}
diff --git a/its/ruling/src/test/resources/guava/squid-S4449.json b/its/ruling/src/test/resources/guava/squid-S4449.json
new file mode 100755
index 0000000000..ff23e38a27
--- /dev/null
+++ b/its/ruling/src/test/resources/guava/squid-S4449.json
@@ -0,0 +1,104 @@
+{
+'com.google.guava:guava:src/com/google/common/base/Converter.java':[
+156,
+166,
+],
+'com.google.guava:guava:src/com/google/common/base/Joiner.java':[
+133,
+177,
+215,
+],
+'com.google.guava:guava:src/com/google/common/base/MoreObjects.java':[
+56,
+],
+'com.google.guava:guava:src/com/google/common/base/Preconditions.java':[
+146,
+199,
+310,
+353,
+],
+'com.google.guava:guava:src/com/google/common/cache/LongAdder.java':[
+77,
+],
+'com.google.guava:guava:src/com/google/common/collect/AbstractBiMap.java':[
+136,
+149,
+],
+'com.google.guava:guava:src/com/google/common/collect/AbstractSortedMultiset.java':[
+111,
+111,
+],
+'com.google.guava:guava:src/com/google/common/collect/AbstractTable.java':[
+39,
+44,
+70,
+92,
+],
+'com.google.guava:guava:src/com/google/common/collect/FilteredEntryMultimap.java':[
+84,
+188,
+204,
+366,
+],
+'com.google.guava:guava:src/com/google/common/collect/FilteredKeyListMultimap.java':[
+50,
+],
+'com.google.guava:guava:src/com/google/common/collect/ForwardingMap.java':[
+289,
+],
+'com.google.guava:guava:src/com/google/common/collect/ForwardingMultiset.java':[
+114,
+],
+'com.google.guava:guava:src/com/google/common/collect/ForwardingSortedMap.java':[
+138,
+],
+'com.google.guava:guava:src/com/google/common/collect/ForwardingSortedSet.java':[
+119,
+146,
+],
+'com.google.guava:guava:src/com/google/common/collect/HashBiMap.java':[
+290,
+329,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableMap.java':[
+601,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableSetMultimap.java':[
+302,
+],
+'com.google.guava:guava:src/com/google/common/collect/ImmutableSortedMap.java':[
+510,
+],
+'com.google.guava:guava:src/com/google/common/collect/RegularImmutableBiMap.java':[
+98,
+],
+'com.google.guava:guava:src/com/google/common/collect/SortedLists.java':[
+277,
+],
+'com.google.guava:guava:src/com/google/common/collect/Tables.java':[
+484,
+515,
+],
+'com.google.guava:guava:src/com/google/common/collect/TreeMultiset.java':[
+236,
+583,
+597,
+675,
+692,
+729,
+750,
+],
+'com.google.guava:guava:src/com/google/common/collect/TreeRangeMap.java':[
+550,
+],
+'com.google.guava:guava:src/com/google/common/reflect/TypeToken.java':[
+1033,
+],
+'com.google.guava:guava:src/com/google/common/util/concurrent/AbstractFuture.java':[
+512,
+611,
+632,
+665,
+668,
+],
+}
diff --git a/its/ruling/src/test/resources/jboss-ejb3-tutorial/squid-S126.json b/its/ruling/src/test/resources/jboss-ejb3-tutorial/squid-S126.json
new file mode 100755
index 0000000000..6b1b843169
--- /dev/null
+++ b/its/ruling/src/test/resources/jboss-ejb3-tutorial/squid-S126.json
@@ -0,0 +1,5 @@
+{
+'jboss-ejb3-tutorial:enterprise_app_ejb_injection/webapp/src/main/java/org/jboss/tutorial/enterprise_app_ejb_injection/servlet/CalculatorActionServlet.java':[
+92,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-EmptyStatementUsageCheck.json b/its/ruling/src/test/resources/jdk6/squid-EmptyStatementUsageCheck.json
index 9c5ebc6e38..465ab02378 100755
--- a/its/ruling/src/test/resources/jdk6/squid-EmptyStatementUsageCheck.json
+++ b/its/ruling/src/test/resources/jdk6/squid-EmptyStatementUsageCheck.json
@@ -25,24 +25,9 @@
 'jdk6:java/awt/image/ColorConvertOp.java':[
 596,
 ],
-'jdk6:java/beans/Beans.java':[
-499,
-],
-'jdk6:java/io/ObjectInputStream.java':[
-2610,
-],
-'jdk6:java/io/StreamTokenizer.java':[
-712,
-718,
-729,
-],
 'jdk6:java/lang/Shutdown.java':[
 42,
 ],
-'jdk6:java/lang/String.java':[
-1769,
-1777,
-],
 'jdk6:java/lang/management/ManagementFactory.java':[
 272,
 ],
@@ -51,13 +36,8 @@
 201,
 219,
 ],
-'jdk6:java/lang/ref/Finalizer.java':[
-111,
-172,
-],
 'jdk6:java/lang/ref/Reference.java':[
 86,
-138,
 ],
 'jdk6:java/lang/ref/ReferenceQueue.java':[
 35,
@@ -65,28 +45,10 @@
 'jdk6:java/lang/reflect/Constructor.java':[
 653,
 ],
-'jdk6:java/math/BigInteger.java':[
-2332,
-2777,
-2791,
-2804,
-2830,
-2836,
-2877,
-2882,
-2893,
-3003,
-],
-'jdk6:java/math/MutableBigInteger.java':[
-255,
-],
 'jdk6:java/net/InetAddress.java':[
 675,
 836,
 ],
-'jdk6:java/net/NetworkInterface.java':[
-462,
-],
 'jdk6:java/net/Proxy.java':[
 41,
 ],
@@ -109,43 +71,19 @@
 165,
 222,
 ],
-'jdk6:java/text/DigitList.java':[
-524,
-566,
-],
 'jdk6:java/text/Normalizer.java':[
 97,
 ],
-'jdk6:java/util/AbstractQueue.java':[
-121,
-],
 'jdk6:java/util/Formatter.java':[
 2522,
 ],
-'jdk6:java/util/HashMap.java':[
-783,
-801,
-],
-'jdk6:java/util/ServiceLoader.java':[
-282,
-],
-'jdk6:java/util/WeakHashMap.java':[
-607,
-619,
-],
 'jdk6:java/util/concurrent/ConcurrentSkipListMap.java':[
 870,
 ],
-'jdk6:java/util/jar/Manifest.java':[
-370,
-],
 'jdk6:java/util/prefs/FileSystemPreferences.java':[
 354,
 ],
 'jdk6:java/util/regex/Pattern.java':[
 4076,
 ],
-'jdk6:java/util/zip/ZipInputStream.java':[
-100,
-],
 }
diff --git a/its/ruling/src/test/resources/jdk6/squid-RedundantThrowsDeclarationCheck.json b/its/ruling/src/test/resources/jdk6/squid-RedundantThrowsDeclarationCheck.json
index 9bce4529db..95da140d5f 100755
--- a/its/ruling/src/test/resources/jdk6/squid-RedundantThrowsDeclarationCheck.json
+++ b/its/ruling/src/test/resources/jdk6/squid-RedundantThrowsDeclarationCheck.json
@@ -30,7 +30,6 @@
 ],
 'jdk6:java/awt/Component.java':[
 1304,
-3405,
 ],
 'jdk6:java/awt/Container.java':[
 2406,
@@ -258,10 +257,6 @@
 431,
 461,
 ],
-'jdk6:java/beans/EventSetDescriptor.java':[
-230,
-261,
-],
 'jdk6:java/beans/PropertyEditor.java':[
 142,
 ],
@@ -280,18 +275,12 @@
 ],
 'jdk6:java/io/ObjectInputStream.java':[
 299,
-509,
-599,
-666,
-725,
 751,
 777,
 2367,
 ],
 'jdk6:java/io/ObjectOutputStream.java':[
 254,
-286,
-567,
 592,
 ],
 'jdk6:java/io/ObjectStreamClass.java':[
@@ -303,25 +292,6 @@
 1023,
 1052,
 ],
-'jdk6:java/lang/Class.java':[
-303,
-312,
-1513,
-1598,
-1652,
-1875,
-1930,
-1980,
-],
-'jdk6:java/lang/Enum.java':[
-203,
-],
-'jdk6:java/lang/StringBuffer.java':[
-624,
-],
-'jdk6:java/lang/StringBuilder.java':[
-456,
-],
 'jdk6:java/lang/management/ManagementPermission.java':[
 96,
 ],
@@ -419,7 +389,6 @@
 139,
 ],
 'jdk6:java/net/Socket.java':[
-146,
 187,
 ],
 'jdk6:java/net/SocketImpl.java':[
@@ -435,9 +404,6 @@
 303,
 514,
 ],
-'jdk6:java/net/URLConnection.java':[
-759,
-],
 'jdk6:java/rmi/activation/Activatable.java':[
 228,
 262,
@@ -493,13 +459,6 @@
 'jdk6:java/security/GuardedObject.java':[
 65,
 ],
-'jdk6:java/security/Identity.java':[
-167,
-279,
-],
-'jdk6:java/security/KeyStoreSpi.java':[
-430,
-],
 'jdk6:java/security/Permission.java':[
 83,
 ],
@@ -522,10 +481,6 @@
 'jdk6:java/security/Signer.java':[
 116,
 ],
-'jdk6:java/security/cert/X509CertSelector.java':[
-1347,
-1406,
-],
 'jdk6:java/security/interfaces/DSAKeyPairGenerator.java':[
 66,
 96,
@@ -631,6 +586,5 @@
 'jdk6:java/util/zip/ZipFile.java':[
 142,
 319,
-369,
 ],
 }
diff --git a/its/ruling/src/test/resources/jdk6/squid-S126.json b/its/ruling/src/test/resources/jdk6/squid-S126.json
new file mode 100755
index 0000000000..02b7bb2a9b
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S126.json
@@ -0,0 +1,804 @@
+{
+'jdk6:java/awt/AWTEvent.java':[
+371,
+],
+'jdk6:java/awt/AWTEventMulticaster.java':[
+906,
+914,
+927,
+],
+'jdk6:java/awt/BasicStroke.java':[
+190,
+202,
+505,
+],
+'jdk6:java/awt/BorderLayout.java':[
+470,
+479,
+608,
+854,
+],
+'jdk6:java/awt/Checkbox.java':[
+307,
+],
+'jdk6:java/awt/Choice.java':[
+324,
+],
+'jdk6:java/awt/Component.java':[
+812,
+1894,
+2942,
+3309,
+3679,
+3779,
+3954,
+4237,
+4660,
+5772,
+5968,
+6073,
+],
+'jdk6:java/awt/Container.java':[
+858,
+1073,
+3964,
+4001,
+4290,
+4295,
+4342,
+],
+'jdk6:java/awt/ContainerOrderFocusTraversalPolicy.java':[
+85,
+117,
+158,
+201,
+262,
+273,
+323,
+375,
+],
+'jdk6:java/awt/DefaultKeyboardFocusManager.java':[
+884,
+1065,
+1240,
+],
+'jdk6:java/awt/Dialog.java':[
+1167,
+],
+'jdk6:java/awt/EventDispatchThread.java':[
+249,
+307,
+434,
+],
+'jdk6:java/awt/EventQueue.java':[
+275,
+992,
+1072,
+],
+'jdk6:java/awt/Font.java':[
+454,
+627,
+1474,
+],
+'jdk6:java/awt/Frame.java':[
+647,
+948,
+],
+'jdk6:java/awt/Graphics.java':[
+1234,
+],
+'jdk6:java/awt/Graphics2D.java':[
+474,
+],
+'jdk6:java/awt/GridBagLayout.java':[
+684,
+1059,
+1111,
+1188,
+1228,
+1403,
+1510,
+1561,
+1821,
+],
+'jdk6:java/awt/KeyboardFocusManager.java':[
+2243,
+2648,
+2834,
+],
+'jdk6:java/awt/List.java':[
+1051,
+],
+'jdk6:java/awt/MediaTracker.java':[
+898,
+916,
+],
+'jdk6:java/awt/MenuComponent.java':[
+251,
+338,
+],
+'jdk6:java/awt/ModalEventFilter.java':[
+42,
+],
+'jdk6:java/awt/MultipleGradientPaintContext.java':[
+510,
+],
+'jdk6:java/awt/Polygon.java':[
+275,
+],
+'jdk6:java/awt/Rectangle.java':[
+1067,
+1072,
+1079,
+1087,
+1090,
+1093,
+1126,
+1133,
+],
+'jdk6:java/awt/RenderingHints.java':[
+1220,
+],
+'jdk6:java/awt/SystemTray.java':[
+187,
+228,
+],
+'jdk6:java/awt/TexturePaintContext.java':[
+69,
+235,
+261,
+],
+'jdk6:java/awt/TrayIcon.java':[
+679,
+735,
+],
+'jdk6:java/awt/Window.java':[
+2476,
+],
+'jdk6:java/awt/color/ICC_Profile.java':[
+736,
+1961,
+],
+'jdk6:java/awt/datatransfer/DataFlavor.java':[
+769,
+783,
+],
+'jdk6:java/awt/datatransfer/MimeTypeParameterList.java':[
+86,
+],
+'jdk6:java/awt/datatransfer/SystemFlavorMap.java':[
+323,
+485,
+1056,
+1136,
+],
+'jdk6:java/awt/dnd/DragSource.java':[
+669,
+],
+'jdk6:java/awt/event/KeyEvent.java':[
+966,
+1081,
+],
+'jdk6:java/awt/event/MouseEvent.java':[
+561,
+808,
+],
+'jdk6:java/awt/font/NumericShaper.java':[
+231,
+604,
+819,
+],
+'jdk6:java/awt/font/TextLayout.java':[
+1312,
+1668,
+1713,
+2453,
+2459,
+],
+'jdk6:java/awt/geom/AffineTransform.java':[
+1400,
+],
+'jdk6:java/awt/geom/Arc2D.java':[
+870,
+1108,
+],
+'jdk6:java/awt/geom/CubicCurve2D.java':[
+1154,
+],
+'jdk6:java/awt/geom/Rectangle2D.java':[
+216,
+223,
+420,
+427,
+],
+'jdk6:java/awt/image/AffineTransformOp.java':[
+101,
+111,
+274,
+388,
+394,
+],
+'jdk6:java/awt/image/AreaAveragingScaleFilter.java':[
+109,
+110,
+111,
+],
+'jdk6:java/awt/image/BandCombineOp.java':[
+129,
+],
+'jdk6:java/awt/image/BufferedImage.java':[
+650,
+693,
+710,
+729,
+736,
+769,
+],
+'jdk6:java/awt/image/BufferedImageFilter.java':[
+118,
+192,
+],
+'jdk6:java/awt/image/ColorConvertOp.java':[
+863,
+905,
+],
+'jdk6:java/awt/image/ComponentColorModel.java':[
+439,
+884,
+1117,
+1750,
+],
+'jdk6:java/awt/image/ComponentSampleModel.java':[
+217,
+],
+'jdk6:java/awt/image/ConvolveOp.java':[
+173,
+187,
+225,
+],
+'jdk6:java/awt/image/CropImageFilter.java':[
+171,
+],
+'jdk6:java/awt/image/DataBuffer.java':[
+397,
+],
+'jdk6:java/awt/image/DirectColorModel.java':[
+232,
+311,
+326,
+354,
+377,
+400,
+],
+'jdk6:java/awt/image/ImageFilter.java':[
+94,
+],
+'jdk6:java/awt/image/IndexColorModel.java':[
+744,
+],
+'jdk6:java/awt/image/Kernel.java':[
+113,
+],
+'jdk6:java/awt/image/LookupOp.java':[
+248,
+377,
+],
+'jdk6:java/awt/image/PackedColorModel.java':[
+433,
+],
+'jdk6:java/awt/image/PixelGrabber.java':[
+358,
+420,
+494,
+],
+'jdk6:java/awt/image/Raster.java':[
+907,
+996,
+],
+'jdk6:java/awt/image/ReplicateScaleFilter.java':[
+140,
+],
+'jdk6:java/awt/image/RescaleOp.java':[
+463,
+],
+'jdk6:java/beans/Beans.java':[
+316,
+],
+'jdk6:java/beans/EventHandler.java':[
+424,
+],
+'jdk6:java/beans/Introspector.java':[
+473,
+571,
+582,
+590,
+803,
+1016,
+],
+'jdk6:java/beans/MetaData.java':[
+526,
+746,
+],
+'jdk6:java/beans/ReflectionUtils.java':[
+217,
+],
+'jdk6:java/beans/XMLEncoder.java':[
+542,
+667,
+],
+'jdk6:java/io/BufferedInputStream.java':[
+192,
+311,
+],
+'jdk6:java/io/BufferedReader.java':[
+257,
+],
+'jdk6:java/io/BufferedWriter.java':[
+161,
+],
+'jdk6:java/io/ByteArrayInputStream.java':[
+162,
+],
+'jdk6:java/io/ByteArrayOutputStream.java':[
+89,
+],
+'jdk6:java/io/CharArrayReader.java':[
+109,
+],
+'jdk6:java/io/CharArrayWriter.java':[
+82,
+],
+'jdk6:java/io/Console.java':[
+352,
+471,
+],
+'jdk6:java/io/FilePermission.java':[
+409,
+],
+'jdk6:java/io/InputStream.java':[
+147,
+],
+'jdk6:java/io/LineNumberInputStream.java':[
+118,
+],
+'jdk6:java/io/ObjectInputStream.java':[
+1283,
+2375,
+2738,
+2750,
+2762,
+2774,
+2786,
+2798,
+2810,
+],
+'jdk6:java/io/ObjectOutputStream.java':[
+1102,
+1144,
+],
+'jdk6:java/io/ObjectStreamClass.java':[
+468,
+674,
+1542,
+2098,
+],
+'jdk6:java/io/OutputStream.java':[
+95,
+],
+'jdk6:java/io/PipedInputStream.java':[
+219,
+245,
+292,
+356,
+],
+'jdk6:java/io/PipedOutputStream.java':[
+82,
+129,
+],
+'jdk6:java/io/PipedReader.java':[
+157,
+222,
+279,
+287,
+325,
+],
+'jdk6:java/io/PipedWriter.java':[
+79,
+130,
+],
+'jdk6:java/io/PrintWriter.java':[
+318,
+],
+'jdk6:java/io/PushbackInputStream.java':[
+154,
+],
+'jdk6:java/io/PushbackReader.java':[
+96,
+],
+'jdk6:java/io/RandomAccessFile.java':[
+187,
+],
+'jdk6:java/io/SequenceInputStream.java':[
+187,
+],
+'jdk6:java/io/StringBufferInputStream.java':[
+97,
+],
+'jdk6:java/io/StringReader.java':[
+77,
+],
+'jdk6:java/io/StringWriter.java':[
+74,
+],
+'jdk6:java/lang/AbstractStringBuilder.java':[
+97,
+],
+'jdk6:java/lang/Byte.java':[
+271,
+],
+'jdk6:java/lang/CharacterData00.java':[
+263,
+274,
+290,
+],
+'jdk6:java/lang/CharacterData01.java':[
+176,
+187,
+203,
+],
+'jdk6:java/lang/CharacterData02.java':[
+175,
+186,
+202,
+],
+'jdk6:java/lang/CharacterData0E.java':[
+175,
+186,
+202,
+],
+'jdk6:java/lang/CharacterDataLatin1.java':[
+162,
+181,
+],
+'jdk6:java/lang/ClassLoader.java':[
+1665,
+],
+'jdk6:java/lang/ConditionalSpecialCasing.java':[
+299,
+],
+'jdk6:java/lang/Integer.java':[
+941,
+],
+'jdk6:java/lang/Long.java':[
+624,
+],
+'jdk6:java/lang/Short.java':[
+277,
+],
+'jdk6:java/lang/StrictMath.java':[
+348,
+],
+'jdk6:java/lang/String.java':[
+1569,
+],
+'jdk6:java/lang/ThreadGroup.java':[
+790,
+861,
+982,
+],
+'jdk6:java/lang/reflect/Proxy.java':[
+473,
+],
+'jdk6:java/math/BigDecimal.java':[
+393,
+421,
+435,
+831,
+1003,
+1027,
+1785,
+2635,
+3533,
+],
+'jdk6:java/math/BigInteger.java':[
+930,
+1402,
+],
+'jdk6:java/net/DatagramSocket.java':[
+614,
+],
+'jdk6:java/net/HttpCookie.java':[
+166,
+746,
+1115,
+],
+'jdk6:java/net/Inet6Address.java':[
+613,
+],
+'jdk6:java/net/InetAddress.java':[
+925,
+1062,
+1079,
+],
+'jdk6:java/net/MulticastSocket.java':[
+637,
+],
+'jdk6:java/net/SocketPermission.java':[
+480,
+],
+'jdk6:java/net/URI.java':[
+1432,
+1551,
+1815,
+1947,
+2307,
+2752,
+2941,
+3422,
+3426,
+],
+'jdk6:java/net/URL.java':[
+1236,
+],
+'jdk6:java/net/URLConnection.java':[
+1296,
+1641,
+],
+'jdk6:java/net/URLStreamHandler.java':[
+239,
+],
+'jdk6:java/nio/channels/Channels.java':[
+145,
+],
+'jdk6:java/nio/charset/CharsetEncoder.java':[
+868,
+],
+'jdk6:java/nio/charset/CoderResult.java':[
+192,
+],
+'jdk6:java/rmi/Naming.java':[
+267,
+],
+'jdk6:java/rmi/server/LogStream.java':[
+243,
+],
+'jdk6:java/security/AccessControlContext.java':[
+468,
+],
+'jdk6:java/security/CodeSource.java':[
+329,
+377,
+],
+'jdk6:java/security/KeyPairGenerator.java':[
+566,
+],
+'jdk6:java/security/KeyStoreSpi.java':[
+451,
+460,
+526,
+],
+'jdk6:java/security/Permissions.java':[
+230,
+],
+'jdk6:java/security/UnresolvedPermission.java':[
+331,
+],
+'jdk6:java/security/cert/X509CertSelector.java':[
+2342,
+],
+'jdk6:java/security/spec/EllipticCurve.java':[
+41,
+44,
+],
+'jdk6:java/sql/Timestamp.java':[
+477,
+],
+'jdk6:java/text/CollationElementIterator.java':[
+179,
+201,
+218,
+228,
+271,
+291,
+368,
+],
+'jdk6:java/text/DecimalFormat.java':[
+638,
+1403,
+1572,
+2143,
+2461,
+],
+'jdk6:java/text/DigitList.java':[
+329,
+443,
+455,
+644,
+],
+'jdk6:java/text/FieldPosition.java':[
+203,
+],
+'jdk6:java/text/NumberFormat.java':[
+758,
+],
+'jdk6:java/text/RBTableBuilder.java':[
+197,
+],
+'jdk6:java/text/RuleBasedCollationKey.java':[
+44,
+],
+'jdk6:java/text/RuleBasedCollator.java':[
+484,
+493,
+500,
+],
+'jdk6:java/text/SimpleDateFormat.java':[
+1033,
+1181,
+1780,
+1996,
+],
+'jdk6:java/util/ArrayDeque.java':[
+146,
+],
+'jdk6:java/util/Arrays.java':[
+3715,
+],
+'jdk6:java/util/Calendar.java':[
+1005,
+2640,
+2665,
+],
+'jdk6:java/util/Date.java':[
+230,
+305,
+465,
+544,
+549,
+691,
+],
+'jdk6:java/util/Formatter.java':[
+2915,
+3028,
+3055,
+3103,
+3232,
+3278,
+3283,
+3575,
+3604,
+],
+'jdk6:java/util/GregorianCalendar.java':[
+992,
+1290,
+1369,
+2335,
+2511,
+2872,
+],
+'jdk6:java/util/JapaneseImperialCalendar.java':[
+373,
+445,
+674,
+695,
+796,
+873,
+1994,
+2339,
+],
+'jdk6:java/util/Properties.java':[
+352,
+561,
+],
+'jdk6:java/util/PropertyPermission.java':[
+237,
+],
+'jdk6:java/util/ResourceBundle.java':[
+1284,
+],
+'jdk6:java/util/SimpleTimeZone.java':[
+607,
+687,
+1386,
+1433,
+],
+'jdk6:java/util/TimeZone.java':[
+761,
+],
+'jdk6:java/util/TreeMap.java':[
+2156,
+],
+'jdk6:java/util/Vector.java':[
+514,
+],
+'jdk6:java/util/concurrent/ConcurrentSkipListMap.java':[
+822,
+],
+'jdk6:java/util/concurrent/CyclicBarrier.java':[
+200,
+],
+'jdk6:java/util/concurrent/Exchanger.java':[
+338,
+342,
+511,
+],
+'jdk6:java/util/concurrent/ScheduledThreadPoolExecutor.java':[
+195,
+236,
+],
+'jdk6:java/util/concurrent/SynchronousQueue.java':[
+322,
+335,
+423,
+715,
+769,
+],
+'jdk6:java/util/concurrent/ThreadPoolExecutor.java':[
+657,
+750,
+759,
+1346,
+],
+'jdk6:java/util/concurrent/locks/AbstractQueuedLongSynchronizer.java':[
+441,
+1737,
+],
+'jdk6:java/util/concurrent/locks/AbstractQueuedSynchronizer.java':[
+669,
+1962,
+],
+'jdk6:java/util/concurrent/locks/ReentrantLock.java':[
+114,
+218,
+],
+'jdk6:java/util/logging/FileHandler.java':[
+464,
+494,
+],
+'jdk6:java/util/logging/LogManager.java':[
+954,
+],
+'jdk6:java/util/logging/Logger.java':[
+336,
+],
+'jdk6:java/util/prefs/AbstractPreferences.java':[
+485,
+],
+'jdk6:java/util/prefs/FileSystemPreferences.java':[
+777,
+],
+'jdk6:java/util/regex/Pattern.java':[
+1005,
+1961,
+2562,
+2713,
+2723,
+2733,
+2918,
+2942,
+4114,
+4376,
+],
+'jdk6:java/util/zip/DeflaterInputStream.java':[
+161,
+176,
+],
+'jdk6:java/util/zip/DeflaterOutputStream.java':[
+52,
+106,
+],
+'jdk6:java/util/zip/InflaterInputStream.java':[
+67,
+130,
+],
+'jdk6:java/util/zip/InflaterOutputStream.java':[
+211,
+],
+'jdk6:java/util/zip/ZipInputStream.java':[
+145,
+],
+'jdk6:java/util/zip/ZipOutputStream.java':[
+162,
+262,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S1821.json b/its/ruling/src/test/resources/jdk6/squid-S1821.json
new file mode 100755
index 0000000000..bbf5e0f103
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S1821.json
@@ -0,0 +1,27 @@
+{
+'jdk6:java/awt/AWTEvent.java':[
+518,
+],
+'jdk6:java/io/ObjectInputStream.java':[
+3246,
+],
+'jdk6:java/lang/CharacterData00.java':[
+311,
+],
+'jdk6:java/lang/CharacterData01.java':[
+224,
+],
+'jdk6:java/net/SocksSocketImpl.java':[
+481,
+797,
+907,
+],
+'jdk6:java/text/MessageFormat.java':[
+1369,
+1388,
+1410,
+],
+'jdk6:java/util/Formatter.java':[
+3901,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S1871.json b/its/ruling/src/test/resources/jdk6/squid-S1871.json
index f64dd41b57..cdffb38dbc 100755
--- a/its/ruling/src/test/resources/jdk6/squid-S1871.json
+++ b/its/ruling/src/test/resources/jdk6/squid-S1871.json
@@ -7,6 +7,12 @@
 3450,
 3460,
 ],
+'jdk6:java/beans/MetaData.java':[
+526,
+],
+'jdk6:java/io/PushbackReader.java':[
+96,
+],
 'jdk6:java/lang/management/ThreadInfo.java':[
 599,
 ],
@@ -18,6 +24,9 @@
 'jdk6:java/net/URI.java':[
 2304,
 ],
+'jdk6:java/net/URLConnection.java':[
+1645,
+],
 'jdk6:java/text/PatternEntry.java':[
 150,
 ],
diff --git a/its/ruling/src/test/resources/jdk6/squid-S2761.json b/its/ruling/src/test/resources/jdk6/squid-S2761.json
new file mode 100755
index 0000000000..e2d724562f
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S2761.json
@@ -0,0 +1,11 @@
+{
+'jdk6:java/lang/Byte.java':[
+64,
+],
+'jdk6:java/lang/Long.java':[
+531,
+],
+'jdk6:java/lang/Short.java':[
+184,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S3366.json b/its/ruling/src/test/resources/jdk6/squid-S3366.json
new file mode 100755
index 0000000000..a76ca9ae0e
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S3366.json
@@ -0,0 +1,78 @@
+{
+'jdk6:java/awt/Checkbox.java':[
+185,
+701,
+],
+'jdk6:java/awt/Dialog.java':[
+659,
+710,
+],
+'jdk6:java/awt/List.java':[
+1276,
+1277,
+],
+'jdk6:java/awt/SequencedEvent.java':[
+56,
+],
+'jdk6:java/awt/TextComponent.java':[
+883,
+],
+'jdk6:java/awt/TrayIcon.java':[
+135,
+],
+'jdk6:java/awt/dnd/DropTarget.java':[
+93,
+],
+'jdk6:java/awt/font/TextAttribute.java':[
+252,
+],
+'jdk6:java/beans/beancontext/BeanContextChildSupport.java':[
+54,
+],
+'jdk6:java/io/ObjectStreamClass.java':[
+408,
+],
+'jdk6:java/io/Reader.java':[
+50,
+],
+'jdk6:java/io/Writer.java':[
+59,
+],
+'jdk6:java/net/ServerSocket.java':[
+60,
+],
+'jdk6:java/net/Socket.java':[
+122,
+127,
+150,
+],
+'jdk6:java/net/URL.java':[
+596,
+],
+'jdk6:java/security/Identity.java':[
+103,
+],
+'jdk6:java/text/AttributedCharacterIterator.java':[
+84,
+],
+'jdk6:java/text/DateFormat.java':[
+780,
+783,
+],
+'jdk6:java/text/NumberFormat.java':[
+1032,
+],
+'jdk6:java/util/Collections.java':[
+1549,
+1954,
+],
+'jdk6:java/util/concurrent/ConcurrentSkipListMap.java':[
+394,
+],
+'jdk6:java/util/logging/Level.java':[
+189,
+],
+'jdk6:java/util/prefs/AbstractPreferences.java':[
+187,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S3626.json b/its/ruling/src/test/resources/jdk6/squid-S3626.json
new file mode 100755
index 0000000000..7790dbb6c4
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S3626.json
@@ -0,0 +1,73 @@
+{
+'jdk6:java/awt/AWTEventMulticaster.java':[
+922,
+],
+'jdk6:java/awt/geom/CubicCurve2D.java':[
+1286,
+],
+'jdk6:java/awt/geom/QuadCurve2D.java':[
+1027,
+],
+'jdk6:java/awt/image/PixelGrabber.java':[
+379,
+394,
+410,
+],
+'jdk6:java/beans/Introspector.java':[
+1333,
+],
+'jdk6:java/beans/beancontext/BeanContextServicesSupport.java':[
+621,
+636,
+],
+'jdk6:java/beans/beancontext/BeanContextSupport.java':[
+612,
+630,
+],
+'jdk6:java/lang/ref/Finalizer.java':[
+162,
+],
+'jdk6:java/lang/reflect/Proxy.java':[
+444,
+],
+'jdk6:java/math/BigDecimal.java':[
+3530,
+],
+'jdk6:java/math/MathContext.java':[
+130,
+152,
+],
+'jdk6:java/net/DatagramSocket.java':[
+699,
+],
+'jdk6:java/net/PlainSocketImpl.java':[
+172,
+201,
+518,
+],
+'jdk6:java/net/SocketPermission.java':[
+427,
+],
+'jdk6:java/security/AccessControlContext.java':[
+383,
+],
+'jdk6:java/security/IdentityScope.java':[
+67,
+],
+'jdk6:java/security/Policy.java':[
+309,
+],
+'jdk6:java/text/DecimalFormat.java':[
+2551,
+2557,
+],
+'jdk6:java/util/concurrent/ThreadPoolExecutor.java':[
+1576,
+],
+'jdk6:java/util/jar/JarVerifier.java':[
+163,
+],
+'jdk6:java/util/jar/Manifest.java':[
+165,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S3923.json b/its/ruling/src/test/resources/jdk6/squid-S3923.json
deleted file mode 100755
index 1749e4ad0f..0000000000
--- a/its/ruling/src/test/resources/jdk6/squid-S3923.json
+++ /dev/null
@@ -1,11 +0,0 @@
-{
-'jdk6:java/beans/MetaData.java':[
-524,
-],
-'jdk6:java/io/PushbackReader.java':[
-94,
-],
-'jdk6:java/net/URLConnection.java':[
-1630,
-],
-}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S4201.json b/its/ruling/src/test/resources/jdk6/squid-S4201.json
new file mode 100755
index 0000000000..b26356056a
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S4201.json
@@ -0,0 +1,117 @@
+{
+'jdk6:java/awt/Component.java':[
+4602,
+9528,
+],
+'jdk6:java/awt/Container.java':[
+3701,
+3709,
+],
+'jdk6:java/awt/MenuComponent.java':[
+334,
+],
+'jdk6:java/awt/dnd/DropTarget.java':[
+758,
+],
+'jdk6:java/awt/image/AreaAveragingScaleFilter.java':[
+89,
+],
+'jdk6:java/awt/image/ComponentSampleModel.java':[
+1139,
+],
+'jdk6:java/awt/image/MultiPixelPackedSampleModel.java':[
+640,
+],
+'jdk6:java/awt/image/ReplicateScaleFilter.java':[
+111,
+179,
+220,
+],
+'jdk6:java/awt/image/SinglePixelPackedSampleModel.java':[
+743,
+],
+'jdk6:java/beans/IndexedPropertyDescriptor.java':[
+362,
+],
+'jdk6:java/beans/PropertyDescriptor.java':[
+419,
+],
+'jdk6:java/io/File.java':[
+1870,
+],
+'jdk6:java/lang/reflect/Constructor.java':[
+299,
+],
+'jdk6:java/lang/reflect/Field.java':[
+236,
+],
+'jdk6:java/lang/reflect/Method.java':[
+343,
+],
+'jdk6:java/net/DatagramPacket.java':[
+291,
+],
+'jdk6:java/net/Inet4Address.java':[
+333,
+],
+'jdk6:java/net/Inet6Address.java':[
+663,
+],
+'jdk6:java/net/InetSocketAddress.java':[
+278,
+],
+'jdk6:java/net/MulticastSocket.java':[
+343,
+390,
+],
+'jdk6:java/net/NetworkInterface.java':[
+443,
+],
+'jdk6:java/net/PlainDatagramSocketImpl.java':[
+203,
+221,
+260,
+269,
+275,
+280,
+288,
+295,
+299,
+303,
+],
+'jdk6:java/net/PlainSocketImpl.java':[
+191,
+236,
+244,
+252,
+258,
+265,
+270,
+275,
+],
+'jdk6:java/net/Proxy.java':[
+132,
+],
+'jdk6:java/net/SocksSocketImpl.java':[
+312,
+],
+'jdk6:java/rmi/MarshalledObject.java':[
+175,
+],
+'jdk6:java/security/CodeSigner.java':[
+111,
+],
+'jdk6:java/security/Timestamp.java':[
+106,
+],
+'jdk6:java/util/Scanner.java':[
+1845,
+1951,
+2081,
+2187,
+2311,
+2378,
+2480,
+2546,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S4248.json b/its/ruling/src/test/resources/jdk6/squid-S4248.json
new file mode 100755
index 0000000000..8b72a0309d
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S4248.json
@@ -0,0 +1,12 @@
+{
+'jdk6:java/util/Formatter.java':[
+2453,
+],
+'jdk6:java/util/Scanner.java':[
+402,
+406,
+409,
+484,
+491,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S4274.json b/its/ruling/src/test/resources/jdk6/squid-S4274.json
new file mode 100755
index 0000000000..807699409f
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S4274.json
@@ -0,0 +1,36 @@
+{
+'jdk6:java/awt/AWTKeyStroke.java':[
+857,
+858,
+859,
+865,
+870,
+],
+'jdk6:java/io/UnixFileSystem.java':[
+175,
+],
+'jdk6:java/text/BreakIterator.java':[
+674,
+],
+'jdk6:java/text/Collator.java':[
+522,
+],
+'jdk6:java/text/DateFormat.java':[
+945,
+],
+'jdk6:java/text/DateFormatSymbols.java':[
+748,
+],
+'jdk6:java/text/DecimalFormatSymbols.java':[
+809,
+],
+'jdk6:java/text/NumberFormat.java':[
+1126,
+],
+'jdk6:java/util/Currency.java':[
+389,
+],
+'jdk6:java/util/Locale.java':[
+1107,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S4351.json b/its/ruling/src/test/resources/jdk6/squid-S4351.json
new file mode 100755
index 0000000000..fffc66c513
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S4351.json
@@ -0,0 +1,8 @@
+{
+'jdk6:java/sql/Timestamp.java':[
+472,
+],
+'jdk6:java/util/Calendar.java':[
+2475,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S4524.json b/its/ruling/src/test/resources/jdk6/squid-S4524.json
new file mode 100755
index 0000000000..1984c4f9aa
--- /dev/null
+++ b/its/ruling/src/test/resources/jdk6/squid-S4524.json
@@ -0,0 +1,32 @@
+{
+'jdk6:java/awt/dnd/DragSourceContext.java':[
+453,
+],
+'jdk6:java/awt/geom/AffineTransform.java':[
+866,
+1024,
+1231,
+1618,
+1686,
+2330,
+2520,
+2636,
+2732,
+2866,
+2949,
+3024,
+3138,
+3233,
+3328,
+3434,
+3528,
+3660,
+3735,
+],
+'jdk6:java/awt/geom/CubicCurve2D.java':[
+1352,
+],
+'jdk6:java/awt/geom/QuadCurve2D.java':[
+1092,
+],
+}
diff --git a/its/ruling/src/test/resources/jdk6/squid-S899.json b/its/ruling/src/test/resources/jdk6/squid-S899.json
index 0ab61ec6bf..f8a504a6c5 100755
--- a/its/ruling/src/test/resources/jdk6/squid-S899.json
+++ b/its/ruling/src/test/resources/jdk6/squid-S899.json
@@ -17,9 +17,6 @@
 'jdk6:java/util/concurrent/PriorityBlockingQueue.java':[
 184,
 ],
-'jdk6:java/util/concurrent/ThreadPoolExecutor.java':[
-1189,
-],
 'jdk6:java/util/logging/FileHandler.java':[
 529,
 531,
diff --git a/its/ruling/src/test/resources/jdk6/squid-SwitchLastCaseIsDefaultCheck.json b/its/ruling/src/test/resources/jdk6/squid-SwitchLastCaseIsDefaultCheck.json
index 0ff2d5e7fa..493cf15f27 100755
--- a/its/ruling/src/test/resources/jdk6/squid-SwitchLastCaseIsDefaultCheck.json
+++ b/its/ruling/src/test/resources/jdk6/squid-SwitchLastCaseIsDefaultCheck.json
@@ -42,9 +42,6 @@
 'jdk6:java/awt/TextComponent.java':[
 685,
 ],
-'jdk6:java/awt/dnd/DragSourceContext.java':[
-453,
-],
 'jdk6:java/awt/event/KeyEvent.java':[
 1115,
 1341,
@@ -53,31 +50,12 @@
 841,
 ],
 'jdk6:java/awt/geom/AffineTransform.java':[
-866,
-1024,
-1231,
 1540,
 1574,
-1618,
-1686,
 1963,
 2026,
 2214,
-2330,
 2422,
-2520,
-2636,
-2732,
-2866,
-2949,
-3024,
-3138,
-3233,
-3328,
-3434,
-3528,
-3660,
-3735,
 ],
 'jdk6:java/awt/geom/ArcIterator.java':[
 51,
@@ -85,9 +63,6 @@
 'jdk6:java/awt/geom/Area.java':[
 134,
 ],
-'jdk6:java/awt/geom/CubicCurve2D.java':[
-1352,
-],
 'jdk6:java/awt/geom/FlatteningPathIterator.java':[
 196,
 ],
@@ -100,9 +75,6 @@
 1365,
 1858,
 ],
-'jdk6:java/awt/geom/QuadCurve2D.java':[
-1092,
-],
 'jdk6:java/awt/image/BandedSampleModel.java':[
 247,
 582,
@@ -128,9 +100,6 @@
 446,
 588,
 ],
-'jdk6:java/awt/image/PixelGrabber.java':[
-622,
-],
 'jdk6:java/awt/image/Raster.java':[
 889,
 897,
diff --git a/its/ruling/src/test/resources/sonar-server/squid-S126.json b/its/ruling/src/test/resources/sonar-server/squid-S126.json
new file mode 100755
index 0000000000..c38bc11d1a
--- /dev/null
+++ b/its/ruling/src/test/resources/sonar-server/squid-S126.json
@@ -0,0 +1,125 @@
+{
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/app/TomcatAccessLog.java':[
+73,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/app/TomcatContexts.java':[
+74,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/authentication/CredentialsAuthenticator.java':[
+92,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/api/measurecomputer/ComponentImpl.java':[
+50,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/formula/VariationSumFormula.java':[
+94,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/formula/counter/IntSumCounter.java':[
+63,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/formula/counter/LongSumCounter.java':[
+63,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/issue/IssueCounter.java':[
+246,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/qualitymodel/NewReliabilityAndSecurityRatingMeasuresVisitor.java':[
+162,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/qualitymodel/ReliabilityAndSecurityRatingMeasuresVisitor.java':[
+153,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/DuplicationMeasuresStep.java':[
+121,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/QualityGateMeasuresStep.java':[
+249,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/QualityProfileEventsStep.java':[
+124,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/SendIssueNotificationsStep.java':[
+98,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/debt/DebtRulesXMLImporter.java':[
+115,
+133,
+161,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/IssueQueryFactory.java':[
+230,
+262,
+356,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/index/IssueIndex.java':[
+242,
+250,
+446,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/ComponentTreeSort.java':[
+128,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/permission/ws/template/SetDefaultTemplateAction.java':[
+119,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/UrlSettings.java':[
+95,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/db/CheckDatabaseCharsetAtStartup.java':[
+45,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/ProjectStatusAction.java':[
+129,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/ShowAction.java':[
+88,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/QProfileBackuperImpl.java':[
+158,
+194,
+222,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/RuleActivator.java':[
+214,
+267,
+481,
+513,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/ws/AddProjectAction.java':[
+101,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/RegisterRules.java':[
+285,
+398,
+416,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/RuleCreator.java':[
+103,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/index/RuleIndex.java':[
+318,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/source/HtmlTextDecorator.java':[
+80,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/source/ws/LinesAction.java':[
+170,
+183,
+196,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/startup/RegisterMetrics.java':[
+92,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/UserUpdater.java':[
+291,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/GroupsAction.java':[
+155,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/usergroups/ws/UsersAction.java':[
+127,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/util/RubyUtils.java':[
+49,
+],
+}
diff --git a/its/ruling/src/test/resources/sonar-server/squid-S1312.json b/its/ruling/src/test/resources/sonar-server/squid-S1312.json
index 447a4d0fc5..90b090c96e 100755
--- a/its/ruling/src/test/resources/sonar-server/squid-S1312.json
+++ b/its/ruling/src/test/resources/sonar-server/squid-S1312.json
@@ -11,6 +11,9 @@
 'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/es/EsClient.java':[
 77,
 ],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/web/RootFilter.java':[
+49,
+],
 'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/SecurityRealmFactory.java':[
 81,
 ],
diff --git a/its/ruling/src/test/resources/sonar-server/squid-S4248.json b/its/ruling/src/test/resources/sonar-server/squid-S4248.json
new file mode 100755
index 0000000000..0eb7ca8f98
--- /dev/null
+++ b/its/ruling/src/test/resources/sonar-server/squid-S4248.json
@@ -0,0 +1,43 @@
+{
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/component/ws/SuggestionsAction.java':[
+252,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/debt/DebtModelXMLExporter.java':[
+102,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/es/Facets.java':[
+118,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/es/textsearch/ComponentTextSearchQueryFactory.java':[
+95,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/index/ProjectsTextSearchQueryFactory.java':[
+104,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/UrlSettings.java':[
+47,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/web/WebPagesFilter.java':[
+79,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/projecttag/ws/SetAction.java':[
+109,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/RuleCreator.java':[
+146,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/source/DecorationDataHolder.java':[
+46,
+48,
+58,
+60,
+71,
+73,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/UserUpdater.java':[
+291,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/util/MetricKeyValidator.java':[
+50,
+],
+}
diff --git a/its/ruling/src/test/resources/sonar-server/squid-S4449.json b/its/ruling/src/test/resources/sonar-server/squid-S4449.json
new file mode 100755
index 0000000000..1f53735e10
--- /dev/null
+++ b/its/ruling/src/test/resources/sonar-server/squid-S4449.json
@@ -0,0 +1,467 @@
+{
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/ce/queue/CeQueueImpl.java':[
+102,
+104,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/app/TomcatContexts.java':[
+62,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/authentication/OAuth2CallbackFilter.java':[
+99,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/ce/ws/ActivityAction.java':[
+166,
+176,
+190,
+216,
+252,
+257,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/ce/ws/SubmitAction.java':[
+101,
+106,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/ce/ws/TaskFormatter.java':[
+69,
+83,
+98,
+123,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/component/ComponentFinder.java':[
+113,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/component/ws/AppAction.java':[
+126,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/component/ws/ProjectMeasuresQueryFactory.java':[
+130,
+136,
+144,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/component/ws/SearchAction.java':[
+147,
+148,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/component/ws/SearchProjectsAction.java':[
+264,
+298,
+301,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/api/posttask/ConditionToCondition.java':[
+54,
+55,
+57,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/api/posttask/PostProjectAnalysisTasksExecutor.java':[
+124,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/component/ComponentRootBuilder.java':[
+113,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/duplication/IntegrateCrossProjectDuplications.java':[
+71,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/filemove/FileMoveDetectionStep.java':[
+194,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/issue/IssueAssigner.java':[
+83,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/issue/NewEffortCalculator.java':[
+84,
+88,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/measure/BestValueOptimization.java':[
+62,
+63,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/measure/MeasureDtoToMeasure.java':[
+42,
+44,
+46,
+48,
+120,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/qualitygate/EvaluationResultTextConverterImpl.java':[
+97,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/qualitymodel/RatingSettings.java':[
+126,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/ComputeMeasureVariationsStep.java':[
+154,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/CustomMeasuresCopyStep.java':[
+96,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/LoadCrossProjectDuplicationsRepositoryStep.java':[
+122,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/computation/task/projectanalysis/step/PersistComponentsStep.java':[
+240,
+242,
+243,
+245,
+292,
+293,
+306,
+307,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/debt/DebtRulesXMLImporter.java':[
+166,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/email/ws/SendAction.java':[
+76,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/favorite/FavoriteFinder.java':[
+57,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/favorite/ws/SearchAction.java':[
+90,
+90,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/IssueUpdater.java':[
+58,
+59,
+71,
+72,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/notification/AbstractNewIssuesEmailTemplate.java':[
+77,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/notification/DoNotFixNotificationDispatcher.java':[
+65,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/notification/MyNewIssuesNotificationDispatcher.java':[
+62,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/notification/NewIssuesStatistics.java':[
+104,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/ws/SearchAction.java':[
+344,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/ws/SearchResponseFormat.java':[
+173,
+270,
+272,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/ws/SearchResponseLoader.java':[
+210,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/ws/SetSeverityAction.java':[
+106,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/issue/ws/SetTypeAction.java':[
+106,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/custom/ws/CreateAction.java':[
+118,
+122,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/custom/ws/SearchAction.java':[
+109,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/custom/ws/UpdateAction.java':[
+93,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/ComponentAction.java':[
+154,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/ComponentDtoToWsComponent.java':[
+61,
+64,
+67,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/ComponentTreeAction.java':[
+215,
+217,
+218,
+230,
+236,
+250,
+267,
+268,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/ComponentTreeDataLoader.java':[
+189,
+263,
+265,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/ComponentTreeSort.java':[
+73,
+117,
+125,
+127,
+129,
+138,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/MetricDtoToWsMetric.java':[
+38,
+40,
+48,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/SearchAction.java':[
+125,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/measure/ws/SearchHistoryAction.java':[
+79,
+80,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/metric/DefaultMetricFinder.java':[
+101,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/metric/ws/CreateAction.java':[
+108,
+173,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/metric/ws/UpdateAction.java':[
+170,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/notification/email/AlertsEmailTemplate.java':[
+58,
+59,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/notification/ws/AddAction.java':[
+128,
+135,
+140,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/notification/ws/ListAction.java':[
+123,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/notification/ws/RemoveAction.java':[
+127,
+134,
+138,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/organization/ws/CreateAction.java':[
+105,
+106,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/organization/ws/SearchMyOrganizationsAction.java':[
+64,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/organization/ws/UpdateAction.java':[
+98,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/permission/GroupPermissionChanger.java':[
+151,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/permission/ws/PermissionWsSupport.java':[
+98,
+103,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/permission/ws/SearchProjectPermissionsDataLoader.java':[
+70,
+71,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/permission/ws/template/SetDefaultTemplateAction.java':[
+100,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/BackendCleanup.java':[
+116,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/platform/monitoring/SettingsMonitor.java':[
+54,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/plugins/PluginReferentialMetadataConverter.java':[
+64,
+65,
+66,
+67,
+68,
+69,
+70,
+71,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/CreateAction.java':[
+126,
+127,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/GhostsAction.java':[
+116,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/IndexAction.java':[
+125,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/ProvisionedAction.java':[
+106,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/SearchAction.java':[
+143,
+144,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/SearchMyProjectsAction.java':[
+93,
+94,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/project/ws/SearchMyProjectsDataLoader.java':[
+88,
+88,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/projectanalysis/ws/CreateEventAction.java':[
+165,
+167,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/CreateConditionAction.java':[
+99,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/GetByProjectAction.java':[
+81,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/ProjectStatusAction.java':[
+128,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/QualityGateDetailsFormatter.java':[
+78,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/SelectAction.java':[
+110,
+111,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualitygate/ws/UpdateConditionAction.java':[
+93,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/QProfileBackuperImpl.java':[
+164,
+199,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/RuleActivator.java':[
+254,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/RuleActivatorContextFactory.java':[
+63,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/ws/InheritanceAction.java':[
+105,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/ws/ProjectsAction.java':[
+105,
+135,
+140,
+142,
+144,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/qualityprofile/ws/SearchAction.java':[
+135,
+138,
+176,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/root/ws/SearchAction.java':[
+86,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/DeprecatedRulesDefinitionLoader.java':[
+96,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/RegisterRules.java':[
+229,
+232,
+282,
+286,
+423,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/RuleCreator.java':[
+165,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/RuleUpdater.java':[
+216,
+303,
+305,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/index/RuleIndex.java':[
+202,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/ws/CreateAction.java':[
+170,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/ws/RuleMapper.java':[
+100,
+136,
+137,
+265,
+268,
+274,
+286,
+294,
+358,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/ws/SearchAction.java':[
+343,
+345,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/rule/ws/UpdateAction.java':[
+278,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/setting/ws/ResetAction.java':[
+123,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/setting/ws/ValuesAction.java':[
+127,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/source/ws/ShowAction.java':[
+93,
+96,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/startup/RegisterMetrics.java':[
+150,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/test/ws/ListAction.java':[
+166,
+170,
+173,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/ui/ws/ComponentAction.java':[
+191,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/ChangePasswordAction.java':[
+100,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/CreateAction.java':[
+150,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/CurrentAction.java':[
+72,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/GroupsAction.java':[
+118,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/SearchAction.java':[
+117,
+125,
+125,
+185,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/SkipOnboardingTutorialAction.java':[
+59,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/user/ws/UserJsonWriter.java':[
+72,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/usertoken/ws/GenerateAction.java':[
+115,
+120,
+128,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/usertoken/ws/RevokeAction.java':[
+72,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/usertoken/ws/SearchAction.java':[
+75,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/util/ClassLoaderUtils.java':[
+95,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/webhook/ws/WebhookDeliveriesAction.java':[
+100,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/webhook/ws/WebhookWsSupport.java':[
+45,
+48,
+55,
+57,
+],
+'org.sonarsource.sonarqube:sonar-server:src/main/java/org/sonar/server/ws/JsonWriterUtils.java':[
+41,
+],
+}
diff --git a/its/semantic/java-debugging-plugin/pom.xml b/its/semantic/java-debugging-plugin/pom.xml
index 9e67732e91..29a8c99719 100755
--- a/its/semantic/java-debugging-plugin/pom.xml
+++ b/its/semantic/java-debugging-plugin/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>it-java-semantic</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-debugging-plugin</artifactId>
diff --git a/its/semantic/pom.xml b/its/semantic/pom.xml
index 53d78fefcb..0efba735ea 100755
--- a/its/semantic/pom.xml
+++ b/its/semantic/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java-its</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-semantic</artifactId>
diff --git a/its/semantic/tests/pom.xml b/its/semantic/tests/pom.xml
index d4e7725983..a8b212bfa5 100755
--- a/its/semantic/tests/pom.xml
+++ b/its/semantic/tests/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>it-java-semantic</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>it-java-semantic-tests</artifactId>
diff --git a/java-checks-testkit/pom.xml b/java-checks-testkit/pom.xml
index 54adaa8ef1..9bef2be83d 100755
--- a/java-checks-testkit/pom.xml
+++ b/java-checks-testkit/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-checks-testkit</artifactId>
@@ -39,5 +39,17 @@
       <artifactId>gson</artifactId>
       <scope>compile</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>org.sonarsource.sonarqube</groupId>
+      <artifactId>sonar-plugin-api</artifactId>
+    </dependency>
   </dependencies>
 </project>
diff --git a/java-checks-testkit/src/main/java/org/sonar/java/checks/verifier/CheckVerifier.java b/java-checks-testkit/src/main/java/org/sonar/java/checks/verifier/CheckVerifier.java
index 9e5a8aa01e..e6a90895b9 100755
--- a/java-checks-testkit/src/main/java/org/sonar/java/checks/verifier/CheckVerifier.java
+++ b/java-checks-testkit/src/main/java/org/sonar/java/checks/verifier/CheckVerifier.java
@@ -49,6 +49,7 @@
 import org.assertj.core.api.Fail;
 import org.sonar.api.batch.fs.internal.TestInputFileBuilder;
 import org.sonar.api.batch.sensor.internal.SensorContextTester;
+import org.sonar.api.config.internal.MapSettings;
 import org.sonar.api.internal.SonarRuntimeImpl;
 import org.sonar.api.utils.AnnotationUtils;
 import org.sonar.api.utils.Version;
@@ -181,6 +182,7 @@ public void checkIssues(Set<AnalyzerMessage> issues, boolean bypassNoIssue) {
 
   static SonarComponents sonarComponents(File file) {
     SensorContextTester context = SensorContextTester.create(new File("")).setRuntime(SonarRuntimeImpl.forSonarLint(Version.create(6, 7)));
+    context.setSettings(new MapSettings().setProperty("sonar.java.failOnException", true));
     SonarComponents sonarComponents = new SonarComponents(null, context.fileSystem(), null, null, null, null) {
       @Override
       public boolean reportAnalysisError(RecognitionException re, File file) {
diff --git a/java-checks/pom.xml b/java-checks/pom.xml
index 3b7c24ed30..5def6ae93e 100755
--- a/java-checks/pom.xml
+++ b/java-checks/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-checks</artifactId>
@@ -13,6 +13,10 @@
   <name>SonarQube Java :: Checks</name>
 
   <dependencies>
+    <dependency>
+      <groupId>org.sonarsource.sonarqube</groupId>
+      <artifactId>sonar-plugin-api</artifactId>
+    </dependency>
     <dependency>
       <groupId>${project.groupId}</groupId>
       <artifactId>java-frontend</artifactId>
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AbstractInjectionChecker.java b/java-checks/src/main/java/org/sonar/java/checks/AbstractInjectionChecker.java
index 179e42e106..1b4f90e317 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/AbstractInjectionChecker.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AbstractInjectionChecker.java
@@ -20,6 +20,10 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.Collection;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.java.resolve.SemanticModel;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
@@ -36,11 +40,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.Nullable;
-
-import java.util.Collection;
-import java.util.List;
-
 public abstract class AbstractInjectionChecker extends IssuableSubscriptionVisitor {
 
   protected String parameterName;
@@ -63,7 +62,12 @@ protected boolean isDynamicString(Tree methodTree, ExpressionTree arg, @Nullable
 
   protected boolean isDynamicString(Tree methodTree, ExpressionTree arg, @Nullable Symbol currentlyChecking, boolean firstLevel) {
     if (arg.is(Tree.Kind.MEMBER_SELECT)) {
-      return !isConstant(((MemberSelectExpressionTree) arg).identifier().symbol());
+      MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) arg;
+      IdentifierTree identifier = memberSelectExpressionTree.identifier();
+      if (ExpressionUtils.isSelectOnThisOrSuper(memberSelectExpressionTree)) {
+        return isIdentifierDynamicString(methodTree, identifier, currentlyChecking, firstLevel);
+      }
+      return !isConstant(identifier.symbol());
     } else if (arg.is(Tree.Kind.IDENTIFIER)) {
       return isIdentifierDynamicString(methodTree, (IdentifierTree) arg, currentlyChecking, firstLevel);
     } else if (arg.is(Tree.Kind.PLUS)) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AllBranchesAreIdenticalCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AllBranchesAreIdenticalCheck.java
index 3cb788d4ac..a14507424c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/AllBranchesAreIdenticalCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AllBranchesAreIdenticalCheck.java
@@ -48,12 +48,12 @@ public void visitNode(Tree tree) {
     if (tree.is(Tree.Kind.SWITCH_STATEMENT)) {
       SwitchStatementTree switchStatement = (SwitchStatementTree) tree;
       Multimap<CaseGroupTree, CaseGroupTree> identicalBranches = checkSwitchStatement(switchStatement);
-      if (allBranchesSame(identicalBranches, switchStatement.cases().size())) {
-        reportIssue(((SwitchStatementTree) tree).switchKeyword(), IF_SWITCH_MSG);
+      if (hasDefaultClause(switchStatement) && allBranchesSame(identicalBranches, switchStatement.cases().size())) {
+        reportIssue(switchStatement.switchKeyword(), IF_SWITCH_MSG);
       }
     } else if (tree.is(Tree.Kind.IF_STATEMENT)) {
-      if (!tree.parent().is(Tree.Kind.IF_STATEMENT)) {
-        IfStatementTree ifStatementTree = (IfStatementTree) tree;
+      IfStatementTree ifStatementTree = (IfStatementTree) tree;
+      if (hasElseClause(ifStatementTree) && !tree.parent().is(Tree.Kind.IF_STATEMENT)) {
         IfElseChain ifElseChain = checkIfStatement(ifStatementTree);
         if (allBranchesSame(ifElseChain.branches, ifElseChain.totalBranchCount)) {
           reportIssue(ifStatementTree.ifKeyword(), IF_SWITCH_MSG);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AnonymousClassShouldBeLambdaCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AnonymousClassShouldBeLambdaCheck.java
index be8ffc0029..baba5c99a7 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/AnonymousClassShouldBeLambdaCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AnonymousClassShouldBeLambdaCheck.java
@@ -20,12 +20,17 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.Lists;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
 import org.sonar.check.Rule;
 import org.sonar.java.JavaVersionAwareVisitor;
+import org.sonar.java.resolve.ClassJavaType;
 import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.JavaVersion;
+import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.ClassTree;
 import org.sonar.plugins.java.api.tree.EnumConstantTree;
@@ -36,11 +41,10 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TypeTree;
 
-import java.util.List;
-
 @Rule(key = "S1604")
 public class AnonymousClassShouldBeLambdaCheck extends BaseTreeVisitor implements JavaFileScanner, JavaVersionAwareVisitor {
 
+  private static final String JAVA_LANG_OBJECT = "java.lang.Object";
   private JavaFileScannerContext context;
   private List<IdentifierTree> enumConstants;
 
@@ -76,14 +80,36 @@ public void visitNewClass(NewClassTree tree) {
   }
 
   private static boolean isSAM(ClassTree classBody) {
-    if(hasOnlyOneMethod(classBody.members()) && classBody.symbol().isTypeSymbol()) {
-      // Verify class body is a subtype of an interface
+    if (hasOnlyOneMethod(classBody.members())) {
       JavaSymbol.TypeJavaSymbol symbol = (JavaSymbol.TypeJavaSymbol) classBody.symbol();
-      return symbol.getInterfaces().size() == 1 && symbol.getSuperclass().is("java.lang.Object");
+      // should be anonymous class of interface and not abstract class
+      return symbol.getInterfaces().size() == 1
+        && symbol.getSuperclass().is(JAVA_LANG_OBJECT)
+        && hasSingleAbstractMethodInHierarchy(symbol.superTypes());
     }
     return false;
   }
 
+  private static boolean hasSingleAbstractMethodInHierarchy(Set<ClassJavaType> superTypes) {
+    return superTypes.stream()
+      .filter(type -> !type.is(JAVA_LANG_OBJECT))
+      .map(ClassJavaType::getSymbol)
+      // collect all the methods declared in hierarchy
+      .flatMap(superType -> superType.memberSymbols().stream().filter(Symbol::isMethodSymbol).filter(Symbol::isAbstract))
+      .map(JavaSymbol.MethodJavaSymbol.class::cast)
+      // remove objects methods redefined in interfaces
+      .filter(symbol -> !isObjectMethod(symbol))
+      // always take same symbol if method is redeclared over and over in hierarchy
+      .map(symbol -> symbol.overriddenSymbol() != null ? symbol.overriddenSymbol() : symbol)
+      .collect(Collectors.toSet())
+      .size() == 1;
+  }
+
+  private static boolean isObjectMethod(JavaSymbol.MethodJavaSymbol methodSymbol) {
+    Symbol overridenSymbol = methodSymbol.overriddenSymbol();
+    return overridenSymbol != null && overridenSymbol.owner().type().is(JAVA_LANG_OBJECT);
+  }
+
   private static boolean hasOnlyOneMethod(List<Tree> members) {
     MethodTree methodTree = null;
     for (Tree tree : members) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java
index 31785b05c3..e6119f442e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ArrayHashCodeAndToStringCheck.java
@@ -20,16 +20,14 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
-
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2116")
 public class ArrayHashCodeAndToStringCheck extends AbstractMethodDetection {
 
@@ -49,6 +47,6 @@ private static MethodMatcher arrayMethodInvocation(String methodName) {
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
     String methodName = mit.symbol().name();
-    reportIssue(MethodsHelper.methodName(mit), "Use \"Arrays." + methodName + "(array)\" instead.");
+    reportIssue(ExpressionUtils.methodName(mit), "Use \"Arrays." + methodName + "(array)\" instead.");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertOnBooleanVariableCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertOnBooleanVariableCheck.java
index 4191d6dae0..8b157fb867 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertOnBooleanVariableCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertOnBooleanVariableCheck.java
@@ -19,8 +19,11 @@
  */
 package org.sonar.java.checks;
 
+import java.util.Collections;
+import java.util.List;
+import java.util.regex.Pattern;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.AssertStatementTree;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
@@ -30,10 +33,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import java.util.Collections;
-import java.util.List;
-import java.util.regex.Pattern;
-
 @Rule(key = "S3346")
 public class AssertOnBooleanVariableCheck extends IssuableSubscriptionVisitor {
 
@@ -53,7 +52,7 @@ public void visitNode(Tree tree) {
 
     @Override
     public void visitMethodInvocation(MethodInvocationTree tree) {
-      IdentifierTree methodNameTree = MethodsHelper.methodName(tree);
+      IdentifierTree methodNameTree = ExpressionUtils.methodName(tree);
       if (SIDE_EFFECT_METHOD_NAMES.matcher(methodNameTree.name()).find()) {
         reportIssue(methodNameTree, "Move this \"assert\" side effect to another statement.");
       } else {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java
index 0f2a75bdd0..b1837db84c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertionInThreadRunCheck.java
@@ -20,8 +20,9 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
@@ -30,8 +31,6 @@
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2186")
 public class AssertionInThreadRunCheck extends IssuableSubscriptionVisitor {
 
@@ -65,7 +64,7 @@ public void visitMethodInvocation(MethodInvocationTree tree) {
       if(tree.symbol().isMethodSymbol()) {
         Type type = tree.symbol().owner().type();
         if (isCheckedType(type)) {
-          reportIssue(MethodsHelper.methodName(tree), "Remove this assertion.");
+          reportIssue(ExpressionUtils.methodName(tree), "Remove this assertion.");
         }
       }
       super.visitMethodInvocation(tree);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/AssertsOnParametersOfPublicMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/AssertsOnParametersOfPublicMethodCheck.java
new file mode 100755
index 0000000000..c5e81c4f7d
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/AssertsOnParametersOfPublicMethodCheck.java
@@ -0,0 +1,79 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.sonar.check.Rule;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.JavaFileScannerContext;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.tree.AssertStatementTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.VariableTree;
+
+@Rule(key = "S4274")
+public class AssertsOnParametersOfPublicMethodCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.METHOD, Tree.Kind.CONSTRUCTOR);
+  }
+
+  private Set<AssertStatementTree> assertReported = new HashSet<>();
+
+  @Override
+  public void scanFile(JavaFileScannerContext context) {
+    assertReported.clear();
+    super.scanFile(context);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (!hasSemantic()) {
+      return;
+    }
+    MethodTree methodTree = (MethodTree) tree;
+    if (!methodTree.symbol().isPublic()) {
+      return;
+    }
+    methodTree.parameters().stream()
+      .map(VariableTree::symbol)
+      .map(Symbol::usages)
+      .flatMap(List::stream)
+      .forEach(parameter -> checkUsage(parameter, methodTree));
+  }
+
+  private void checkUsage(IdentifierTree parameterUsage, MethodTree methodTree) {
+    Tree parameterParent = parameterUsage.parent();
+    while (!parameterParent.equals(methodTree) && !assertReported.contains(parameterParent)) {
+      if (parameterParent.is(Tree.Kind.ASSERT_STATEMENT)) {
+        assertReported.add((AssertStatementTree) parameterParent);
+        reportIssue(parameterParent, "Replace this assert with a proper check.");
+        return;
+      }
+      parameterParent = parameterParent.parent();
+    }
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CallOuterPrivateMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CallOuterPrivateMethodCheck.java
index e653c66ae0..1b2ee508f0 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CallOuterPrivateMethodCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CallOuterPrivateMethodCheck.java
@@ -29,7 +29,7 @@
 import java.util.Map;
 import javax.annotation.Nullable;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.model.JavaTree;
 import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
@@ -89,7 +89,7 @@ public void setClassSymbol(Symbol.TypeSymbol classSymbol) {
     public void visitMethodInvocation(MethodInvocationTree tree) {
       Symbol symbol = tree.symbol();
       if(symbol.isUnknown()) {
-        unknownInvocations.put(MethodsHelper.methodName(tree).name(), tree);
+        unknownInvocations.put(ExpressionUtils.methodName(tree).name(), tree);
       } else if (isPrivateMethodOfOuterClass(symbol)) {
         usages.add(symbol);
       }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CallSuperMethodFromInnerClassCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CallSuperMethodFromInnerClassCheck.java
index cd91b1e9a7..c878cc7003 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CallSuperMethodFromInnerClassCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CallSuperMethodFromInnerClassCheck.java
@@ -20,8 +20,9 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -31,8 +32,6 @@
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2388")
 public class CallSuperMethodFromInnerClassCheck extends IssuableSubscriptionVisitor {
 
@@ -72,7 +71,7 @@ public void visitMethodInvocation(MethodInvocationTree tree) {
       Symbol symbol = tree.symbol();
       if (tree.methodSelect().is(Tree.Kind.IDENTIFIER) && isCallToSuperclassMethod(symbol)) {
         String methodName = ((IdentifierTree) tree.methodSelect()).name();
-        reportIssue(MethodsHelper.methodName(tree), "Prefix this call to \"" + methodName + "\" with \"super.\".");
+        reportIssue(ExpressionUtils.methodName(tree), "Prefix this call to \"" + methodName + "\" with \"super.\".");
       }
       super.visitMethodInvocation(tree);
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CallToFileDeleteOnExitMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CallToFileDeleteOnExitMethodCheck.java
index 4c518cea18..9e069d0287 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CallToFileDeleteOnExitMethodCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CallToFileDeleteOnExitMethodCheck.java
@@ -20,15 +20,14 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "CallToFileDeleteOnExitMethod")
 @RspecKey("S2308")
 public class CallToFileDeleteOnExitMethodCheck extends AbstractMethodDetection {
@@ -40,6 +39,6 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove this call to \"deleteOnExit\".");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove this call to \"deleteOnExit\".");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CheckList.java b/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
index e2f2408873..c528175135 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CheckList.java
@@ -42,6 +42,7 @@
 import org.sonar.java.checks.naming.MethodNameSameAsClassCheck;
 import org.sonar.java.checks.naming.MethodNamedEqualsCheck;
 import org.sonar.java.checks.naming.MethodNamedHashcodeOrEqualCheck;
+import org.sonar.java.checks.security.HostnameVerifierImplementationCheck;
 import org.sonar.java.checks.serialization.CustomSerializationMethodCheck;
 import org.sonar.java.checks.serialization.ExternalizableClassConstructorCheck;
 import org.sonar.java.checks.serialization.PrivateReadResolveCheck;
@@ -92,6 +93,7 @@
 import org.sonar.java.se.checks.NonNullSetToNullCheck;
 import org.sonar.java.se.checks.NullDereferenceCheck;
 import org.sonar.java.se.checks.OptionalGetBeforeIsPresentCheck;
+import org.sonar.java.se.checks.ParameterNullnessCheck;
 import org.sonar.java.se.checks.RedundantAssignmentsCheck;
 import org.sonar.java.se.checks.StreamConsumedCheck;
 import org.sonar.java.se.checks.StreamNotConsumedCheck;
@@ -379,7 +381,8 @@ private CheckList() {
       .add(PrimitiveWrappersInTernaryOperatorCheck.class)
       .add(SynchronizedLockCheck.class)
       .add(SymmetricEqualsCheck.class)
-      .add(UnconditionalJumpStatementCheck.class)
+      .add(LoopExecutingAtMostOnceCheck.class)
+      .add(RedundantJumpCheck.class)
       .add(CallSuperMethodFromInnerClassCheck.class)
       .add(SelectorMethodArgumentCheck.class)
       .add(ThreadAsRunnableArgumentCheck.class)
@@ -455,6 +458,7 @@ private CheckList() {
       .add(ChangeMethodContractCheck.class)
       .add(CatchRethrowingCheck.class)
       .add(InappropriateRegexpCheck.class)
+      .add(WeakSSLContextCheck.class)
       .add(CallOuterPrivateMethodCheck.class)
       .add(SubClassStaticReferenceCheck.class)
       .add(InterruptedExceptionCheck.class)
@@ -525,6 +529,19 @@ private CheckList() {
       .add(PredictableSeedCheck.class)
       .add(RedundantStreamCollectCheck.class)
       .add(GettersSettersOnRightFieldCheck.class)
+      .add(ParameterNullnessCheck.class)
+      .add(DoublePrefixOperatorCheck.class)
+      .add(CompareToNotOverloadedCheck.class)
+      .add(EqualsParametersMarkedNonNullCheck.class)
+      .add(NestedSwitchStatementCheck.class)
+      .add(ThisExposedFromConstructorCheck.class)
+      .add(IfElseIfStatementEndsWithElseCheck.class)
+      .add(MethodParametersOrderCheck.class)
+      .add(AssertsOnParametersOfPublicMethodCheck.class)
+      .add(NullCheckWithInstanceofCheck.class)
+      .add(HostnameVerifierImplementationCheck.class)
+      .add(SwitchDefaultLastCaseCheck.class)
+      .add(RegexPatternsNeedlesslyCheck.class)
       .build();
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java
index 8d1c3eeeb4..e7fd168b4e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CollectionInappropriateCallsCheck.java
@@ -21,12 +21,14 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
-
+import java.text.MessageFormat;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.java.resolve.JavaType;
 import org.sonar.java.resolve.ParametrizedTypeJavaType;
@@ -39,11 +41,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import javax.annotation.Nullable;
-
-import java.text.MessageFormat;
-import java.util.List;
-
 @Rule(key = "S2175")
 public class CollectionInappropriateCallsCheck extends AbstractMethodDetection {
 
@@ -83,7 +80,7 @@ protected void onMethodInvocationFound(MethodInvocationTree tree) {
       && !collectionParameterType.isUnknown()
       && !isCallToParametrizedOrUnknownMethod
       && !isArgumentCompatible(argumentType, collectionParameterType)) {
-      reportIssue(MethodsHelper.methodName(tree), MessageFormat.format("A \"{0}<{1}>\" cannot contain a \"{2}\"", collectionType, collectionParameterType, argumentType));
+      reportIssue(ExpressionUtils.methodName(tree), MessageFormat.format("A \"{0}<{1}>\" cannot contain a \"{2}\"", collectionType, collectionParameterType, argumentType));
     }
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CollectionMethodsWithLinearComplexityCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CollectionMethodsWithLinearComplexityCheck.java
index 0e10ee30c9..d3e36fe679 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CollectionMethodsWithLinearComplexityCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CollectionMethodsWithLinearComplexityCheck.java
@@ -21,11 +21,17 @@
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Stream;
+import javax.annotation.CheckForNull;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -37,15 +43,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.CheckForNull;
-
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import java.util.stream.Stream;
-
 @Rule(key = "S2250")
 public class CollectionMethodsWithLinearComplexityCheck extends IssuableSubscriptionVisitor {
 
@@ -93,7 +90,7 @@ public void visitNode(Tree tree) {
       if (methodMatcher.matches(mit) && invocationInMethod(mit)) {
         Symbol target = invocationTarget(mit);
         if (target != null && isField(target) && matchesActualType(target, actualTypes)) {
-          IdentifierTree methodName = MethodsHelper.methodName(mit);
+          IdentifierTree methodName = ExpressionUtils.methodName(mit);
           reportIssue(methodName, "This call to \"" + methodName.name() + "()\" may be a performance hot spot if the collection is large.");
         }
       }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CommentRegularExpressionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CommentRegularExpressionCheck.java
index 0c9246b926..3a22ae9796 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/CommentRegularExpressionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/CommentRegularExpressionCheck.java
@@ -21,20 +21,17 @@
 
 import com.google.common.base.Strings;
 import com.google.common.collect.ImmutableList;
+import java.util.List;
+import java.util.regex.Pattern;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.check.RuleProperty;
 import org.sonar.java.IllegalRuleParameterException;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.SyntaxTrivia;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.annotations.RuleTemplate;
-
-import javax.annotation.Nullable;
-import java.util.List;
-import java.util.regex.Pattern;
 
 @Rule(key = "S124")
-@RuleTemplate
 public class CommentRegularExpressionCheck extends IssuableSubscriptionVisitor {
 
   private static final String DEFAULT_REGULAR_EXPRESSION = "";
diff --git a/java-checks/src/main/java/org/sonar/java/checks/CompareToNotOverloadedCheck.java b/java-checks/src/main/java/org/sonar/java/checks/CompareToNotOverloadedCheck.java
new file mode 100755
index 0000000000..33f562271e
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/CompareToNotOverloadedCheck.java
@@ -0,0 +1,60 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.java.resolve.ClassJavaType;
+import org.sonar.java.resolve.ParametrizedTypeJavaType;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S4351")
+public class CompareToNotOverloadedCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.METHOD);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    MethodTree methodTree = (MethodTree) tree;
+    if (hasSemantic() && isCompareToMethod(methodTree) && Boolean.FALSE.equals(methodTree.isOverriding())) {
+      ClassJavaType ownerType = (ClassJavaType) methodTree.symbol().owner().type();
+      ownerType.superTypes().stream().filter(supertype -> supertype.is("java.lang.Comparable")).findFirst().ifPresent(
+        comparableType -> {
+          String name = "Object";
+          if (comparableType.isParameterized()) {
+            ParametrizedTypeJavaType ptjt = (ParametrizedTypeJavaType) comparableType;
+            name = ptjt.substitution(ptjt.typeParameters().get(0)).symbol().name();
+          }
+          reportIssue(methodTree.parameters().get(0), "Refactor this method so that its argument is of type '" + name + "'.");
+        });
+    }
+  }
+
+  private static boolean isCompareToMethod(MethodTree tree) {
+    return "compareTo".equals(tree.simpleName().name()) && tree.parameters().size() == 1;
+  }
+
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ConstructorCallingOverridableCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ConstructorCallingOverridableCheck.java
index dc633365d2..935ab2b5a7 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ConstructorCallingOverridableCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ConstructorCallingOverridableCheck.java
@@ -20,9 +20,11 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.resolve.JavaSymbol.TypeJavaSymbol;
 import org.sonar.java.resolve.ClassJavaType;
+import org.sonar.java.resolve.JavaSymbol;
+import org.sonar.java.resolve.JavaSymbol.TypeJavaSymbol;
 import org.sonar.java.resolve.SemanticModel;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
@@ -30,16 +32,14 @@
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
 import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
-import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
 import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import java.util.List;
-
 @Rule(key = "S1699")
 public class ConstructorCallingOverridableCheck extends IssuableSubscriptionVisitor {
 
@@ -88,7 +88,7 @@ public void visitMethodInvocation(MethodInvocationTree tree) {
       }
       if (isInvocationOnSelf) {
         Symbol symbol = methodIdentifier.symbol();
-        if (isOverridableMethod(symbol) && isMethodDefinedOnConstructedType(symbol)) {
+        if (symbol.isMethodSymbol() && ((JavaSymbol.MethodJavaSymbol) symbol).isOverridable() && isMethodDefinedOnConstructedType(symbol)) {
           reportIssue(methodIdentifier, "Remove this call from a constructor to the overridable \"" + methodIdentifier.name() + "\" method.");
         }
       }
@@ -130,10 +130,6 @@ private boolean isMethodDefinedOnConstructedType(Symbol symbol) {
       }
       return constructorType.equals(methodEnclosingClass);
     }
-
-    private boolean isOverridableMethod(Symbol symbol) {
-      return symbol.isMethodSymbol() && !symbol.isPrivate() && !symbol.isFinal() && !symbol.isStatic();
-    }
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DateUtilsTruncateCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DateUtilsTruncateCheck.java
index 19652b60d3..901a039221 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DateUtilsTruncateCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DateUtilsTruncateCheck.java
@@ -20,16 +20,15 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
 import org.sonar.java.JavaVersionAwareVisitor;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2718")
 public class DateUtilsTruncateCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {
 
@@ -48,7 +47,7 @@ public boolean isCompatibleWithJavaVersion(JavaVersion version) {
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Use \"Instant.truncatedTo\" instead." + context.getJavaVersion().java8CompatibilityMessage());
+    reportIssue(ExpressionUtils.methodName(mit), "Use \"ZonedDateTime.truncatedTo\" instead." + context.getJavaVersion().java8CompatibilityMessage());
   }
 
   private static MethodMatcher truncateMethodMatcher(String firstParameterType) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DefaultEncodingUsageCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DefaultEncodingUsageCheck.java
index a80eaee317..ed631db15a 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DefaultEncodingUsageCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DefaultEncodingUsageCheck.java
@@ -22,8 +22,11 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.MethodMatcherCollection;
@@ -40,11 +43,6 @@
 import org.sonar.plugins.java.api.tree.TypeCastTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import java.util.List;
-import java.util.Set;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
-
 @Rule(key = "S1943")
 public class DefaultEncodingUsageCheck extends AbstractMethodDetection {
 
@@ -137,7 +135,7 @@ public void visitNode(Tree tree) {
         }
       } else if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
         MethodInvocationTree mit = (MethodInvocationTree) tree;
-        checkForbiddenTypes(MethodsHelper.methodName(mit), mit.symbolType());
+        checkForbiddenTypes(ExpressionUtils.methodName(mit), mit.symbolType());
       }
     }
   }
@@ -203,7 +201,7 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
     } else if (FILEUTILS_WRITE_WITH_CHARSET_MATCHERS.anyMatch(mit)) {
       testNullLiteralPassedForEncoding(mit.arguments().get(2));
     } else {
-      reportIssue(MethodsHelper.methodName(mit), "Remove this use of \"" + mit.symbol().name() + "\"");
+      reportIssue(ExpressionUtils.methodName(mit), "Remove this use of \"" + mit.symbol().name() + "\"");
     }
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java
index 02a436947a..7d0bb823d9 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DeprecatedHashAlgorithmCheck.java
@@ -22,25 +22,24 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableList.Builder;
 import com.google.common.collect.ImmutableMap;
-
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Optional;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.helpers.JavaPropertiesHelper;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.LiteralTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.Arrays;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Optional;
-
 import static org.sonar.java.checks.DeprecatedHashAlgorithmCheck.InsecureAlgorithm.MD2;
 import static org.sonar.java.checks.DeprecatedHashAlgorithmCheck.InsecureAlgorithm.MD5;
 import static org.sonar.java.checks.DeprecatedHashAlgorithmCheck.InsecureAlgorithm.SHA1;
@@ -139,13 +138,13 @@ boolean match(String algorithm) {
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    String methodName = MethodsHelper.methodName(mit).name();
-    InsecureAlgorithm algorithm = ALGORITHM_BY_METHOD_NAME.get(methodName);
+    IdentifierTree methodName = ExpressionUtils.methodName(mit);
+    InsecureAlgorithm algorithm = ALGORITHM_BY_METHOD_NAME.get(methodName.name());
     if (algorithm == null) {
       algorithm = algorithm(mit.arguments().get(0)).orElse(null);
     }
     if (algorithm != null) {
-      reportIssue(MethodsHelper.methodName(mit), "Use a stronger hashing algorithm than " + algorithm.toString() + ".");
+      reportIssue(methodName, "Use a stronger hashing algorithm than " + algorithm.toString() + ".");
     }
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DisallowedClassCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DisallowedClassCheck.java
index c4d5d739ee..aa221ab2e7 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DisallowedClassCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DisallowedClassCheck.java
@@ -33,9 +33,7 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TypeTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
-import org.sonar.squidbridge.annotations.RuleTemplate;
 
-@RuleTemplate
 @Rule(key = "S3688")
 public class DisallowedClassCheck extends BaseTreeVisitor implements JavaFileScanner {
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DisallowedConstructorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DisallowedConstructorCheck.java
index a41b9e2319..5f2b5c033f 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DisallowedConstructorCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DisallowedConstructorCheck.java
@@ -19,19 +19,16 @@
  */
 package org.sonar.java.checks;
 
+import java.util.Collections;
+import java.util.List;
 import org.apache.commons.lang.StringUtils;
 import org.sonar.check.Rule;
 import org.sonar.check.RuleProperty;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.plugins.java.api.tree.NewClassTree;
-import org.sonar.squidbridge.annotations.RuleTemplate;
-
-import java.util.Collections;
-import java.util.List;
 
 @Rule(key = "S4011")
-@RuleTemplate
 public class DisallowedConstructorCheck extends AbstractMethodDetection {
 
   @RuleProperty(key = "className", description = "Name of the class whose constructor is forbidden. This parameter is mandatory, if absent the rule is disabled.")
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DisallowedMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DisallowedMethodCheck.java
index 69dce01a8f..079a119a8e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DisallowedMethodCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DisallowedMethodCheck.java
@@ -20,19 +20,16 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.apache.commons.lang.StringUtils;
 import org.sonar.check.Rule;
 import org.sonar.check.RuleProperty;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
-import org.sonar.squidbridge.annotations.RuleTemplate;
-
-import java.util.List;
 
 @Rule(key = "S2253")
-@RuleTemplate
 public class DisallowedMethodCheck extends AbstractMethodDetection {
 
   @RuleProperty(key = "className", description = "Name of the class whose method is forbidden")
@@ -73,7 +70,7 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove this forbidden call");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove this forbidden call");
   }
 
   public void setClassName(String className) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DoublePrefixOperatorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DoublePrefixOperatorCheck.java
new file mode 100755
index 0000000000..83b06badc9
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/DoublePrefixOperatorCheck.java
@@ -0,0 +1,82 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.sonar.check.Rule;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.JavaFileScannerContext;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.Tree.Kind;
+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
+
+@Rule(key = "S2761")
+public class DoublePrefixOperatorCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.LOGICAL_COMPLEMENT, Tree.Kind.BITWISE_COMPLEMENT, Tree.Kind.UNARY_PLUS, Tree.Kind.UNARY_MINUS);
+  }
+
+  private Set<ExpressionTree> prefixSet = new HashSet<>();
+
+  @Override
+  public void scanFile(JavaFileScannerContext context) {
+    prefixSet.clear();
+    super.scanFile(context);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    UnaryExpressionTree exprTree = (UnaryExpressionTree) tree;
+    if (alreadyReported(exprTree)) {
+      return;
+    }
+    ExpressionTree expr = ExpressionUtils.skipParentheses(exprTree.expression());
+    if (exprTree.is(expr.kind())) {
+      UnaryExpressionTree child = (UnaryExpressionTree) expr;
+      if (child.is(Tree.Kind.BITWISE_COMPLEMENT) && !ExpressionUtils.skipParentheses(child.expression()).is(Tree.Kind.BITWISE_COMPLEMENT)) {
+        return;
+      }
+      prefixSet.add(child);
+      reportIssue(exprTree.operatorToken(), child.operatorToken(), "Remove multiple operator prefixes.");
+    }
+  }
+
+  private boolean alreadyReported(UnaryExpressionTree tree) {
+    if (prefixSet.contains(tree)) {
+      return true;
+    }
+    Tree parent = tree;
+    while (parent.is(Tree.Kind.PARENTHESIZED_EXPRESSION, Tree.Kind.BITWISE_COMPLEMENT, Tree.Kind.LOGICAL_COMPLEMENT, Tree.Kind.UNARY_PLUS, Tree.Kind.UNARY_MINUS)) {
+      parent = parent.parent();
+      if (prefixSet.contains(parent)) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java b/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java
index bebafe34dd..f43a189e9e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/DynamicClassLoadCheck.java
@@ -20,15 +20,14 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2658")
 public class DynamicClassLoadCheck extends AbstractMethodDetection {
 
@@ -42,7 +41,7 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove this use of dynamic class loading.");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove this use of dynamic class loading.");
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/EmptyStatementUsageCheck.java b/java-checks/src/main/java/org/sonar/java/checks/EmptyStatementUsageCheck.java
index e26fead647..45570f8fe3 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/EmptyStatementUsageCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/EmptyStatementUsageCheck.java
@@ -20,7 +20,6 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
-
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
@@ -40,7 +39,7 @@
 
   @Override
   public void visitNode(Tree tree) {
-    if (usedForEmptyEnum(tree)) {
+    if (usedForEmptyEnum(tree) || uniqueStatementOfLoop(tree)) {
       return;
     }
     reportIssue(tree, "Remove this empty statement.");
@@ -48,9 +47,13 @@ public void visitNode(Tree tree) {
 
   private static boolean usedForEmptyEnum(Tree tree) {
     Tree parent = tree.parent();
-    if(parent.is(Tree.Kind.ENUM)) {
+    if (parent.is(Tree.Kind.ENUM)) {
       return ((ClassTree) parent).members().indexOf(tree) == 0;
     }
     return false;
   }
+
+  private static boolean uniqueStatementOfLoop(Tree tree) {
+    return tree.parent().is(Tree.Kind.WHILE_STATEMENT, Tree.Kind.FOR_EACH_STATEMENT, Tree.Kind.FOR_STATEMENT, Tree.Kind.DO_STATEMENT);
+  }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java b/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java
index a1c3422982..1aaed2a186 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/EqualsOnAtomicClassCheck.java
@@ -20,15 +20,14 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2204")
 public class EqualsOnAtomicClassCheck extends AbstractMethodDetection {
 
@@ -49,7 +48,7 @@ private static MethodMatcher equalsInvocationMatcher(String fullyQualifiedName)
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Use \".get()\" to retrieve the value and compare it instead.");
+    reportIssue(ExpressionUtils.methodName(mit), "Use \".get()\" to retrieve the value and compare it instead.");
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/EqualsParametersMarkedNonNullCheck.java b/java-checks/src/main/java/org/sonar/java/checks/EqualsParametersMarkedNonNullCheck.java
new file mode 100755
index 0000000000..ec4e08ec56
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/EqualsParametersMarkedNonNullCheck.java
@@ -0,0 +1,57 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.java.se.NullableAnnotationUtils;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.Tree.Kind;
+import org.sonar.plugins.java.api.tree.VariableTree;
+
+@Rule(key = "S4454")
+public class EqualsParametersMarkedNonNullCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.METHOD);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (!hasSemantic()) {
+      return;
+    }
+    MethodTree methodTree = (MethodTree) tree;
+    List<VariableTree> params = methodTree.parameters();
+    if ("equals".equals(methodTree.symbol().name()) && params.size() == 1) {
+      VariableTree variable = params.get(0);
+      if (variable.type().symbolType().is("java.lang.Object") &&
+        NullableAnnotationUtils.isAnnotatedNonNull(variable.symbol())) {
+        reportIssue(variable, "\"equals\" method parameters should not be marked \"@Nonnull\".");
+
+      }
+    }
+  }
+
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/FileCreateTempFileCheck.java b/java-checks/src/main/java/org/sonar/java/checks/FileCreateTempFileCheck.java
index 543f1a074b..dd1966c203 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/FileCreateTempFileCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/FileCreateTempFileCheck.java
@@ -19,9 +19,13 @@
  */
 package org.sonar.java.checks;
 
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.java.JavaVersionAwareVisitor;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.JavaFileScanner;
@@ -38,12 +42,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.Nullable;
-import java.util.Deque;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Map;
-
 @Rule(key = "S2976")
 public class FileCreateTempFileCheck extends BaseTreeVisitor implements JavaFileScanner, JavaVersionAwareVisitor {
 
@@ -118,7 +116,7 @@ public void visitMethodInvocation(MethodInvocationTree mit) {
     } else if (FILE_MKDIR.matches(mit) && State.MKDIR.equals(checkAndAdvanceState(mit, State.DELETE, State.MKDIR))) {
       context.reportIssue(
         this,
-        MethodsHelper.methodName(mit),
+        ExpressionUtils.methodName(mit),
         "Use \"Files.createTempDirectory\" or a library function to create this directory instead." +
           context.getJavaVersion().java7CompatibilityMessage());
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/FilesExistsJDK8Check.java b/java-checks/src/main/java/org/sonar/java/checks/FilesExistsJDK8Check.java
index 57634c4b2a..e13bcef0e4 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/FilesExistsJDK8Check.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/FilesExistsJDK8Check.java
@@ -21,16 +21,16 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import java.util.List;
+import java.util.Map;
 import org.sonar.check.Rule;
 import org.sonar.java.JavaVersionAwareVisitor;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-import java.util.Map;
-
 @Rule(key = "S3725")
 public class FilesExistsJDK8Check extends AbstractMethodDetection implements JavaVersionAwareVisitor {
 
@@ -62,6 +62,6 @@ public boolean isCompatibleWithJavaVersion(JavaVersion version) {
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
     String methodName = mit.symbol().name();
-    reportIssue(mit.methodSelect(), "Replace this with a call to the \"toFile()." + messageParam.get(methodName) + "()\" method");
+    reportIssue(ExpressionUtils.methodName(mit), "Replace this with a call to the \"toFile()." + messageParam.get(methodName) + "()\" method");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/GetRequestedSessionIdCheck.java b/java-checks/src/main/java/org/sonar/java/checks/GetRequestedSessionIdCheck.java
index da44fa6215..fa1655c69c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/GetRequestedSessionIdCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/GetRequestedSessionIdCheck.java
@@ -20,14 +20,13 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2254")
 public class GetRequestedSessionIdCheck extends AbstractMethodDetection {
 
@@ -41,6 +40,6 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove use of this unsecured \"getRequestedSessionId()\" method");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove use of this unsecured \"getRequestedSessionId()\" method");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/HasNextCallingNextCheck.java b/java-checks/src/main/java/org/sonar/java/checks/HasNextCallingNextCheck.java
index 29aacfa46c..ae8835dedb 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/HasNextCallingNextCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/HasNextCallingNextCheck.java
@@ -20,9 +20,9 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
-
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -33,8 +33,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import java.util.List;
-
 @Rule(key = "S1849")
 public class HasNextCallingNextCheck extends IssuableSubscriptionVisitor {
 
@@ -77,7 +75,7 @@ public void visitMethodInvocation(MethodInvocationTree tree) {
         && tree.arguments().isEmpty()
         && isIteratorMethod(method)
         && (hasNextOwner == method.owner() || hasNextOwner.type().isSubtypeOf(method.owner().type()))) {
-        reportIssue(MethodsHelper.methodName(tree), "Refactor the implementation of this \"Iterator.hasNext()\" method to not call \"Iterator.next()\".");
+        reportIssue(ExpressionUtils.methodName(tree), "Refactor the implementation of this \"Iterator.hasNext()\" method to not call \"Iterator.next()\".");
       }
       super.visitMethodInvocation(tree);
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/HttpRefererCheck.java b/java-checks/src/main/java/org/sonar/java/checks/HttpRefererCheck.java
index 7bf7672901..4f7a3b6dc6 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/HttpRefererCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/HttpRefererCheck.java
@@ -20,17 +20,16 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.LiteralTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2089")
 public class HttpRefererCheck extends AbstractMethodDetection {
 
@@ -48,7 +47,7 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
     if (arg.is(Tree.Kind.STRING_LITERAL)) {
       LiteralTree lt = (LiteralTree) arg;
       if ("\"referer\"".equals(lt.value())) {
-        reportIssue(MethodsHelper.methodName(mit), "\"referer\" header should not be relied on");
+        reportIssue(ExpressionUtils.methodName(mit), "\"referer\" header should not be relied on");
       }
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IdenticalCasesInSwitchCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IdenticalCasesInSwitchCheck.java
index 5533ac11fe..990e6517eb 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/IdenticalCasesInSwitchCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IdenticalCasesInSwitchCheck.java
@@ -51,16 +51,19 @@ public void visitNode(Tree node) {
     if (node.is(Tree.Kind.SWITCH_STATEMENT)) {
       SwitchStatementTree switchStatement = (SwitchStatementTree) node;
       Multimap<CaseGroupTree, CaseGroupTree> identicalBranches = checkSwitchStatement(switchStatement);
-      if (!allBranchesSame(identicalBranches, switchStatement.cases().size())) {
+      boolean allBranchesSame = allBranchesSame(identicalBranches, switchStatement.cases().size());
+      boolean allBranchesSameWithoutDefault = allBranchesSame && !hasDefaultClause(switchStatement);
+      if (!allBranchesSame || allBranchesSameWithoutDefault) {
         identicalBranches.asMap().forEach((first, others) -> {
-          if (!isTrivialCase(first.body())) {
+          if (!isTrivialCase(first.body()) || allBranchesSameWithoutDefault) {
             others.forEach(other -> createIssue(other, issueMessage("case", first), first));
           }
         });
       }
     } else if (node.is(Tree.Kind.IF_STATEMENT) && !node.parent().is(Tree.Kind.IF_STATEMENT)) {
-      IfElseChain ifElseChain = checkIfStatement((IfStatementTree) node);
-      reportIdenticalIfChainBranches(ifElseChain.branches, ifElseChain.totalBranchCount);
+      IfStatementTree ifStatement = (IfStatementTree) node;
+      IfElseChain ifElseChain = checkIfStatement(ifStatement);
+      reportIdenticalIfChainBranches(ifElseChain.branches, ifElseChain.totalBranchCount, hasElseClause(ifStatement));
     }
   }
 
@@ -114,7 +117,7 @@ protected static IfElseChain checkIfStatement(IfStatementTree node) {
 
   private static IfElseChain collectIdenticalBranches(List<StatementTree> allBranches) {
     IfElseChain ifElseChain = new IfElseChain();
-    for (int i = 0; i <  allBranches.size(); i++) {
+    for (int i = 0; i < allBranches.size(); i++) {
       if (ifElseChain.branches.containsValue(allBranches.get(i))) {
         continue;
       }
@@ -128,10 +131,12 @@ private static IfElseChain collectIdenticalBranches(List<StatementTree> allBranc
     return ifElseChain;
   }
 
-  private void reportIdenticalIfChainBranches(Multimap<StatementTree, StatementTree> identicalBranches, int totalBranchCount) {
-    if (!allBranchesSame(identicalBranches, totalBranchCount)) {
+  private void reportIdenticalIfChainBranches(Multimap<StatementTree, StatementTree> identicalBranches, int totalBranchCount, boolean withElseClause) {
+    boolean allBranchesSame = allBranchesSame(identicalBranches, totalBranchCount);
+    boolean allBranchesSameWithoutElse = allBranchesSame && !withElseClause;
+    if (!allBranchesSame || allBranchesSameWithoutElse) {
       identicalBranches.asMap().forEach((first, others) -> {
-        if (!isTrivialIfStatement(first)) {
+        if (!isTrivialIfStatement(first) || allBranchesSameWithoutElse) {
           others.forEach(other -> createIssue(other, issueMessage("branch", first), first));
         }
       });
@@ -142,6 +147,20 @@ private static boolean isTrivialIfStatement(StatementTree node) {
     return !node.is(Tree.Kind.BLOCK) || ((BlockTree) node).body().size() <= 1;
   }
 
+  protected static boolean hasDefaultClause(SwitchStatementTree switchStatement) {
+    return switchStatement.cases().stream()
+      .flatMap(caseGroupTree -> caseGroupTree.labels().stream())
+      .anyMatch(caseLabelTree -> caseLabelTree.caseOrDefaultKeyword().text().equals("default"));
+  }
+
+  protected static boolean hasElseClause(IfStatementTree ifStatement) {
+    StatementTree elseStatement = ifStatement.elseStatement();
+    while (elseStatement != null && elseStatement.is(Tree.Kind.IF_STATEMENT)) {
+      elseStatement = ((IfStatementTree) elseStatement).elseStatement();
+    }
+    return elseStatement != null;
+  }
+
   private void createIssue(Tree node, String message, Tree secondary) {
     reportIssue(node, message, ImmutableList.of(new JavaFileScannerContext.Location("Original", secondary)), null);
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IfElseIfStatementEndsWithElseCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IfElseIfStatementEndsWithElseCheck.java
new file mode 100755
index 0000000000..2eeae660ef
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/IfElseIfStatementEndsWithElseCheck.java
@@ -0,0 +1,49 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import java.util.Collections;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.IfStatementTree;
+import org.sonar.plugins.java.api.tree.StatementTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S126")
+public class IfElseIfStatementEndsWithElseCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return Collections.singletonList(Tree.Kind.IF_STATEMENT);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    IfStatementTree treeIfStmt = (IfStatementTree) tree;
+    StatementTree elseStmt = treeIfStmt.elseStatement();
+    if (elseStmt != null && elseStmt.is(Tree.Kind.IF_STATEMENT)) {
+      IfStatementTree ifStmt = (IfStatementTree) elseStmt;
+      if (ifStmt.elseStatement() == null) {
+        reportIssue(treeIfStmt.elseKeyword(), ifStmt.ifKeyword(), "\"if ... else if\" constructs should end with \"else\" clauses.");
+      }
+    }
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IgnoredOperationStatusCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IgnoredOperationStatusCheck.java
index 95e11479df..9df814eda9 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/IgnoredOperationStatusCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IgnoredOperationStatusCheck.java
@@ -63,7 +63,6 @@
       MethodMatcher.create().typeDefinition("java.util.concurrent.Semaphore").name("tryAcquire").withAnyParameters(),
 
       MethodMatcher.create().callSite(SUBTYPE_OF_BLOCKING_QUEUE).name("offer").withAnyParameters(),
-      MethodMatcher.create().callSite(SUBTYPE_OF_BLOCKING_QUEUE).name("drainTo").withAnyParameters(),
       MethodMatcher.create().callSite(SUBTYPE_OF_BLOCKING_QUEUE).name("remove").withAnyParameters());
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java
index 3fd45bf086..ab54dbbe92 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IgnoredReturnValueCheck.java
@@ -21,10 +21,12 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
+import java.util.List;
+import java.util.Set;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.MethodMatcherCollection;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -36,9 +38,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TryStatementTree;
 
-import java.util.List;
-import java.util.Set;
-
 @Rule(key = "S2201")
 public class IgnoredReturnValueCheck extends IssuableSubscriptionVisitor {
 
@@ -98,7 +97,7 @@ public void visitNode(Tree tree) {
         && isCheckedType(methodSymbol.owner().type())
         && methodSymbol.isPublic()
         && !isConstructor(methodSymbol)) {
-        IdentifierTree methodName = MethodsHelper.methodName(mit);
+        IdentifierTree methodName = ExpressionUtils.methodName(mit);
         reportIssue(methodName, "The return value of \"" + methodName.name() + "\" must be used.");
       }
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java
index 968f8ca824..23e5810017 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IgnoredStreamReturnValueCheck.java
@@ -20,11 +20,12 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.MethodMatcherCollection;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -32,8 +33,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import java.util.List;
-
 @Rule(key = "S2674")
 public class IgnoredStreamReturnValueCheck extends IssuableSubscriptionVisitor {
 
@@ -56,7 +55,7 @@ public void visitNode(Tree tree) {
     if (statement.is(Kind.METHOD_INVOCATION)) {
       MethodInvocationTree mit = (MethodInvocationTree) statement;
       if (MATCHERS.anyMatch(mit)) {
-        reportIssue(MethodsHelper.methodName(mit), "Check the return value of the \"" + mit.symbol().name() + "\" call to see how many bytes were read.");
+        reportIssue(ExpressionUtils.methodName(mit), "Check the return value of the \"" + mit.symbol().name() + "\" call to see how many bytes were read.");
       }
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IndexOfStartPositionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IndexOfStartPositionCheck.java
index 8704149981..189d4c488a 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/IndexOfStartPositionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IndexOfStartPositionCheck.java
@@ -20,8 +20,8 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.model.LiteralUtils;
@@ -33,8 +33,6 @@
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2912")
 public class IndexOfStartPositionCheck extends IssuableSubscriptionVisitor {
 
@@ -74,7 +72,7 @@ private void checkIndexOfInvocation(MethodInvocationTree mit, ExpressionTree oth
       }
       Long otherValue = LiteralUtils.longLiteralValue(other);
       if (otherValue != null && otherValue != -1 && otherValue != 0) {
-        reportIssue(MethodsHelper.methodName(mit), "Use \".indexOf(" + replaceMessage + ",n) > -1\" instead.");
+        reportIssue(ExpressionUtils.methodName(mit), "Use \".indexOf(" + replaceMessage + ",n) > -1\" instead.");
       }
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/InnerStaticClassesCheck.java b/java-checks/src/main/java/org/sonar/java/checks/InnerStaticClassesCheck.java
index 8ccadb0a8c..cca06d3a2c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/InnerStaticClassesCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/InnerStaticClassesCheck.java
@@ -19,6 +19,8 @@
  */
 package org.sonar.java.checks;
 
+import java.util.Deque;
+import java.util.LinkedList;
 import org.sonar.check.Rule;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
@@ -27,13 +29,11 @@
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.ClassTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import java.util.Deque;
-import java.util.LinkedList;
-
 @Rule(key = "S2694")
 public class InnerStaticClassesCheck extends BaseTreeVisitor implements JavaFileScanner {
 
@@ -150,8 +150,22 @@ private int fromInstance(Symbol symbol, Symbol owner) {
   public void visitVariable(VariableTree tree) {
     Symbol symbol = tree.symbol();
     if (symbol != null && !symbol.isStatic()) {
-      super.visitVariable(tree);
+      scan(tree.modifiers());
+      scan(tree.type());
+      // skip the simple name
+      scan(tree.initializer());
     }
   }
 
+  @Override
+  public void visitMethod(MethodTree tree) {
+    scan(tree.modifiers());
+    scan(tree.typeParameters());
+    scan(tree.returnType());
+    // skip the simple name
+    scan(tree.parameters());
+    scan(tree.defaultValue());
+    scan(tree.throwsClauses());
+    scan(tree.block());
+  }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/InvalidDateValuesCheck.java b/java-checks/src/main/java/org/sonar/java/checks/InvalidDateValuesCheck.java
index f6c5004f8e..1ae514012b 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/InvalidDateValuesCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/InvalidDateValuesCheck.java
@@ -21,9 +21,14 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Maps;
+import java.text.MessageFormat;
+import java.util.List;
+import java.util.Map;
+import javax.annotation.CheckForNull;
 import org.sonar.check.Rule;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.Arguments;
 import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
@@ -36,11 +41,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
 
-import javax.annotation.CheckForNull;
-import java.text.MessageFormat;
-import java.util.List;
-import java.util.Map;
-
 @Rule(key = "S2110")
 public class InvalidDateValuesCheck extends AbstractMethodDetection {
 
@@ -208,11 +208,7 @@ private void checkArgument(ExpressionTree arg, String name, String message) {
   }
 
   private static String getMethodName(MethodInvocationTree mit) {
-    ExpressionTree methodSelect = mit.methodSelect();
-    if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
-      return ((MemberSelectExpressionTree) methodSelect).identifier().name();
-    }
-    return ((IdentifierTree) methodSelect).name();
+    return ExpressionUtils.methodName(mit).name();
   }
 
   private enum Threshold {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java
index 335fbc8d3a..4aadf53ed6 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/IteratorNextExceptionCheck.java
@@ -20,10 +20,11 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.MethodJavaType;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -37,8 +38,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import java.util.List;
-
 @Rule(key = "S2272")
 public class IteratorNextExceptionCheck extends IssuableSubscriptionVisitor {
 
@@ -105,7 +104,7 @@ private static boolean throwsNoSuchElementException(MethodInvocationTree methodI
       if (throwsNoSuchElementException(((Symbol.MethodSymbol) symbol).thrownTypes())) {
         return true;
       }
-      MethodJavaType methodJavaType = (MethodJavaType) MethodsHelper.methodName(methodInvocationTree).symbolType();
+      MethodJavaType methodJavaType = (MethodJavaType) ExpressionUtils.methodName(methodInvocationTree).symbolType();
       return throwsNoSuchElementException(methodJavaType.thrownTypes());
     }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/JavaFootprint.java b/java-checks/src/main/java/org/sonar/java/checks/JavaFootprint.java
index c6bec4ada2..37b0aad50f 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/JavaFootprint.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/JavaFootprint.java
@@ -19,7 +19,8 @@
  */
 package org.sonar.java.checks;
 
-import com.google.common.collect.Sets;
+import java.util.HashSet;
+import java.util.Set;
 import org.sonar.squidbridge.recognizer.CamelCaseDetector;
 import org.sonar.squidbridge.recognizer.ContainsDetector;
 import org.sonar.squidbridge.recognizer.Detector;
@@ -27,11 +28,9 @@
 import org.sonar.squidbridge.recognizer.KeywordsDetector;
 import org.sonar.squidbridge.recognizer.LanguageFootprint;
 
-import java.util.Set;
-
 public final class JavaFootprint implements LanguageFootprint {
 
-  private final Set<Detector> detectors = Sets.newHashSet();
+  private final Set<Detector> detectors = new HashSet<>();
 
   public JavaFootprint() {
     detectors.add(new EndWithDetector(0.95, '}', ';', '{'));
diff --git a/java-checks/src/main/java/org/sonar/java/checks/LeastSpecificTypeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/LeastSpecificTypeCheck.java
index e6c1505794..8d2a3f9a7c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/LeastSpecificTypeCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/LeastSpecificTypeCheck.java
@@ -34,6 +34,7 @@
 import org.sonar.java.resolve.JavaType;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.semantic.SymbolMetadata;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
@@ -64,25 +65,34 @@ public void visitNode(Tree tree) {
       return;
     }
 
+    boolean springInjectionAnnotated = isSpringInjectionAnnotated(methodSymbol.metadata());
     methodTree.parameters().stream()
       .map(VariableTree::symbol)
       .filter(p -> p.type().isClass() && !p.type().symbol().isEnum() && !p.type().is("java.lang.String"))
-      .forEach(this::handleParameter);
+      .filter(p -> !(springInjectionAnnotated && p.type().is("java.util.Collection")))
+      .forEach(p -> handleParameter(p, springInjectionAnnotated));
   }
 
   private static boolean isOverloaded(Symbol.MethodSymbol methodSymbol) {
     return ((Symbol.TypeSymbol) methodSymbol.owner()).lookupSymbols(methodSymbol.name()).size() > 1;
   }
 
-  private void handleParameter(Symbol parameter) {
+  private void handleParameter(Symbol parameter, boolean springInjectionAnnotated) {
     Type leastSpecificType = findLeastSpecificType(parameter);
     if (parameter.type() != leastSpecificType
       && !leastSpecificType.is("java.lang.Object")) {
-      String suggestedType = leastSpecificType.fullyQualifiedName().replace('$', '.');
+      String suggestedType = getSuggestedType(springInjectionAnnotated, leastSpecificType);
       reportIssue(parameter.declaration(), String.format("Use '%s' here; it is a more general type than '%s'.", suggestedType, parameter.type().name()));
     }
   }
 
+  private static String getSuggestedType(boolean springInjectionAnnotated, Type leastSpecificType) {
+    if (springInjectionAnnotated && leastSpecificType.is("java.lang.Iterable")) {
+      return "java.util.Collection";
+    }
+    return leastSpecificType.fullyQualifiedName().replace('$', '.');
+  }
+
   private static Type findLeastSpecificType(Symbol parameter) {
     InheritanceGraph inheritanceGraph = new InheritanceGraph(parameter.type());
     for (IdentifierTree usage : parameter.usages()) {
@@ -204,4 +214,10 @@ private static boolean isMethodInvocationOnParameter(Symbol parameter, MethodInv
     }
     return false;
   }
+
+  private static boolean isSpringInjectionAnnotated(SymbolMetadata metadata) {
+    return metadata.isAnnotatedWith("org.springframework.beans.factory.annotation.Autowired")
+      || metadata.isAnnotatedWith("javax.inject.Inject")
+      || metadata.isAnnotatedWith("javax.annotation.Resource");
+  }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/LoggersDeclarationCheck.java b/java-checks/src/main/java/org/sonar/java/checks/LoggersDeclarationCheck.java
index c80c357662..f4e0bca351 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/LoggersDeclarationCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/LoggersDeclarationCheck.java
@@ -26,6 +26,7 @@
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.Modifier;
 import org.sonar.plugins.java.api.tree.ModifiersTree;
@@ -102,10 +103,14 @@ private static String getPrivateStaticFinalMessage(String simpleName) {
   }
 
   private static boolean isLoggerType(Tree tree) {
-    if (!tree.is(Tree.Kind.IDENTIFIER)) {
+    IdentifierTree identifierTree = null;
+    if (tree.is(Tree.Kind.IDENTIFIER)) {
+      identifierTree = (IdentifierTree) tree;
+    } else if (tree.is(Tree.Kind.MEMBER_SELECT)) {
+      identifierTree = ((MemberSelectExpressionTree) tree).identifier ();
+    } else {
       return false;
     }
-    IdentifierTree identifierTree = (IdentifierTree) tree;
 
     return "Log".equals(identifierTree.name()) ||
       "Logger".equals(identifierTree.name());
diff --git a/java-checks/src/main/java/org/sonar/java/checks/LongBitsToDoubleOnIntCheck.java b/java-checks/src/main/java/org/sonar/java/checks/LongBitsToDoubleOnIntCheck.java
index f5cabfb97f..c5812b4d0f 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/LongBitsToDoubleOnIntCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/LongBitsToDoubleOnIntCheck.java
@@ -20,15 +20,14 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2127")
 public class LongBitsToDoubleOnIntCheck extends AbstractMethodDetection {
 
@@ -43,7 +42,7 @@
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
     Type symbolType = mit.arguments().get(0).symbolType();
     if (!(symbolType.is("long") || symbolType.is("java.lang.Long"))) {
-      reportIssue(MethodsHelper.methodName(mit), "Remove this \"Double.longBitsToDouble\" call.");
+      reportIssue(ExpressionUtils.methodName(mit), "Remove this \"Double.longBitsToDouble\" call.");
     }
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/UnconditionalJumpStatementCheck.java b/java-checks/src/main/java/org/sonar/java/checks/LoopExecutingAtMostOnceCheck.java
similarity index 96%
rename from java-checks/src/main/java/org/sonar/java/checks/UnconditionalJumpStatementCheck.java
rename to java-checks/src/main/java/org/sonar/java/checks/LoopExecutingAtMostOnceCheck.java
index 42b0ead1d4..975140e06e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/UnconditionalJumpStatementCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/LoopExecutingAtMostOnceCheck.java
@@ -47,7 +47,7 @@
 import org.sonar.plugins.java.api.tree.WhileStatementTree;
 
 @Rule(key = "S1751")
-public class UnconditionalJumpStatementCheck extends IssuableSubscriptionVisitor {
+public class LoopExecutingAtMostOnceCheck extends IssuableSubscriptionVisitor {
 
   private static final MethodMatcherCollection NEXT_ELEMENT = MethodMatcherCollection.create(
     MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.util.Enumeration")).name("hasMoreElements").withoutParameter(),
@@ -64,7 +64,6 @@
   public List<Tree.Kind> nodesToVisit() {
     return Arrays.asList(
       Tree.Kind.BREAK_STATEMENT,
-      Tree.Kind.CONTINUE_STATEMENT,
       Tree.Kind.RETURN_STATEMENT,
       Tree.Kind.THROW_STATEMENT);
   }
@@ -80,8 +79,7 @@ public void visitNode(Tree tree) {
       return;
     }
 
-    if (tree.is(Tree.Kind.CONTINUE_STATEMENT)
-      || (!isWhileNextElementLoop(parent) && !isEmptyConditionLoop(parent) && executeUnconditionnally(parent))) {
+    if (!isWhileNextElementLoop(parent) && !isEmptyConditionLoop(parent) && executeUnconditionnally(parent)) {
       SyntaxToken jumpKeyword = jumpKeyword(tree);
       reportIssue(jumpKeyword, String.format("Remove this \"%s\" statement or make it conditional.", jumpKeyword.text()));
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/MethodParametersOrderCheck.java b/java-checks/src/main/java/org/sonar/java/checks/MethodParametersOrderCheck.java
new file mode 100755
index 0000000000..4eff64b2af
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/MethodParametersOrderCheck.java
@@ -0,0 +1,145 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.stream.Collectors;
+import org.sonar.check.Rule;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.JavaFileScannerContext;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.semantic.Type;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.VariableTree;
+
+@Rule(key = "S2234")
+public class MethodParametersOrderCheck extends IssuableSubscriptionVisitor {
+
+  private Map<Symbol, ParametersList> parametersByMethod = new HashMap<>();
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
+  }
+
+  @Override
+  public void scanFile(JavaFileScannerContext context) {
+    parametersByMethod.clear();
+    super.scanFile(context);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    MethodInvocationTree methodInvTree = (MethodInvocationTree) tree;
+    MethodTree methodDeclaration = (MethodTree) methodInvTree.symbol().declaration();
+    if (methodDeclaration == null) {
+      return;
+    }
+    ParametersList formalParameterList = parametersByMethod.computeIfAbsent(methodInvTree.symbol(), m -> new ParametersList(methodDeclaration));
+    List<IdentifierTree> argumentsList = methodInvTree.arguments().stream().map(this::argumentToIdentifier).collect(Collectors.toList());
+    if (matchingNames(formalParameterList, argumentsList)
+      && matchingTypesWrongOrder(formalParameterList, argumentsList)) {
+      List<JavaFileScannerContext.Location> flow = methodDeclaration.parameters().stream().map(param -> new JavaFileScannerContext.Location("Formal Parameters", param))
+        .collect(Collectors.toList());
+      reportIssue(methodInvTree.arguments(), "Parameters to " + methodInvTree.symbol().name() + " have the same names but not the same order as the method arguments.",
+        flow, null);
+
+    }
+  }
+
+  private static boolean matchingNames(ParametersList formalParameters, List<IdentifierTree> argumentsList) {
+    List<String> argListNames = argumentsList.stream().filter(Objects::nonNull).map(arg -> arg.name().toLowerCase(Locale.ENGLISH)).collect(Collectors.toList());
+    return allUnique(argListNames)
+      && argListNames.stream().allMatch(formalParameters::hasArgumentWithName);
+  }
+
+  public IdentifierTree argumentToIdentifier(ExpressionTree expr) {
+    if (expr.is(Tree.Kind.IDENTIFIER)) {
+      return (IdentifierTree) ExpressionUtils.skipParentheses(expr);
+    } else if (expr.is(Tree.Kind.MEMBER_SELECT)) {
+      return (IdentifierTree) ExpressionUtils.skipParentheses(((MemberSelectExpressionTree) expr).identifier());
+    } else {
+      return null;
+    }
+  }
+
+  public static boolean allUnique(List<String> argListNames) {
+    return argListNames.size() == new HashSet<>(argListNames).size();
+  }
+
+  private static boolean matchingTypesWrongOrder(ParametersList formalParameterList, List<IdentifierTree> argumentList) {
+    Iterator<IdentifierTree> argumentsIterator = argumentList.stream().filter(Objects::nonNull).iterator();
+    int countArgumentsNotOrdered = 0;
+    while (argumentsIterator.hasNext()) {
+      IdentifierTree argument = argumentsIterator.next();
+      int index = formalParameterList.indexOf(argument.name().toLowerCase(Locale.ENGLISH));
+      Type formalType = formalParameterList.typeOfIndex(index);
+      Type argType = argument.symbolType();
+      if (!formalType.is(argType.fullyQualifiedName()) || formalType.isUnknown() || argType.isUnknown()) {
+        return false;
+      }
+      if (argumentList.indexOf(argument) != index) {
+        countArgumentsNotOrdered++;
+      }
+    }
+    return countArgumentsNotOrdered >= 2;
+  }
+
+  private static class ParametersList {
+
+    private List<String> parameterNames;
+    private List<Type> parameterTypes;
+
+    public ParametersList(MethodTree methodTree) {
+      parameterNames = new ArrayList<>();
+      parameterTypes = new ArrayList<>();
+      methodTree.parameters().stream().map(VariableTree::symbol).forEach(symbol -> {
+        parameterNames.add(symbol.name().toLowerCase(Locale.ENGLISH));
+        parameterTypes.add(symbol.type());
+      });
+    }
+
+    public boolean hasArgumentWithName(String argument) {
+      return parameterNames.contains(argument);
+    }
+
+    public int indexOf(String argName) {
+      return parameterNames.indexOf(argName);
+    }
+
+    public Type typeOfIndex(int index) {
+      return parameterTypes.get(index);
+    }
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/NestedSwitchStatementCheck.java b/java-checks/src/main/java/org/sonar/java/checks/NestedSwitchStatementCheck.java
new file mode 100755
index 0000000000..df676cdb92
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/NestedSwitchStatementCheck.java
@@ -0,0 +1,63 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.ClassTree;
+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
+import org.sonar.plugins.java.api.tree.SwitchStatementTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S1821")
+public class NestedSwitchStatementCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.SWITCH_STATEMENT);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    NestedSwitchVisitor visitor = new NestedSwitchVisitor();
+    ((SwitchStatementTree) tree).cases().stream().forEach(c -> c.accept(visitor));
+  }
+
+  private class NestedSwitchVisitor extends BaseTreeVisitor {
+
+    @Override
+    public void visitClass(ClassTree tree) {
+      // skip nested and anonymous Classes
+    }
+
+    @Override
+    public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
+      // skip Lambdas
+    }
+
+    @Override
+    public void visitSwitchStatement(SwitchStatementTree tree) {
+      reportIssue(tree.switchKeyword(), "Refactor the code to eliminate this nested \"switch\".");
+    }
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/NioFileDeleteCheck.java b/java-checks/src/main/java/org/sonar/java/checks/NioFileDeleteCheck.java
index 3887f1b4d7..11e6d1ea22 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/NioFileDeleteCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/NioFileDeleteCheck.java
@@ -19,17 +19,16 @@
  */
 package org.sonar.java.checks;
 
+import java.util.Collections;
+import java.util.List;
 import org.sonar.check.Rule;
 import org.sonar.java.JavaVersionAwareVisitor;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.Collections;
-import java.util.List;
-
 @Rule(key = "S4042")
 public class NioFileDeleteCheck extends AbstractMethodDetection implements JavaVersionAwareVisitor {
 
@@ -40,7 +39,7 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Use \"java.nio.Files#delete\" here for better messages on error conditions.");
+    reportIssue(ExpressionUtils.methodName(mit), "Use \"java.nio.Files#delete\" here for better messages on error conditions.");
   }
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/NoSonarCheck.java b/java-checks/src/main/java/org/sonar/java/checks/NoSonarCheck.java
index a6f83a1b94..644c222c10 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/NoSonarCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/NoSonarCheck.java
@@ -20,17 +20,13 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.SyntaxTrivia;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
-/**
- * Note that {@link org.sonar.squidbridge.checks.AbstractNoSonarCheck} can't be used because of bug SSLRSQBR-16.
- */
 @Rule(key = "NoSonar")
 @RspecKey("S1291")
 public class NoSonarCheck extends IssuableSubscriptionVisitor {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/NotifyCheck.java b/java-checks/src/main/java/org/sonar/java/checks/NotifyCheck.java
index ac925baaa1..ef0bc2d647 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/NotifyCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/NotifyCheck.java
@@ -20,14 +20,13 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2446")
 public class NotifyCheck extends AbstractMethodDetection {
 
@@ -38,6 +37,6 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "\"notify\" may not wake up the appropriate thread.");
+    reportIssue(ExpressionUtils.methodName(mit), "\"notify\" may not wake up the appropriate thread.");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/NullCheckWithInstanceofCheck.java b/java-checks/src/main/java/org/sonar/java/checks/NullCheckWithInstanceofCheck.java
new file mode 100755
index 0000000000..88edcbf153
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/NullCheckWithInstanceofCheck.java
@@ -0,0 +1,113 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Optional;
+import javax.annotation.CheckForNull;
+import org.sonar.check.Rule;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.java.model.SyntacticEquivalence;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.InstanceOfTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;
+
+@Rule(key = "S4201")
+public class NullCheckWithInstanceofCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.CONDITIONAL_AND, Tree.Kind.CONDITIONAL_OR);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (!hasSemantic()) {
+      return;
+    }
+    BinaryExpressionTree binaryExpression = (BinaryExpressionTree) tree;
+    ExpressionTree leftOp = ExpressionUtils.skipParentheses(binaryExpression.leftOperand());
+    ExpressionTree rightOp = ExpressionUtils.skipParentheses(binaryExpression.rightOperand());
+    if ((is(Tree.Kind.EQUAL_TO, leftOp, rightOp) && nullCheckWithInstanceOf(leftOp, rightOp, binaryExpression.kind(), Tree.Kind.CONDITIONAL_OR)) ||
+      (is(Tree.Kind.NOT_EQUAL_TO, leftOp, rightOp) && nullCheckWithInstanceOf(leftOp, rightOp, binaryExpression.kind(), Tree.Kind.CONDITIONAL_AND))) {
+      reportIssue(treeToReport(leftOp, rightOp), "Remove this unnecessary null check; \"instanceof\" returns false for nulls.");
+    }
+  }
+
+  private static boolean nullCheckWithInstanceOf(ExpressionTree leftOp, ExpressionTree rightOp, Tree.Kind binaryExpressionKind, Tree.Kind expectedKind) {
+    ExpressionTree binaryVariable = Optional.ofNullable(binaryExpressionVariable(leftOp))
+      .orElse(binaryExpressionVariable(rightOp));
+    if (binaryVariable == null || binaryExpressionKind != expectedKind) {
+      return false;
+    }
+    ExpressionTree instanceofVariable = Optional.ofNullable(instanceofFound(rightOp, binaryExpressionKind))
+      .orElse(instanceofFound(leftOp, binaryExpressionKind));
+    return instanceofVariable != null && SyntacticEquivalence.areEquivalent(binaryVariable, instanceofVariable);
+  }
+
+  private static ExpressionTree treeToReport(ExpressionTree left, ExpressionTree right) {
+    return left.is(Tree.Kind.EQUAL_TO, Tree.Kind.NOT_EQUAL_TO) ? left : right;
+  }
+
+  @CheckForNull
+  private static ExpressionTree binaryExpressionVariable(ExpressionTree expression) {
+    BinaryExpressionTree binaryExpression = null;
+    if (expression.is(Tree.Kind.NOT_EQUAL_TO, Tree.Kind.EQUAL_TO)) {
+      binaryExpression = (BinaryExpressionTree) expression;
+      if (binaryExpression.leftOperand().is(Tree.Kind.NULL_LITERAL)) {
+        return binaryExpression.rightOperand();
+      } else if (binaryExpression.rightOperand().is(Tree.Kind.NULL_LITERAL)) {
+        return binaryExpression.leftOperand();
+      }
+    }
+    return null;
+  }
+
+  @CheckForNull
+  private static ExpressionTree instanceofFound(ExpressionTree expressionTree, Tree.Kind kind) {
+    if (kind == Tree.Kind.CONDITIONAL_OR) {
+      /* if CONDITIONAL_OR we want LOGICAL COMPLEMENT before instanceof */
+      if (expressionTree.is(Tree.Kind.LOGICAL_COMPLEMENT)) {
+        return instanceofLHS(ExpressionUtils.skipParentheses(((UnaryExpressionTree) expressionTree).expression()));
+      } else {
+        return null;
+      }
+    } else {
+      return instanceofLHS(expressionTree);
+    }
+  }
+
+  @CheckForNull
+  private static ExpressionTree instanceofLHS(ExpressionTree expressionTree) {
+    if (expressionTree.is(Tree.Kind.INSTANCE_OF)) {
+      return ((InstanceOfTree) expressionTree).expression();
+    }
+    return null;
+  }
+
+  private static boolean is(Tree.Kind kind, Tree... trees) {
+    return Arrays.stream(trees).anyMatch(tree -> tree.is(kind));
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ObjectFinalizeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ObjectFinalizeCheck.java
index 581f8d1596..57c95acba6 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ObjectFinalizeCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ObjectFinalizeCheck.java
@@ -20,9 +20,10 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
-import org.sonar.java.checks.helpers.MethodsHelper;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
@@ -30,8 +31,6 @@
 import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "ObjectFinalizeCheck")
 @RspecKey("S1111")
 public class ObjectFinalizeCheck extends IssuableSubscriptionVisitor {
@@ -49,7 +48,7 @@ public void visitNode(Tree tree) {
       isInFinalizeMethod = isFinalizeMethodMember((MethodTree) tree);
     } else {
       MethodInvocationTree methodInvocationTree = (MethodInvocationTree) tree;
-      IdentifierTree methodName = MethodsHelper.methodName(methodInvocationTree);
+      IdentifierTree methodName = ExpressionUtils.methodName(methodInvocationTree);
       if (!isInFinalizeMethod && "finalize".equals(methodName.name()) && methodInvocationTree.arguments().isEmpty()) {
         reportIssue(methodName, "Remove this call to finalize().");
       }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ParsingErrorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ParsingErrorCheck.java
index 256760b4a0..36874763c2 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ParsingErrorCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ParsingErrorCheck.java
@@ -20,18 +20,17 @@
 package org.sonar.java.checks;
 
 import com.sonar.sslr.api.RecognitionException;
+import java.io.PrintWriter;
+import java.io.StringWriter;
 import org.sonar.check.Rule;
+import org.sonar.java.ExceptionHandler;
 import org.sonar.java.RspecKey;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
-import org.sonar.squidbridge.AstScannerExceptionHandler;
-
-import java.io.PrintWriter;
-import java.io.StringWriter;
 
 @Rule(key = "ParsingError")
 @RspecKey("S2260")
-public class ParsingErrorCheck implements AstScannerExceptionHandler, JavaFileScanner {
+public class ParsingErrorCheck implements ExceptionHandler, JavaFileScanner {
 
   private JavaFileScannerContext context;
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PreferStreamAnyMatchCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PreferStreamAnyMatchCheck.java
index 80012382f6..7eacbdbca2 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PreferStreamAnyMatchCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PreferStreamAnyMatchCheck.java
@@ -26,10 +26,10 @@
 import java.util.Set;
 import java.util.stream.Stream;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.MethodMatcherCollection;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
@@ -93,7 +93,7 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
 
   private void handleAnyMatch(MethodInvocationTree anyMatchMIT) {
     ExpressionTree predicate = anyMatchMIT.arguments().get(0);
-    IdentifierTree reportTree = MethodsHelper.methodName(anyMatchMIT);
+    IdentifierTree reportTree = ExpressionUtils.methodName(anyMatchMIT);
     if (anyMatchMIT.parent().is(Tree.Kind.LOGICAL_COMPLEMENT)) {
       if (predicate.is(Tree.Kind.LAMBDA_EXPRESSION) && ((LambdaExpressionTree) predicate).body().is(Tree.Kind.LOGICAL_COMPLEMENT)) {
         // !stream.anyMatch(x -> !(...))
@@ -122,8 +122,8 @@ private void handleIsPresent(MethodInvocationTree isPresentMIT) {
       .ifPresent(findMIT ->
         previousMITInChain(findMIT).filter(FILTER_METHODS::anyMatch)
           .ifPresent(filterMIT ->
-            context.reportIssue(this, MethodsHelper.methodName(filterMIT), MethodsHelper.methodName(isPresentMIT),
-              "Replace this \"filter()." + MethodsHelper.methodName(findMIT).name() + "().isPresent()\" chain with \"anyMatch()\".")));
+    context.reportIssue(this, ExpressionUtils.methodName(filterMIT), ExpressionUtils.methodName(isPresentMIT),
+      "Replace this \"filter()." + ExpressionUtils.methodName(findMIT).name() + "().isPresent()\" chain with \"anyMatch()\".")));
   }
 
   private static Optional<MethodInvocationTree> previousMITInChain(MethodInvocationTree mit) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PrintfFailCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PrintfFailCheck.java
index 605ed16c25..d06b9964c0 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PrintfFailCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PrintfFailCheck.java
@@ -20,6 +20,9 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.Sets;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Set;
 import org.sonar.check.Rule;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -29,10 +32,6 @@
 import org.sonar.plugins.java.api.tree.NewArrayTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.Arrays;
-import java.util.List;
-import java.util.Set;
-
 @Rule(key = "S2275")
 public class PrintfFailCheck extends AbstractPrintfChecker {
 
@@ -67,6 +66,10 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
   }
 
   private void checkFormatting(MethodInvocationTree mit, boolean isMessageFormat) {
+    if (mit.arguments().stream().map(ExpressionTree::symbolType).anyMatch(Type::isUnknown)) {
+      // method resolved but not all the parameters are
+      return;
+    }
     ExpressionTree formatStringTree;
     List<ExpressionTree> args;
     // Check type of first argument:
@@ -88,7 +91,6 @@ private void checkFormatting(MethodInvocationTree mit, boolean isMessageFormat)
     }
   }
 
-
   @Override
   protected void handlePrintfFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
     List<String> params = getParameters(formatString, mit);
@@ -100,6 +102,8 @@ protected void handlePrintfFormat(MethodInvocationTree mit, String formatString,
       verifyParameters(mit, args, params);
     }
   }
+
+  @Override
   protected void handleMessageFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
     String newFormatString = cleanupDoubleQuote(formatString);
     Set<Integer> indexes = getMessageFormatIndexes(newFormatString, mit);
@@ -182,7 +186,6 @@ private void verifyParameters(MethodInvocationTree mit, List<ExpressionTree> arg
     }
   }
 
-
   private void verifyParameters(MethodInvocationTree mit, List<ExpressionTree> args, List<String> params) {
     int index = 0;
     for (String rawParam : params) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
index 09f51bc473..682979d698 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PrintfMisuseCheck.java
@@ -66,6 +66,10 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
   }
 
   private void checkFormatting(MethodInvocationTree mit, boolean isMessageFormat) {
+    if (mit.arguments().stream().map(ExpressionTree::symbolType).anyMatch(Type::isUnknown)) {
+      // method resolved but not all the parameters are
+      return;
+    }
     ExpressionTree formatStringTree;
     List<ExpressionTree> args;
     // Check type of first argument:
@@ -132,6 +136,7 @@ private void verifyParameters(MethodInvocationTree mit, List<ExpressionTree> arg
     reportUnusedArgs(mit, args, unusedArgs);
   }
 
+  @Override
   protected void handleMessageFormat(MethodInvocationTree mit, String formatString, List<ExpressionTree> args) {
     String newFormatString = cleanupDoubleQuote(formatString);
     Set<Integer> indexes = getMessageFormatIndexes(newFormatString, mit);
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PseudoRandomCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PseudoRandomCheck.java
index a67e894a97..2675fb613e 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PseudoRandomCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PseudoRandomCheck.java
@@ -20,16 +20,15 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2245")
 public class PseudoRandomCheck extends IssuableSubscriptionVisitor {
 
@@ -46,7 +45,7 @@ public void visitNode(Tree tree) {
     if (tree.is(Tree.Kind.METHOD_INVOCATION)) {
       MethodInvocationTree mit = (MethodInvocationTree) tree;
       if (MATH_RANDOM_MATCHER.matches(mit)) {
-        reportIssue(MethodsHelper.methodName(mit), MESSAGE);
+        reportIssue(ExpressionUtils.methodName(mit), MESSAGE);
       }
     } else {
       NewClassTree newClass = (NewClassTree) tree;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java b/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java
index 104b41a70e..b56983bff8 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/PublicStaticMutableMembersCheck.java
@@ -23,7 +23,11 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Multimap;
-
+import java.text.MessageFormat;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.MethodMatcherCollection;
@@ -46,13 +50,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.Nullable;
-
-import java.text.MessageFormat;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
 @Rule(key = "S2386")
 public class PublicStaticMutableMembersCheck extends IssuableSubscriptionVisitor {
 
@@ -70,6 +67,8 @@
   private static final String DECORATE = "decorate";
   // java.util and apache commons
   private static final MethodMatcherCollection UNMODIFIABLE_METHOD_CALLS = MethodMatcherCollection.create()
+    .add(MethodMatcher.create().typeDefinition("java.util.Collections").name(NameCriteria.startsWith("singleton")).withAnyParameters())
+    .add(MethodMatcher.create().typeDefinition("java.util.Collections").name(NameCriteria.startsWith("empty")).withAnyParameters())
     .add(MethodMatcher.create().typeDefinition(TypeCriteria.anyType()).name(NameCriteria.startsWith("unmodifiable")).withAnyParameters())
       // apache commons 3.X
     .add(MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("org.apache.commons.collections.map.UnmodifiableMap")).name(DECORATE).withAnyParameters())
diff --git a/java-checks/src/main/java/org/sonar/java/checks/RedundantJumpCheck.java b/java-checks/src/main/java/org/sonar/java/checks/RedundantJumpCheck.java
new file mode 100755
index 0000000000..53ca6a1953
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/RedundantJumpCheck.java
@@ -0,0 +1,87 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import java.util.Arrays;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.java.cfg.CFG;
+import org.sonar.java.cfg.CFG.Block;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.ReturnStatementTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S3626")
+public class RedundantJumpCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return Arrays.asList(
+      Tree.Kind.METHOD,
+      Tree.Kind.CONSTRUCTOR);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    MethodTree methodTree = (MethodTree) tree;
+    if (methodTree.block() != null) {
+      CFG cfg = CFG.build(methodTree);
+      cfg.blocks().forEach(this::checkBlock);
+    }
+  }
+
+  private void checkBlock(Block block) {
+    Block successorWithoutJump = block.successorWithoutJump();
+    Tree terminator = block.terminator();
+
+    if (terminator != null
+      && successorWithoutJump != null
+      && terminator.is(Tree.Kind.CONTINUE_STATEMENT, Tree.Kind.RETURN_STATEMENT)
+      && !isReturnWithExpression(terminator)
+      && !isSwitchCaseChild(terminator)) {
+
+      successorWithoutJump = nonEmptySuccessor(successorWithoutJump);
+      Block successor = nonEmptySuccessor(block.successors().iterator().next());
+      if (successorWithoutJump.equals(successor)) {
+        reportIssue(terminator, "Remove this redundant jump.");
+      }
+    }
+  }
+
+  private static boolean isReturnWithExpression(Tree tree) {
+    if (tree.is(Tree.Kind.RETURN_STATEMENT)) {
+      return ((ReturnStatementTree) tree).expression() != null;
+    }
+    return false;
+  }
+
+  private static boolean isSwitchCaseChild(Tree tree) {
+    return tree.parent().is(Tree.Kind.CASE_GROUP);
+  }
+
+  private static Block nonEmptySuccessor(Block initialBlock) {
+    Block result = initialBlock;
+    while (result.elements().isEmpty() && result.successors().size() == 1) {
+      result = result.successors().iterator().next();
+    }
+    return result;
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/RedundantStreamCollectCheck.java b/java-checks/src/main/java/org/sonar/java/checks/RedundantStreamCollectCheck.java
index a4db814917..c35df34992 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/RedundantStreamCollectCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/RedundantStreamCollectCheck.java
@@ -26,9 +26,9 @@
 import java.util.Set;
 import java.util.stream.Collectors;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
@@ -78,7 +78,7 @@ protected void onMethodInvocationFound(MethodInvocationTree collectMIT) {
       REPLACEMENTS.entrySet().stream()
         .filter(e -> e.getKey().matches(methodInvocation))
         .findFirst()
-        .ifPresent(e -> context.reportIssue(this,  MethodsHelper.methodName(methodInvocation),
+        .ifPresent(e -> context.reportIssue(this, ExpressionUtils.methodName(methodInvocation),
             "Use \"" + e.getValue() + "\" instead."));
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/RedundantThrowsDeclarationCheck.java b/java-checks/src/main/java/org/sonar/java/checks/RedundantThrowsDeclarationCheck.java
index 338ef957c2..35c7765087 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/RedundantThrowsDeclarationCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/RedundantThrowsDeclarationCheck.java
@@ -26,9 +26,11 @@
 import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
+import org.sonar.java.checks.helpers.Javadoc;
 import org.sonar.java.checks.serialization.SerializableContract;
 import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.model.ModifiersUtils;
+import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.java.resolve.JavaType;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -62,13 +64,21 @@
 
   @Override
   public void visitNode(Tree tree) {
-    MethodTree methodTree = (MethodTree) tree;
-    ListTree<TypeTree> thrownList = methodTree.throwsClauses();
+    ListTree<TypeTree> thrownList = ((MethodTree) tree).throwsClauses();
+    if (!hasSemantic() || thrownList.isEmpty()) {
+      return;
+    }
+
+    checkMethodThrownList((MethodTree) tree, thrownList);
+  }
 
+  private void checkMethodThrownList(MethodTree methodTree, ListTree<TypeTree> thrownList) {
     Set<Type> thrownExceptions = thrownExceptionsFromBody(methodTree);
     boolean hasTryWithResourceInBody = hasTryWithResourceInBody(methodTree);
-
+    boolean isOverridableMethod = ((JavaSymbol.MethodJavaSymbol) methodTree.symbol()).isOverridable();
+    List<String> undocumentedExceptionNames = new Javadoc(methodTree).undocumentedThrownExceptions();
     Set<String> reported = new HashSet<>();
+
     for (TypeTree typeTree : thrownList) {
       Type exceptionType = typeTree.symbolType();
       if (hasTryWithResourceInBody && (exceptionType.is("java.io.IOException") || exceptionType.is("java.lang.Exception"))) {
@@ -85,7 +95,7 @@ public void visitNode(Tree tree) {
           reportIssue(typeTree, String.format("Remove the declaration of thrown exception '%s' which is a runtime exception.", fullyQualifiedName));
         } else if (declaredMoreThanOnce(fullyQualifiedName, thrownList)) {
           reportIssue(typeTree, String.format("Remove the redundant '%s' thrown exception declaration(s).", fullyQualifiedName));
-        } else if (canNotBeThrown(methodTree, exceptionType, thrownExceptions)) {
+        } else if (canNotBeThrown(methodTree, exceptionType, thrownExceptions) && (!isOverridableMethod || undocumentedExceptionNames.contains(exceptionType.name()))) {
           reportIssue(typeTree, String.format("Remove the declaration of thrown exception '%s', as it cannot be thrown from %s's body.", fullyQualifiedName,
             methodTreeType(methodTree)));
         }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java b/java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java
index 3a5b03a314..ebdccf5cb4 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/RedundantTypeCastCheck.java
@@ -21,9 +21,16 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
-
+import java.util.List;
+import java.util.Set;
+import java.util.function.Predicate;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import javax.annotation.CheckForNull;
 import org.sonar.check.Rule;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.JavaSymbol;
+import org.sonar.java.resolve.JavaSymbol.MethodJavaSymbol;
 import org.sonar.java.resolve.JavaType;
 import org.sonar.java.resolve.MethodJavaType;
 import org.sonar.java.resolve.TypeVariableJavaType;
@@ -39,14 +46,11 @@
 import org.sonar.plugins.java.api.tree.TypeCastTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.CheckForNull;
-
-import java.util.List;
-import java.util.Set;
-
 @Rule(key = "S1905")
 public class RedundantTypeCastCheck extends IssuableSubscriptionVisitor {
 
+  private static final Predicate<JavaSymbol> NON_DEFAULT_METHOD_PREDICATE = symbol -> !symbol.isDefault();
+
   private Set<Tree> excluded = Sets.newHashSet();
 
   @Override
@@ -73,7 +77,7 @@ public void visitNode(Tree tree) {
       // Primitive wrappers excluded because covered by S2154
       return;
     }
-    if(target != null && (isRedundantNumericalCast(cast, expressionType) || isSubtype(expressionType, target))) {
+    if (target != null && (isRedundantNumericalCast(cast, expressionType) || isUnnecessarySubtypeCast(expressionType, typeCastTree, target))) {
       reportIssue(typeCastTree.type(), "Remove this unnecessary cast to \"" + cast + "\".");
     }
   }
@@ -81,7 +85,8 @@ public void visitNode(Tree tree) {
   private static boolean requiredForMemberAccess(TypeCastTree typeCastTree) {
     ExpressionTree expression = typeCastTree.expression();
     if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {
-      return false;
+      Tree parent = typeCastTree.parent();
+      return expression.is(Tree.Kind.METHOD_REFERENCE) && parent != null && skipParentheses(parent).is(Tree.Kind.MEMBER_SELECT);
     }
     Symbol symbol = ((MethodInvocationTree) expression).symbol();
     if (!symbol.isMethodSymbol()) {
@@ -139,9 +144,33 @@ private static Tree skipParentheses(Tree parent) {
     return skip;
   }
 
-  private static boolean isSubtype(Type expression, Type target) {
-    return expression.isSubtypeOf(target);
+  private static boolean isUnnecessarySubtypeCast(Type childType, TypeCastTree typeCastTree, Type parentType) {
+    return childType.isSubtypeOf(parentType)
+      && (!ExpressionUtils.skipParentheses(typeCastTree.expression()).is(Tree.Kind.LAMBDA_EXPRESSION)
+        || isUnnecessaryLambdaCast(childType, parentType));
+  }
+
+  private static boolean isUnnecessaryLambdaCast(Type childType, Type parentType) {
+    if (parentType.isSubtypeOf(childType)) {
+      return true;
+    }
+
+    List<MethodJavaSymbol> childMethods = getMethodSymbolsOf(childType).collect(Collectors.toList());
+    return childMethods.isEmpty() || (childMethods.size() == 1 && isSingleAbstractMethodOverride(childMethods.get(0), parentType));
+  }
+
+  private static boolean isSingleAbstractMethodOverride(MethodJavaSymbol childMethod, Type parentType) {
+    MethodJavaSymbol overriddenSymbol = childMethod.overriddenSymbol();
+    return !childMethod.isDefault() && overriddenSymbol != null
+      && getMethodSymbolsOf(parentType).filter(NON_DEFAULT_METHOD_PREDICATE).anyMatch(overriddenSymbol::equals);
   }
+
+  private static Stream<MethodJavaSymbol> getMethodSymbolsOf(Type type) {
+    return type.symbol().memberSymbols().stream()
+      .filter(Symbol::isMethodSymbol)
+      .map(MethodJavaSymbol.class::cast);
+  }
+
   private static boolean isRedundantNumericalCast(Type cast, Type expressionType) {
     return cast.isNumerical() && cast.equals(expressionType);
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/RegexPatternsNeedlesslyCheck.java b/java-checks/src/main/java/org/sonar/java/checks/RegexPatternsNeedlesslyCheck.java
new file mode 100755
index 0000000000..110636ff33
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/RegexPatternsNeedlesslyCheck.java
@@ -0,0 +1,119 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import java.util.regex.Pattern;
+import org.sonar.check.Rule;
+import org.sonar.java.checks.methods.AbstractMethodDetection;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.java.model.LiteralUtils;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.LiteralTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.VariableTree;
+
+@Rule(key = "S4248")
+public class RegexPatternsNeedlesslyCheck extends AbstractMethodDetection {
+
+  private static final String STRING = "java.lang.String";
+  private static final String PATTERN = "java.util.regex.Pattern";
+  private static final Pattern SPLIT_EXCLUSION = Pattern.compile("[\\$\\.\\|\\(\\)\\[\\{\\^\\?\\*\\+\\\\]|\\\\\\w");
+
+  @Override
+  protected List<MethodMatcher> getMethodInvocationMatchers() {
+    return ImmutableList.of(
+      MethodMatcher.create().typeDefinition(PATTERN).name("compile").addParameter(STRING),
+      MethodMatcher.create().typeDefinition(STRING).name("matches").withAnyParameters(),
+      MethodMatcher.create().typeDefinition(STRING).name("split").withAnyParameters(),
+      MethodMatcher.create().typeDefinition(STRING).name("replaceAll").withAnyParameters(),
+      MethodMatcher.create().typeDefinition(STRING).name("replaceFirst").withAnyParameters());
+  }
+
+  @Override
+  protected void onMethodInvocationFound(MethodInvocationTree mit) {
+    ExpressionTree firstArgument = ExpressionUtils.skipParentheses(mit.arguments().get(0));
+    if (isSplitMethod(mit) && firstArgument.is(Tree.Kind.STRING_LITERAL)) {
+      String argValue = LiteralUtils.trimQuotes(((LiteralTree) firstArgument).value());
+      if ((exceptionSplitMethod(argValue) &&
+        !SPLIT_EXCLUSION.matcher(argValue).matches()) || metaCharactersInSplit(argValue)) {
+        return;
+      }
+    }
+    if (!storedInStaticFinal(mit) && (firstArgument.is(Tree.Kind.STRING_LITERAL) || isConstant(firstArgument))) {
+      reportIssue(ExpressionUtils.methodName(mit), mit.arguments(), "Refactor this code to use a \"static final\" Pattern.");
+    }
+  }
+
+  private static boolean storedInStaticFinal(MethodInvocationTree mit) {
+    Tree tree = mit.parent();
+    while (!tree.is(Tree.Kind.VARIABLE, Tree.Kind.CLASS, Tree.Kind.ASSIGNMENT, Tree.Kind.METHOD)) {
+      tree = tree.parent();
+    }
+    if (tree.is(Tree.Kind.CLASS, Tree.Kind.METHOD)) {
+      return false;
+    } else {
+      return isConstant(tree);
+    }
+  }
+
+  private static boolean isConstant(Tree tree) {
+    Symbol symbol = null;
+    switch (tree.kind()) {
+      case IDENTIFIER:
+        symbol = ((IdentifierTree) tree).symbol();
+        break;
+      case MEMBER_SELECT:
+        symbol = (((MemberSelectExpressionTree) tree).identifier()).symbol();
+        break;
+      case VARIABLE:
+        symbol = ((VariableTree) tree).symbol();
+        break;
+      case ASSIGNMENT:
+        return isConstant(((AssignmentExpressionTree) tree).variable());
+      default:
+        break;
+    }
+    return symbol != null && symbol.isFinal() && symbol.isStatic();
+  }
+
+  private static boolean metaCharactersInSplit(String argValue) {
+    int strLength = argValue.length();
+    return ((strLength == 3 && argValue.charAt(1) == '\\' && argValue.charAt(0) == '\\'
+      && SPLIT_EXCLUSION.matcher(Character.toString(argValue.charAt(2))).matches()) ||
+      (strLength == 4 && argValue.charAt(0) == '\\' && argValue.charAt(3) == '\\'));
+  }
+
+  private static boolean exceptionSplitMethod(String argValue) {
+    int strLength = argValue.length();
+    return strLength == 1 || (strLength == 2 && argValue.charAt(0) == '\\');
+  }
+
+  private static boolean isSplitMethod(MethodInvocationTree mit) {
+    return mit.symbol().name().equals("split");
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ResultSetIsLastCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ResultSetIsLastCheck.java
index f40b315dc7..6fc2c98775 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ResultSetIsLastCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ResultSetIsLastCheck.java
@@ -20,14 +20,13 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2232")
 public class ResultSetIsLastCheck extends AbstractMethodDetection {
 
@@ -38,6 +37,6 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove this call to \"isLast()\".");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove this call to \"isLast()\".");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/RunFinalizersCheck.java b/java-checks/src/main/java/org/sonar/java/checks/RunFinalizersCheck.java
index a9592b85bf..1b21203704 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/RunFinalizersCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/RunFinalizersCheck.java
@@ -20,14 +20,13 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2151")
 public class RunFinalizersCheck extends AbstractMethodDetection {
 
@@ -41,6 +40,6 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove this call to \"" + mit.symbol().owner().name() + ".runFinalizersOnExit()\".");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove this call to \"" + mit.symbol().owner().name() + ".runFinalizersOnExit()\".");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java
index 4994787123..11bbfe3fba 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ServletMethodsExceptionsThrownCheck.java
@@ -20,11 +20,15 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.ArrayDeque;
+import java.util.ArrayList;
+import java.util.Deque;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.NameCriteria;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.semantic.Type;
@@ -35,11 +39,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TryStatementTree;
 
-import java.util.ArrayDeque;
-import java.util.ArrayList;
-import java.util.Deque;
-import java.util.List;
-
 @Rule(key = "S1989")
 public class ServletMethodsExceptionsThrownCheck extends IssuableSubscriptionVisitor {
 
@@ -104,7 +103,7 @@ private void checkMethodInvocation(MethodInvocationTree node) {
     if (symbol.isMethodSymbol()) {
       List<Type> types = ((Symbol.MethodSymbol) symbol).thrownTypes();
       if (!types.isEmpty()) {
-        addIssueIfNotCatched(types, MethodsHelper.methodName(node), "Add a \"try/catch\" block for \"" + symbol.name() + "\".");
+        addIssueIfNotCatched(types, ExpressionUtils.methodName(node), "Add a \"try/catch\" block for \"" + symbol.name() + "\".");
       }
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SillyEqualsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SillyEqualsCheck.java
index d12ab9f8bc..e1c5c05fd2 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/SillyEqualsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/SillyEqualsCheck.java
@@ -21,10 +21,11 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.JavaType;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
@@ -33,8 +34,6 @@
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2159")
 public class SillyEqualsCheck extends AbstractMethodDetection {
 
@@ -57,7 +56,7 @@ protected void onMethodInvocationFound(MethodInvocationTree tree) {
       argumentType = ((JavaType) argumentType).primitiveWrapperType();
     }
     Type ownerType = getMethodOwnerType(tree).erasure();
-    IdentifierTree methodInvocationName = MethodsHelper.methodName(tree);
+    IdentifierTree methodInvocationName = ExpressionUtils.methodName(tree);
     if (isLiteralNull(firstArgument)) {
       reportIssue(methodInvocationName, "Remove this call to \"equals\"; comparisons against null always return false; consider using '== null' to check for nullity.");
     } else if (ownerType.isArray()) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/StringPrimitiveConstructorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/StringPrimitiveConstructorCheck.java
index f3e0002edf..d7527639e7 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/StringPrimitiveConstructorCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/StringPrimitiveConstructorCheck.java
@@ -45,12 +45,14 @@
       MethodMatcher.create().typeDefinition("java.lang.Long").name(INIT).addParameter("long"),
       MethodMatcher.create().typeDefinition("java.lang.Float").name(INIT).addParameter("float"),
       MethodMatcher.create().typeDefinition("java.lang.Double").name(INIT).addParameter("double"),
-      MethodMatcher.create().typeDefinition("java.lang.Boolean").name(INIT).addParameter("boolean")
+      MethodMatcher.create().typeDefinition("java.lang.Boolean").name(INIT).addParameter("boolean"),
+      MethodMatcher.create().typeDefinition("java.math.BigInteger").name(INIT).addParameter(STRING),
+      MethodMatcher.create().typeDefinition("java.math.BigDecimal").name(INIT).addParameter("double")
     );
   }
 
   @Override
   protected void onConstructorFound(NewClassTree newClassTree) {
-    reportIssue(newClassTree.identifier(), "Remove this \""+newClassTree.symbolType().name()+"\" constructor");
+    reportIssue(newClassTree.identifier(), "Remove this \"" + newClassTree.symbolType().name() + "\" constructor");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/StringToStringCheck.java b/java-checks/src/main/java/org/sonar/java/checks/StringToStringCheck.java
index e471685918..5f1083268b 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/StringToStringCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/StringToStringCheck.java
@@ -20,10 +20,11 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.ArrayAccessExpressionTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
@@ -33,8 +34,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TypeCastTree;
 
-import java.util.List;
-
 @Rule(key = "S1858")
 public class StringToStringCheck extends AbstractMethodDetection {
 
@@ -55,7 +54,7 @@ protected void onMethodInvocationFound(MethodInvocationTree tree) {
     } else if (expressionTree.is(Tree.Kind.STRING_LITERAL)) {
       reportIssue(expressionTree, "there's no need to call \"toString()\" on a string literal.");
     } else if (expressionTree.is(Tree.Kind.METHOD_INVOCATION)) {
-      IdentifierTree methodName = MethodsHelper.methodName((MethodInvocationTree) expressionTree);
+      IdentifierTree methodName = ExpressionUtils.methodName((MethodInvocationTree) expressionTree);
       reportIssue(methodName, "\"" + methodName + "\" returns a string, there's no need to call \"toString()\".");
     } else if (expressionTree.is(Tree.Kind.ARRAY_ACCESS_EXPRESSION)) {
       ArrayAccessExpressionTree arrayAccess = (ArrayAccessExpressionTree) expressionTree;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SwitchDefaultLastCaseCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SwitchDefaultLastCaseCheck.java
new file mode 100755
index 0000000000..8e41da3423
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/SwitchDefaultLastCaseCheck.java
@@ -0,0 +1,69 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import org.sonar.check.Rule;
+import org.sonar.java.ast.api.JavaKeyword;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.CaseLabelTree;
+import org.sonar.plugins.java.api.tree.SwitchStatementTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S4524")
+public class SwitchDefaultLastCaseCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return Collections.singletonList(Tree.Kind.SWITCH_STATEMENT);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
+    getDefaultLabelAtWrongPosition(switchStatementTree).ifPresent(defaultLabel -> reportIssue(defaultLabel, "Move this default to the end of the switch."));
+  }
+
+  private static Optional<CaseLabelTree> getDefaultLabelAtWrongPosition(SwitchStatementTree switchStatementTree) {
+    for (int i = 0; i < switchStatementTree.cases().size(); i++) {
+      List<CaseLabelTree> labels = switchStatementTree.cases().get(i).labels();
+      for (int j = 0; j < labels.size(); j++) {
+        CaseLabelTree label = labels.get(j);
+        boolean defaultExists = isDefault(label);
+        if (defaultExists && ((j != labels.size() - 1) || (j == labels.size() - 1 && i == switchStatementTree.cases().size() - 1))) {
+          /*
+           * we return Optional.empty() because either we have default at the end which is a best practise
+           * or it is in a place in a case group where it can not affect the result of the execution
+           */
+          return Optional.empty();
+        } else if (defaultExists) {
+          return Optional.of(label);
+        }
+      }
+    }
+    return Optional.empty();
+  }
+
+  private static boolean isDefault(CaseLabelTree caseLabelTree) {
+    return JavaKeyword.DEFAULT.getValue().equals(caseLabelTree.caseOrDefaultKeyword().text());
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/SwitchLastCaseIsDefaultCheck.java b/java-checks/src/main/java/org/sonar/java/checks/SwitchLastCaseIsDefaultCheck.java
index 460f708563..85d780da64 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/SwitchLastCaseIsDefaultCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/SwitchLastCaseIsDefaultCheck.java
@@ -19,29 +19,25 @@
  */
 package org.sonar.java.checks;
 
-import com.google.common.collect.ImmutableList;
-
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Stream;
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
 import org.sonar.java.ast.api.JavaKeyword;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.semantic.Symbol;
-import org.sonar.plugins.java.api.tree.CaseGroupTree;
 import org.sonar.plugins.java.api.tree.CaseLabelTree;
 import org.sonar.plugins.java.api.tree.SwitchStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-import java.util.Optional;
-import java.util.stream.Stream;
-
 @Rule(key = "SwitchLastCaseIsDefaultCheck")
 @RspecKey("S131")
 public class SwitchLastCaseIsDefaultCheck extends IssuableSubscriptionVisitor {
 
   @Override
   public List<Tree.Kind> nodesToVisit() {
-    return ImmutableList.of(Tree.Kind.SWITCH_STATEMENT);
+    return Collections.singletonList(Tree.Kind.SWITCH_STATEMENT);
   }
 
   @Override
@@ -50,13 +46,7 @@ public void visitNode(Tree tree) {
       return;
     }
     SwitchStatementTree switchStatementTree = (SwitchStatementTree) tree;
-    Optional<CaseLabelTree> defaultLabel = getDefaultLabel(switchStatementTree);
-    if (defaultLabel.isPresent()) {
-      CaseLabelTree defaultLabelTree = defaultLabel.get();
-      if (!defaultLabelTree.equals(getLastLabel(switchStatementTree))) {
-        reportIssue(defaultLabelTree, "Move this default to the end of the switch.");
-      }
-    } else {
+    if (getDefaultLabel(switchStatementTree)) {
       if (!isSwitchOnEnum(switchStatementTree)) {
         reportIssue(switchStatementTree.switchKeyword(), "Add a default case to this switch.");
       } else if (missingCasesOfEnum(switchStatementTree)) {
@@ -65,8 +55,8 @@ public void visitNode(Tree tree) {
     }
   }
 
-  private static Optional<CaseLabelTree> getDefaultLabel(SwitchStatementTree switchStatementTree) {
-    return allLabels(switchStatementTree).filter(SwitchLastCaseIsDefaultCheck::isDefault).findAny();
+  private static boolean getDefaultLabel(SwitchStatementTree switchStatementTree) {
+    return allLabels(switchStatementTree).noneMatch(SwitchLastCaseIsDefaultCheck::isDefault);
   }
 
   private static boolean isDefault(CaseLabelTree caseLabelTree) {
@@ -91,10 +81,4 @@ private static long numberConstants(SwitchStatementTree switchStatementTree) {
       .filter(Symbol::isEnum)
       .count();
   }
-
-  private static CaseLabelTree getLastLabel(SwitchStatementTree switchStatementTree) {
-    List<CaseGroupTree> caseGroups = switchStatementTree.cases();
-    List<CaseLabelTree> lastCaseLabels = caseGroups.get(caseGroups.size() - 1).labels();
-    return lastCaseLabels.get(lastCaseLabels.size() - 1);
-  }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThisExposedFromConstructorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThisExposedFromConstructorCheck.java
new file mode 100755
index 0000000000..8b70371105
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThisExposedFromConstructorCheck.java
@@ -0,0 +1,108 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import java.util.Collections;
+import java.util.List;
+import org.sonar.check.Rule;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.ClassTree;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S3366")
+public class ThisExposedFromConstructorCheck extends IssuableSubscriptionVisitor {
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return Collections.singletonList(Tree.Kind.CONSTRUCTOR);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (!hasSemantic()) {
+      return;
+    }
+    MethodTree methodTree = (MethodTree) tree;
+    methodTree.block().accept(new ConstructorBodyVisitor(methodTree.symbol().owner()));
+  }
+
+  private class ConstructorBodyVisitor extends BaseTreeVisitor {
+    private Symbol owner;
+
+    public ConstructorBodyVisitor(Symbol owner) {
+      this.owner = owner;
+    }
+
+    @Override
+    public void visitMethodInvocation(MethodInvocationTree tree) {
+      if (this.owner == tree.symbol().owner()) {
+        return;
+      }
+      tree.arguments().stream().filter(this::isThis).forEach(this::report);
+      super.visitMethodInvocation(tree);
+    }
+
+    @Override
+    public void visitAssignmentExpression(AssignmentExpressionTree tree) {
+      if (!isThis(tree.expression())) {
+        return;
+      }
+      ExpressionTree variable = tree.variable();
+      if (variable.is(Tree.Kind.MEMBER_SELECT)) {
+        MemberSelectExpressionTree memberSelect = (MemberSelectExpressionTree) variable;
+        // not an issue because "this" is assigned to an object of the same type which is also defined as static
+        if (memberSelect.expression().symbolType().symbol().equals(this.owner) && memberSelect.identifier().symbol().isStatic()) {
+          return;
+        }
+      } else if (variable.is(Tree.Kind.IDENTIFIER) && (((IdentifierTree) variable).symbol().isStatic())) {
+        return;
+      }
+      report(tree);
+    }
+
+    @Override
+    public void visitClass(ClassTree tree) {
+      // skip nested and anonymous classes
+    }
+
+    private boolean isThis(ExpressionTree expression) {
+      ExpressionTree expressionNoParenthesis = ExpressionUtils.skipParentheses(expression);
+      if (expressionNoParenthesis.is(Tree.Kind.IDENTIFIER)) {
+        String targetName = ((IdentifierTree) expressionNoParenthesis).name();
+        return "this".equals(targetName);
+      }
+      return false;
+    }
+
+    private void report(ExpressionTree tree) {
+      reportIssue(tree, "Make sure the use of \"this\" doesn't" +
+        " expose partially-constructed instances of this class in multi-threaded environments.");
+    }
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java
index 5e9ce4d425..06f05a0e26 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadRunCheck.java
@@ -20,18 +20,16 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
-
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S1217")
 public class ThreadRunCheck extends AbstractMethodDetection {
   private static final MethodMatcher THREAD_RUN_METHOD_MATCHER = MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("java.lang.Thread")).name("run")
@@ -51,7 +49,7 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {
     if (parent != null && THREAD_RUN_METHOD_MATCHER.matches((MethodTree) parent)) {
       return;
     }
-    reportIssue(MethodsHelper.methodName(mit), "Call the method Thread.start() to execute the content of the run() method in a dedicated thread.");
+    reportIssue(ExpressionUtils.methodName(mit), "Call the method Thread.start() to execute the content of the run() method in a dedicated thread.");
   }
 
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepCheck.java
index 242ade790a..be976f668d 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepCheck.java
@@ -20,20 +20,19 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2276")
 public class ThreadSleepCheck extends AbstractInSynchronizeChecker {
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
     if (isInSyncBlock()) {
-      reportIssue(MethodsHelper.methodName(mit), "Replace the call to \"Thread.sleep(...)\" with a call to \"wait(...)\".");
+      reportIssue(ExpressionUtils.methodName(mit), "Replace the call to \"Thread.sleep(...)\" with a call to \"wait(...)\".");
     }
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepInTestsCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepInTestsCheck.java
index fcab40b22f..2ebda7e127 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepInTestsCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadSleepInTestsCheck.java
@@ -20,19 +20,18 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2925")
 public class ThreadSleepInTestsCheck extends AbstractMethodDetection {
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Remove this use of \"Thread.sleep()\".");
+    reportIssue(ExpressionUtils.methodName(mit), "Remove this use of \"Thread.sleep()\".");
   }
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadStartedInConstructorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadStartedInConstructorCheck.java
index 7e3911d6eb..5d4bfd7c1c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadStartedInConstructorCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadStartedInConstructorCheck.java
@@ -20,20 +20,19 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.Deque;
+import java.util.LinkedList;
+import java.util.List;
 import org.apache.commons.lang.BooleanUtils;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.tree.ClassTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 
-import java.util.Deque;
-import java.util.LinkedList;
-import java.util.List;
-
 @Rule(key = "S2693")
 public class ThreadStartedInConstructorCheck extends IssuableSubscriptionVisitor {
 
@@ -57,7 +56,7 @@ public void visitNode(Tree tree) {
       } else if (tree.is(Tree.Kind.METHOD, Tree.Kind.STATIC_INITIALIZER)) {
         inMethodOrStaticInitializerOrFinalClass.push(Boolean.TRUE);
       } else if (BooleanUtils.isFalse(inMethodOrStaticInitializerOrFinalClass.peek()) && THREAD_START.matches((MethodInvocationTree) tree)) {
-        reportIssue(MethodsHelper.methodName((MethodInvocationTree) tree), "Move this \"start\" call to another method.");
+        reportIssue(ExpressionUtils.methodName((MethodInvocationTree) tree), "Move this \"start\" call to another method.");
       }
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java b/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java
index d9acd53d97..0de79e7dcd 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/ThreadWaitCallCheck.java
@@ -20,21 +20,20 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S2236")
 public class ThreadWaitCallCheck extends AbstractMethodDetection {
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "Refactor the synchronisation mechanism to not use a Thread instance as a monitor");
+    reportIssue(ExpressionUtils.methodName(mit), "Refactor the synchronisation mechanism to not use a Thread instance as a monitor");
   }
 
   @Override
diff --git a/java-checks/src/main/java/org/sonar/java/checks/UndocumentedApiCheck.java b/java-checks/src/main/java/org/sonar/java/checks/UndocumentedApiCheck.java
index 0d73994bce..3687452348 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/UndocumentedApiCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/UndocumentedApiCheck.java
@@ -19,28 +19,18 @@
  */
 package org.sonar.java.checks;
 
-import com.google.common.collect.ImmutableSet;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
 import java.util.Deque;
-import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Set;
-import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
-import javax.annotation.Nullable;
 import org.apache.commons.lang.StringUtils;
 import org.sonar.api.utils.WildcardPattern;
 import org.sonar.check.Rule;
 import org.sonar.check.RuleProperty;
 import org.sonar.java.RspecKey;
 import org.sonar.java.ast.visitors.PublicApiChecker;
-import org.sonar.java.checks.helpers.ExpressionsHelper;
+import org.sonar.java.checks.helpers.Javadoc;
 import org.sonar.java.model.PackageUtils;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
@@ -49,14 +39,11 @@
 import org.sonar.plugins.java.api.tree.ClassTree;
 import org.sonar.plugins.java.api.tree.CompilationUnitTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
-import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.PrimitiveTypeTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
-import org.sonar.plugins.java.api.tree.TypeParameterTree;
-import org.sonar.plugins.java.api.tree.TypeTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
 @Rule(key = "UndocumentedApi")
@@ -117,7 +104,7 @@ public void visitNewClass(NewClassTree tree) {
 
   @Override
   public void visitClass(ClassTree tree) {
-    //No anonymous class, no visit of new class trees.
+    // No anonymous class, no visit of new class trees.
     visitNode(tree, tree.simpleName(), tree.symbol().metadata());
     super.visitClass(tree);
     classTrees.pop();
@@ -143,14 +130,14 @@ private void visitNode(Tree tree, Tree reportTree, SymbolMetadata symbolMetadata
       if (javadoc.noMainDescription() && !isNonVoidMethodWithNoParameter(tree, javadoc)) {
         context.reportIssue(this, reportTree, "Document this public " + getType(tree) + " by adding an explicit description.");
       } else {
-        List<String> undocumentedParameters = javadoc.undocumentedParameters(tree);
+        List<String> undocumentedParameters = javadoc.undocumentedParameters();
         if (!undocumentedParameters.isEmpty()) {
           context.reportIssue(this, reportTree, "Document the parameter(s): " + undocumentedParameters.stream().collect(Collectors.joining(", ")));
         }
         if (hasNonVoidReturnType(tree) && javadoc.noReturnDescription()) {
           context.reportIssue(this, reportTree, "Document this method return value.");
         }
-        List<String> undocumentedExceptions = javadoc.undocumentedThrownExceptions(tree);
+        List<String> undocumentedExceptions = javadoc.undocumentedThrownExceptions();
         if (!undocumentedExceptions.isEmpty()) {
           context.reportIssue(this, reportTree, "Document this method thrown exception(s): " + undocumentedExceptions.stream().collect(Collectors.joining(", ")));
         }
@@ -283,198 +270,4 @@ private boolean hasNonVoidReturnType(Tree tree) {
     return false;
   }
 
-  private static class Javadoc {
-    private static final Pattern PARAMETER_JAVADOC_PATTERN = Pattern.compile(".*@param\\s++(?<name>\\S*)(\\s++)?(?<descr>.+)?");
-    private static final Pattern EXCEPTION_JAVADOC_PATTERN = Pattern.compile(".*@throws\\s++(?<name>\\S*)(\\s++)?(?<descr>.+)?");
-    private static final Pattern RETURN_JAVADOC_PATTERN = Pattern.compile(".*@return(\\s++)?(?<descr>.+)?");
-    private static final Set<String> PLACEHOLDERS = ImmutableSet.of("TODO", "FIXME", "...", ".");
-
-    private final String mainDescription;
-    private final Map<String, List<String>> parameters;
-    private final Map<String, List<String>> thrownExceptions;
-    private final String returnDescription;
-
-    Javadoc(Tree tree) {
-      String javadoc = PublicApiChecker.getApiJavadoc(tree);
-      List<String> lines = cleanedlines(javadoc);
-
-      mainDescription = extractMainDescription(lines);
-      parameters = extractToMap(lines, PARAMETER_JAVADOC_PATTERN);
-      thrownExceptions = extractToMap(lines, EXCEPTION_JAVADOC_PATTERN);
-      returnDescription = extractReturnDescription(lines);
-    }
-
-    public boolean noMainDescription() {
-      return isEmptyDescription(mainDescription);
-    }
-
-    public boolean noReturnDescription() {
-      return isEmptyDescription(returnDescription);
-    }
-
-    public List<String> undocumentedParameters(Tree tree) {
-      return getParameters(tree).stream()
-        .filter(name -> isEmptyDescription(parameters.get(name)))
-        .collect(Collectors.toList());
-    }
-
-    public List<String> undocumentedThrownExceptions(Tree tree) {
-      List<String> exceptionNames = getExceptions(tree);
-      if (exceptionNames.size() == 1 && "Exception".equals(exceptionNames.get(0)) && !thrownExceptions.isEmpty()) {
-        // check for described exceptions when only "Exception" is used is declared as being thrown
-        return thrownExceptions.entrySet().stream()
-          .filter(e -> isEmptyDescription(e.getValue()))
-          .map(Map.Entry::getKey)
-          .map(Javadoc::toSimpleName)
-          .collect(Collectors.toList());
-      }
-      return exceptionNames.stream()
-        .filter(this::noDescriptionForException)
-        .map(Javadoc::toSimpleName)
-        .collect(Collectors.toList());
-    }
-
-    private boolean noDescriptionForException(String exceptionName) {
-      // try getting the exception described with exact match
-      List<String> descriptions = thrownExceptions.get(exceptionName);
-      if (descriptions == null) {
-        // exceptions used in javadoc is using simple name when method declaration use fully qualified name
-        descriptions = thrownExceptions.get(toSimpleName(exceptionName));
-      }
-      if (descriptions == null) {
-        // exceptions used in javadoc is using fully qualified name when method declaration use simple name
-        descriptions = thrownExceptions.entrySet().stream()
-          .filter(e -> toSimpleName(e.getKey()).equals(exceptionName))
-          .map(Map.Entry::getValue)
-          .flatMap(List::stream)
-          .collect(Collectors.toList());
-      }
-      return isEmptyDescription(descriptions);
-    }
-
-    private static String toSimpleName(String exceptionName) {
-      int lastDot = exceptionName.lastIndexOf('.');
-      if (lastDot != -1) {
-        return exceptionName.substring(lastDot + 1);
-      }
-      return exceptionName;
-    }
-
-    private static boolean isEmptyDescription(@Nullable List<String> descriptions) {
-      return descriptions == null || descriptions.isEmpty() || descriptions.stream().anyMatch(Javadoc::isEmptyDescription);
-    }
-
-    private static boolean isEmptyDescription(@Nullable String part) {
-      return part == null
-        || part.trim().isEmpty()
-        || PLACEHOLDERS.contains(part);
-    }
-
-    private static List<String> getParameters(Tree tree) {
-      if (tree.is(METHOD_KINDS)) {
-        return ((MethodTree) tree).parameters().stream()
-          .map(VariableTree::simpleName)
-          .map(IdentifierTree::name)
-          .collect(Collectors.toList());
-      }
-      // don't check type parameters documentation for methods
-      if (tree.is(CLASS_KINDS)) {
-        return ((ClassTree) tree).typeParameters().stream()
-          .map(TypeParameterTree::identifier)
-          .map(IdentifierTree::name)
-          .map(name -> "<" + name + ">")
-          .collect(Collectors.toList());
-      }
-      return Collections.emptyList();
-    }
-
-    private static List<String> getExceptions(Tree tree) {
-      if (tree.is(METHOD_KINDS)) {
-        return ((MethodTree) tree).throwsClauses().stream()
-          .map(Javadoc::exceptionName)
-          .filter(Objects::nonNull)
-          .collect(Collectors.toList());
-      }
-      return Collections.emptyList();
-    }
-
-    private static String exceptionName(TypeTree typeTree) {
-      switch (typeTree.kind()) {
-        case IDENTIFIER:
-          return ((IdentifierTree) typeTree).name();
-        case MEMBER_SELECT:
-          return ExpressionsHelper.concatenate((MemberSelectExpressionTree) typeTree);
-        default:
-          // Should never happen - Throwable can not be extended by a parameterized type
-          throw new IllegalStateException("Exceptions can not be specified other than with an identifier or a fully qualified name.");
-      }
-    }
-
-    private static List<String> cleanedlines(@Nullable String javadoc) {
-      if (javadoc == null) {
-        return Collections.emptyList();
-      }
-      String[] lines = cleanupJavadoc(javadoc).split("\\r?\\n");
-      return Arrays.stream(lines).map(String::trim).collect(Collectors.toList());
-    }
-
-    private static String cleanupJavadoc(String javadoc) {
-      // remove start and end of Javadoc as well as stars.
-      return javadoc.trim().substring(3).replace("*/", "").replace("*", "").trim();
-    }
-
-    private static String extractMainDescription(List<String> lines) {
-      StringBuilder sb = new StringBuilder();
-      for (String line : lines) {
-        if (line.matches("(@param|@throws|@return).*")) {
-          break;
-        }
-        sb.append(line).append(" ");
-      }
-      return sb.toString().trim();
-    }
-
-    private static Map<String, List<String>> extractToMap(List<String> lines, Pattern pattern) {
-      Map<String, List<String>> results = new HashMap<>();
-      for (int i = 0; i < lines.size(); i++) {
-        Matcher matcher = pattern.matcher(lines.get(i));
-        if (matcher.matches()) {
-          List<String> descriptions = results.computeIfAbsent(matcher.group("name"), key -> new ArrayList<>());
-          String newDescription = getNextLineIfNeeded(lines, i, matcher.group("descr"));
-          if (newDescription != null) {
-            descriptions.add(newDescription);
-          }
-        }
-      }
-      return results;
-    }
-
-    private static String extractReturnDescription(List<String> lines) {
-      for (int i = 0; i < lines.size(); i++) {
-        String line = lines.get(i);
-        Matcher matcher = RETURN_JAVADOC_PATTERN.matcher(line);
-        if (matcher.matches()) {
-          String returnDescription = getNextLineIfNeeded(lines, i, matcher.group("descr"));
-          if (returnDescription != null) {
-            return returnDescription;
-          }
-        }
-      }
-      return "";
-    }
-
-    private static String getNextLineIfNeeded(List<String> lines, int currentIndex, @Nullable String currrentValue) {
-      if (currrentValue == null && currentIndex < lines.size() - 1) {
-        String nextLine = lines.get(currentIndex + 1);
-        // not an element declaration
-        if (!nextLine.startsWith("@")) {
-          // assume the description is on the next line
-          return nextLine;
-        }
-      }
-      return currrentValue;
-    }
-
-  }
-
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/WaitInSynchronizeCheck.java b/java-checks/src/main/java/org/sonar/java/checks/WaitInSynchronizeCheck.java
index e778c8a42c..5ebaee3110 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/WaitInSynchronizeCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/WaitInSynchronizeCheck.java
@@ -20,29 +20,28 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
 import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.List;
-
 @Rule(key = "S2273")
 public class WaitInSynchronizeCheck extends AbstractInSynchronizeChecker {
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
     if (!isInSyncBlock()) {
-      IdentifierTree methodName;
+      IdentifierTree methodName = ExpressionUtils.methodName(mit);
+      ExpressionTree methodSelect = mit.methodSelect();
       String lockName;
-      if (mit.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {
-        MemberSelectExpressionTree mse = (MemberSelectExpressionTree) mit.methodSelect();
-        methodName = mse.identifier();
-        lockName = mse.expression().symbolType().name();
+      if (methodSelect.is(Tree.Kind.MEMBER_SELECT)) {
+        lockName = ((MemberSelectExpressionTree) methodSelect).expression().symbolType().name();
       } else {
-        methodName = (IdentifierTree) mit.methodSelect();
         lockName = "this";
       }
       reportIssue(methodName, "Move this call to \"" + methodName + "()\" into a synchronized block to be sure the monitor on \"" + lockName + "\" is held.");
diff --git a/java-checks/src/main/java/org/sonar/java/checks/WaitInWhileLoopCheck.java b/java-checks/src/main/java/org/sonar/java/checks/WaitInWhileLoopCheck.java
index 400015cee0..6720540fd6 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/WaitInWhileLoopCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/WaitInWhileLoopCheck.java
@@ -21,20 +21,19 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import java.util.Deque;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.NameCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.tree.ForStatementTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.Deque;
-import java.util.List;
-
 @Rule(key = "S2274")
 public class WaitInWhileLoopCheck extends AbstractMethodDetection {
 
@@ -74,7 +73,7 @@ public void leaveNode(Tree tree) {
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
     if (!inWhileLoop.peek()) {
-      IdentifierTree identifierTree = MethodsHelper.methodName(mit);
+      IdentifierTree identifierTree = ExpressionUtils.methodName(mit);
       reportIssue(identifierTree, "Remove this call to \"" + identifierTree.name() + "\" or move it into a \"while\" loop.");
     }
   }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java b/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java
index 2b540d31bf..eafe74c620 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/WaitOnConditionCheck.java
@@ -20,15 +20,14 @@
 package org.sonar.java.checks;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.methods.AbstractMethodDetection;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 
-import java.util.List;
-
 @Rule(key = "S1844")
 public class WaitOnConditionCheck extends AbstractMethodDetection {
 
@@ -44,6 +43,6 @@
 
   @Override
   protected void onMethodInvocationFound(MethodInvocationTree mit) {
-    reportIssue(MethodsHelper.methodName(mit), "The \"Condition.await(...)\" method should be used instead of \"Object.wait(...)\"");
+    reportIssue(ExpressionUtils.methodName(mit), "The \"Condition.await(...)\" method should be used instead of \"Object.wait(...)\"");
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/WeakSSLContextCheck.java b/java-checks/src/main/java/org/sonar/java/checks/WeakSSLContextCheck.java
new file mode 100755
index 0000000000..4035e5c6d4
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/WeakSSLContextCheck.java
@@ -0,0 +1,68 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+import org.sonar.check.Rule;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.Arguments;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.LiteralTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+import static org.sonar.java.model.LiteralUtils.trimQuotes;
+
+@Rule(key = "S4423")
+public class WeakSSLContextCheck extends IssuableSubscriptionVisitor {
+
+  private static final Set<String> STRONG_PROTOCOLS = new HashSet<>(Arrays.asList("TLSv1.2", "DTLSv1.2"));
+
+  private static final MethodMatcher SSLCONTEXT_GETINSTANCE_MATCHER = MethodMatcher.create()
+    .typeDefinition("javax.net.ssl.SSLContext")
+    .name("getInstance")
+    .withAnyParameters();
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (hasSemantic()) {
+      MethodInvocationTree mit = (MethodInvocationTree) tree;
+      Arguments arguments = mit.arguments();
+      if (SSLCONTEXT_GETINSTANCE_MATCHER.matches(mit)) {
+        ExpressionTree firstArgument = arguments.get(0);
+        if (firstArgument.is(Tree.Kind.STRING_LITERAL) && !STRONG_PROTOCOLS.contains(trimQuotes(((LiteralTree) firstArgument).value()))) {
+          reportIssue(firstArgument, "Change this code to use a stronger protocol.");
+        }
+      }
+    }
+  }
+
+
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/WrongAssignmentOperatorCheck.java b/java-checks/src/main/java/org/sonar/java/checks/WrongAssignmentOperatorCheck.java
index 66c05a61f1..624282fd5c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/WrongAssignmentOperatorCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/WrongAssignmentOperatorCheck.java
@@ -49,12 +49,24 @@ public void visitNode(Tree tree) {
     if (isSuspiciousToken(expressionFirstToken)
       && noSpacingBetween(operatorToken, expressionFirstToken)
       && !noSpacingBetween(variableLastToken, operatorToken)) {
-      reportIssue(operatorToken, expressionFirstToken, "Was \"" + expressionFirstToken.text() + "=\" meant instead?");
+      reportIssue(operatorToken, expressionFirstToken, getMessage(expressionFirstToken, aeTree));
     }
   }
 
+  private static String getMessage(SyntaxToken expressionFirstToken, AssignmentExpressionTree aeTree) {
+    if (isSingleNegationAssignment(expressionFirstToken, aeTree)) {
+      return "Add a space between \"=\" and \"!\" to avoid confusion.";
+    }
+    return "Was \"" + expressionFirstToken.text() + "=\" meant instead?";
+  }
+
+  private static boolean isSingleNegationAssignment(SyntaxToken firstToken, AssignmentExpressionTree aeTree) {
+    return "!".equals(firstToken.text()) && (aeTree.parent() == null || !aeTree.parent().is(Tree.Kind.ASSIGNMENT));
+  }
+
   private static boolean noSpacingBetween(SyntaxToken firstToken, SyntaxToken secondToken) {
-    return firstToken.column() + firstToken.text().length() == secondToken.column();
+    return firstToken.line() == secondToken.line()
+      && firstToken.column() + firstToken.text().length() == secondToken.column();
   }
 
   private static boolean isSuspiciousToken(SyntaxToken firstToken) {
diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/Javadoc.java b/java-checks/src/main/java/org/sonar/java/checks/helpers/Javadoc.java
new file mode 100755
index 0000000000..7905ffd40d
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/helpers/Javadoc.java
@@ -0,0 +1,284 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.helpers;
+
+import com.google.common.annotations.VisibleForTesting;
+import com.google.common.collect.ImmutableSet;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
+import org.sonar.java.ast.visitors.PublicApiChecker;
+import org.sonar.plugins.java.api.tree.ClassTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.TypeParameterTree;
+import org.sonar.plugins.java.api.tree.TypeTree;
+import org.sonar.plugins.java.api.tree.VariableTree;
+
+public final class Javadoc {
+  private enum BlockTag {
+    RETURN(Pattern.compile("^@return(\\s++)?(?<descr>.+)?"), false),
+    PARAM(Pattern.compile("^@param\\s++(?<name>\\S*)(\\s++)?(?<descr>.+)?"), true),
+    EXCEPTIONS(Pattern.compile("^(?:@throws|@exception)\\s++(?<name>\\S*)(\\s++)?(?<descr>.+)?"), true);
+
+    private final Pattern pattern;
+    private final boolean patternWithName;
+
+    BlockTag(Pattern pattern, boolean patternWithName) {
+      this.pattern = pattern;
+      this.patternWithName = patternWithName;
+    }
+
+    private Pattern getPattern() {
+      return pattern;
+    }
+
+    private boolean isPatternWithName() {
+      return patternWithName;
+    }
+  }
+
+  private static class BlockTagKey {
+    private final BlockTag tag;
+    private final String name;
+
+    BlockTagKey(BlockTag tag, @Nullable String name) {
+      this.tag = tag;
+      this.name = name;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) {
+        return true;
+      } else if (o instanceof BlockTagKey) {
+        BlockTagKey other = ((BlockTagKey) o);
+        return tag == other.tag && Objects.equals(name, other.name);
+      }
+      return false;
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(tag, name);
+    }
+
+    private static BlockTagKey of(BlockTag tag, @Nullable String name) {
+      return new BlockTagKey(tag, name);
+    }
+  }
+
+  private static final Tree.Kind[] CLASS_KINDS = PublicApiChecker.classKinds();
+  private static final Tree.Kind[] METHOD_KINDS = PublicApiChecker.methodKinds();
+  private static final List<String> GENERIC_EXCEPTIONS = Arrays.asList("Exception", "java.lang.Exception");
+  private static final Pattern BLOCK_TAG_LINE_PATTERN = Pattern.compile("^@\\S+.*");
+  private static final Set<String> PLACEHOLDERS = ImmutableSet.of("TODO", "FIXME", "...", ".");
+
+  private final List<String> elementParameters;
+  private final List<String> elementExceptionNames;
+  private final String mainDescription;
+  private final Map<BlockTagKey, List<String>> blockTagDescriptions;
+  private final EnumMap<BlockTag, List<String>> undocumentedNamedTags;
+  private Map<String, List<String>> javadocExceptions;
+
+  public Javadoc(Tree tree) {
+    if (tree.is(METHOD_KINDS)) {
+      elementParameters = ((MethodTree) tree).parameters().stream()
+        .map(VariableTree::simpleName)
+        .map(IdentifierTree::name)
+        .collect(Collectors.toList());
+      elementExceptionNames = ((MethodTree) tree).throwsClauses().stream()
+        .map(Javadoc::exceptionName)
+        .filter(Objects::nonNull)
+        .collect(Collectors.toList());
+    } else if (tree.is(CLASS_KINDS)) {
+      elementParameters = ((ClassTree) tree).typeParameters().stream()
+        .map(TypeParameterTree::identifier)
+        .map(IdentifierTree::name)
+        .map(name -> "<" + name + ">")
+        .collect(Collectors.toList());
+      elementExceptionNames = Collections.emptyList();
+    } else {
+      elementParameters = Collections.emptyList();
+      elementExceptionNames = Collections.emptyList();
+    }
+
+    List<String> javadocLines = cleanLines(PublicApiChecker.getApiJavadoc(tree));
+    mainDescription = getDescription(javadocLines, -1, "");
+    blockTagDescriptions = extractBlockTags(javadocLines, Arrays.asList(BlockTag.values()));
+    undocumentedNamedTags = new EnumMap<>(BlockTag.class);
+  }
+
+  public boolean noMainDescription() {
+    return isEmptyDescription(mainDescription);
+  }
+
+  public boolean noReturnDescription() {
+    return isEmptyDescription(blockTagDescriptions.get(BlockTagKey.of(BlockTag.RETURN, null)));
+  }
+
+  public List<String> undocumentedParameters() {
+    return undocumentedNamedTags.computeIfAbsent(BlockTag.PARAM, key -> computeUndocumentedParameters());
+  }
+
+  public List<String> undocumentedThrownExceptions() {
+    return undocumentedNamedTags.computeIfAbsent(BlockTag.EXCEPTIONS, key -> computeUndocumentedThrownExceptions());
+  }
+
+  private List<String> computeUndocumentedParameters() {
+    return elementParameters.stream()
+      .filter(name -> isEmptyDescription(blockTagDescriptions.get(BlockTagKey.of(BlockTag.PARAM, name))))
+      .collect(Collectors.toList());
+  }
+
+  private List<String> computeUndocumentedThrownExceptions() {
+    Map<String, List<String>> thrownExceptionsMap = getJavadocExceptions();
+    List<String> exceptionNames = elementExceptionNames;
+    if (exceptionNames.size() == 1 && GENERIC_EXCEPTIONS.contains(toSimpleName(exceptionNames.get(0))) && !thrownExceptionsMap.isEmpty()) {
+      // check for documented exceptions without description when only "Exception" is declared as being thrown
+      return thrownExceptionsMap.entrySet().stream()
+        .filter(e -> isEmptyDescription(e.getValue()))
+        .map(Map.Entry::getKey)
+        .map(Javadoc::toSimpleName)
+        .collect(Collectors.toList());
+    }
+    return exceptionNames.stream()
+      .map(Javadoc::toSimpleName)
+      .filter(simpleName -> noDescriptionForException(thrownExceptionsMap, simpleName))
+      .collect(Collectors.toList());
+  }
+
+  private boolean noDescriptionForException(Map<String, List<String>> thrownExceptionsMap, String exceptionSimpleName) {
+    List<String> descriptions = thrownExceptionsMap.get(exceptionSimpleName);
+    if (descriptions == null) {
+      // exceptions used in javadoc is using fully qualified name when method declaration use simple name
+      descriptions = thrownExceptionsMap.entrySet().stream()
+        .filter(e -> toSimpleName(e.getKey()).equals(exceptionSimpleName))
+        .map(Map.Entry::getValue)
+        .flatMap(List::stream)
+        .collect(Collectors.toList());
+    }
+    return isEmptyDescription(descriptions);
+  }
+
+  private Map<String, List<String>> getJavadocExceptions() {
+    if (javadocExceptions == null) {
+      javadocExceptions = blockTagDescriptions.entrySet().stream()
+        .filter(entry -> entry.getKey().tag == BlockTag.EXCEPTIONS && entry.getKey().name != null)
+        .collect(Collectors.toMap(entry -> entry.getKey().name, Map.Entry::getValue));
+    }
+    return javadocExceptions;
+  }
+
+  private static Map<BlockTagKey, List<String>> extractBlockTags(List<String> javadocLines, List<BlockTag> tags) {
+    Map<BlockTagKey, List<String>> results = new HashMap<>();
+    for (int i = 0; i < javadocLines.size(); i++) {
+      for (int j = 0; j < tags.size(); j++) {
+        BlockTag tag = tags.get(j);
+        Matcher matcher = tag.getPattern().matcher(javadocLines.get(i));
+        if (matcher.matches()) {
+          BlockTagKey key = BlockTagKey.of(tag, tag.isPatternWithName() ? matcher.group("name") : null);
+          List<String> descriptions = results.computeIfAbsent(key, k -> new ArrayList<>());
+          String newDescription = getDescription(javadocLines, i, matcher.group("descr"));
+          if (!newDescription.isEmpty()) {
+            descriptions.add(newDescription);
+            break;
+          }
+        }
+      }
+    }
+    return results;
+  }
+
+  private static String toSimpleName(String exceptionName) {
+    int lastDot = exceptionName.lastIndexOf('.');
+    if (lastDot != -1) {
+      return exceptionName.substring(lastDot + 1);
+    }
+    return exceptionName;
+  }
+
+  private static boolean isEmptyDescription(@Nullable List<String> descriptions) {
+    return descriptions == null || descriptions.isEmpty() || descriptions.stream().anyMatch(Javadoc::isEmptyDescription);
+  }
+
+  private static boolean isEmptyDescription(@Nullable String part) {
+    return part == null || part.trim().isEmpty() || PLACEHOLDERS.contains(part.trim());
+  }
+
+  private static String exceptionName(TypeTree typeTree) {
+    switch (typeTree.kind()) {
+      case IDENTIFIER:
+        return ((IdentifierTree) typeTree).name();
+      case MEMBER_SELECT:
+        return ExpressionsHelper.concatenate((MemberSelectExpressionTree) typeTree);
+      default:
+        throw new IllegalStateException("Exceptions can not be specified other than with an identifier or a fully qualified name.");
+    }
+  }
+
+  private static List<String> cleanLines(@Nullable String javadoc) {
+    if (javadoc == null) {
+      return Collections.emptyList();
+    }
+    String trimmedJavadoc = javadoc.trim();
+    // remove start and end of Javadoc as well as stars
+    String[] lines = trimmedJavadoc
+      .substring(3, trimmedJavadoc.length() - 2)
+      .replaceAll("(?m)^\\s*\\*", "")
+      .trim()
+      .split("\\r?\\n");
+    return Arrays.stream(lines).map(String::trim).collect(Collectors.toList());
+  }
+
+  private static String getDescription(List<String> lines, int lineIndex, @Nullable String currentValue) {
+    StringBuilder sb = new StringBuilder();
+    sb.append(currentValue != null ? currentValue : "");
+    int currentIndex = lineIndex;
+    while (currentIndex + 1 < lines.size() && !BLOCK_TAG_LINE_PATTERN.matcher(lines.get(currentIndex + 1)).matches()) {
+      sb.append(" ");
+      sb.append(lines.get(currentIndex + 1));
+      currentIndex++;
+    }
+    return sb.toString().trim();
+  }
+
+  @VisibleForTesting
+  String getMainDescription() {
+    return mainDescription;
+  }
+
+  @VisibleForTesting
+  Map<BlockTagKey, List<String>> getBlockTagDescriptions() {
+    return blockTagDescriptions;
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/HostnameVerifierImplementationCheck.java b/java-checks/src/main/java/org/sonar/java/checks/security/HostnameVerifierImplementationCheck.java
new file mode 100755
index 0000000000..812013d401
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/HostnameVerifierImplementationCheck.java
@@ -0,0 +1,117 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import com.google.common.collect.ImmutableList;
+import java.util.List;
+import javax.annotation.Nullable;
+import org.sonar.check.Rule;
+import org.sonar.java.matcher.MethodMatcher;
+import org.sonar.java.matcher.TypeCriteria;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
+import org.sonar.plugins.java.api.tree.BlockTree;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
+import org.sonar.plugins.java.api.tree.LiteralTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.ReturnStatementTree;
+import org.sonar.plugins.java.api.tree.StatementTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+@Rule(key = "S3510")
+public class HostnameVerifierImplementationCheck extends IssuableSubscriptionVisitor {
+
+  private static final String ISSUE_MESSAGE = "Do not unconditionally return true in this method.";
+
+  private static final TypeCriteria TYPE_CRITERIA_STRING = TypeCriteria.is("java.lang.String");
+  private static final TypeCriteria TYPE_CRITERIA_SSL_SESSION = TypeCriteria.is("javax.net.ssl.SSLSession");
+  private static final MethodMatcher VERIFY_METHOD_MATCHER = MethodMatcher.create().typeDefinition(TypeCriteria.subtypeOf("javax.net.ssl.HostnameVerifier"))
+    .name("verify")
+    .addParameter(TYPE_CRITERIA_STRING)
+    .addParameter(TYPE_CRITERIA_SSL_SESSION);
+
+  @Override
+  public List<Tree.Kind> nodesToVisit() {
+    return ImmutableList.of(Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION);
+  }
+
+  @Override
+  public void visitNode(Tree tree) {
+    if (!hasSemantic()) {
+      return;
+    }
+
+    if (tree.kind().equals(Tree.Kind.METHOD)) {
+      checkMethodDefinition((MethodTree) tree);
+    } else if (tree.kind().equals(Tree.Kind.LAMBDA_EXPRESSION)) {
+      checkLambdaDefinition(((LambdaExpressionTree) tree));
+    }
+  }
+
+  private void checkMethodDefinition(MethodTree tree) {
+    BlockTree blockTree = tree.block();
+    if (VERIFY_METHOD_MATCHER.matches(tree) && blockTree != null) {
+      checkBlock(blockTree);
+    }
+  }
+
+  private void checkLambdaDefinition(LambdaExpressionTree lambdaExpression) {
+    Tree lambdaBody = lambdaExpression.body();
+    if (isHostnameVerifierSignature(lambdaExpression)) {
+      if (lambdaBody.is(Tree.Kind.BLOCK)) {
+        checkBlock((BlockTree) lambdaBody);
+      } else if (isTrueLiteral(lambdaBody)) {
+        reportIssue(lambdaBody, ISSUE_MESSAGE);
+      }
+    }
+  }
+
+  private void checkBlock(BlockTree blockTree) {
+    BlockTree innerBlock = blockTree;
+    while (innerBlock.body().size() == 1 && innerBlock.body().get(0).is(Tree.Kind.BLOCK)) {
+      innerBlock = (BlockTree) innerBlock.body().get(0);
+    }
+
+    if (isReturnTrueStatement(innerBlock.body())) {
+      reportIssue(innerBlock.body().get(0), ISSUE_MESSAGE);
+    }
+  }
+
+  private static boolean isHostnameVerifierSignature(LambdaExpressionTree lambdaExpressionTree) {
+    return lambdaExpressionTree.symbolType().isSubtypeOf("javax.net.ssl.HostnameVerifier");
+  }
+
+  private static boolean isReturnTrueStatement(List<StatementTree> statementTreeList) {
+    if (statementTreeList.size() == 1 && statementTreeList.get(0).is(Tree.Kind.RETURN_STATEMENT)) {
+      ExpressionTree expression = ((ReturnStatementTree) statementTreeList.get(0)).expression();
+      return isTrueLiteral(expression);
+    }
+    return false;
+  }
+
+  private static boolean isTrueLiteral(@Nullable Tree tree) {
+    if (tree != null && (tree.is(Tree.Kind.PARENTHESIZED_EXPRESSION) || tree.is(Tree.Kind.BOOLEAN_LITERAL))) {
+      ExpressionTree expression = ExpressionUtils.skipParentheses((ExpressionTree) tree);
+      return expression.is(Tree.Kind.BOOLEAN_LITERAL) && "true".equals(((LiteralTree) expression).value());
+    }
+    return false;
+  }
+}
diff --git a/java-checks/src/main/java/org/sonar/java/checks/security/package-info.java b/java-checks/src/main/java/org/sonar/java/checks/security/package-info.java
new file mode 100755
index 0000000000..40b86f50ae
--- /dev/null
+++ b/java-checks/src/main/java/org/sonar/java/checks/security/package-info.java
@@ -0,0 +1,23 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+@ParametersAreNonnullByDefault
+package org.sonar.java.checks.security;
+
+import javax.annotation.ParametersAreNonnullByDefault;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedMethodParameterCheck.java b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedMethodParameterCheck.java
index 9b2937ae88..37cf18d6e3 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedMethodParameterCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedMethodParameterCheck.java
@@ -22,23 +22,21 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
 import java.util.stream.Collectors;
 import org.sonar.check.Rule;
+import org.sonar.java.checks.helpers.Javadoc;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.MethodMatcherCollection;
 import org.sonar.java.model.ModifiersUtils;
 import org.sonar.java.model.declaration.MethodTreeImpl;
+import org.sonar.java.resolve.JavaSymbol;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.semantic.Symbol;
-import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
 import org.sonar.plugins.java.api.semantic.Type;
 import org.sonar.plugins.java.api.tree.AnnotationTree;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
@@ -52,7 +50,6 @@
 import org.sonar.plugins.java.api.tree.Modifier;
 import org.sonar.plugins.java.api.tree.ModifiersTree;
 import org.sonar.plugins.java.api.tree.NewArrayTree;
-import org.sonar.plugins.java.api.tree.SyntaxTrivia;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
@@ -66,9 +63,8 @@
     MethodMatcher.create().name("writeObject").addParameter("java.io.ObjectOutputStream"),
     MethodMatcher.create().name("readObject").addParameter("java.io.ObjectInputStream"));
   private static final String STRUTS_ACTION_SUPERCLASS = "org.apache.struts.action.Action";
-  private static final Collection<String> EXCLUDED_STRUTS_ACTION_PARAMETER_TYPES = ImmutableList.of("org.apache.struts.action.ActionMapping", 
+  private static final Collection<String> EXCLUDED_STRUTS_ACTION_PARAMETER_TYPES = ImmutableList.of("org.apache.struts.action.ActionMapping",
     "org.apache.struts.action.ActionForm", "javax.servlet.http.HttpServletRequest", "javax.servlet.http.HttpServletResponse");
-  private static final Pattern PARAMETER_JAVADOC_PATTERN = Pattern.compile(".*@param\\s++(?<name>\\S*)(\\s++)?(?<descr>.+)?");
 
   @Override
   public List<Tree.Kind> nodesToVisit() {
@@ -81,18 +77,18 @@ public void visitNode(Tree tree) {
       return;
     }
     MethodTree methodTree = (MethodTree) tree;
-    if (methodTree.block() == null || isExcluded(methodTree)) {
+    if (methodTree.block() == null || methodTree.parameters().isEmpty() || isExcluded(methodTree)) {
       return;
     }
-    Set<String> documentedParameters = documentedParameters(methodTree);
-    boolean overridableMethod = overridableMethod(methodTree.symbol());
+    List<String> undocumentedParameters = new Javadoc(methodTree).undocumentedParameters();
+    boolean overridableMethod = ((JavaSymbol.MethodJavaSymbol) methodTree.symbol()).isOverridable();
     List<IdentifierTree> unused = Lists.newArrayList();
     for (VariableTree var : methodTree.parameters()) {
       Symbol symbol = var.symbol();
       if (symbol.usages().isEmpty()
         && !symbol.metadata().isAnnotatedWith(AUTHORIZED_ANNOTATION)
         && !isStrutsActionParameter(var)
-        && (!overridableMethod || !documentedParameters.contains(symbol.name()))) {
+        && (!overridableMethod || undocumentedParameters.contains(symbol.name()))) {
         unused.add(var.simpleName());
       }
     }
@@ -121,21 +117,6 @@ private void reportUnusedParameters(List<IdentifierTree> unused) {
     reportIssue(firstUnused, msg, locations, null);
   }
 
-  private static boolean overridableMethod(MethodSymbol symbol) {
-    return !(symbol.isPrivate() || symbol.isStatic() || symbol.isFinal() || symbol.owner().isFinal());
-  }
-
-  private static Set<String> documentedParameters(MethodTree methodTree) {
-    return methodTree.firstToken().trivias().stream()
-      .map(SyntaxTrivia::comment)
-      .map(c -> c.split("\\r?\\n"))
-      .flatMap(Arrays::stream)
-      .map(PARAMETER_JAVADOC_PATTERN::matcher)
-      .filter(Matcher::matches)
-      .map(matcher -> matcher.group("name"))
-      .collect(Collectors.toSet());
-  }
-
   private static boolean isExcluded(MethodTree tree) {
     return ((MethodTreeImpl) tree).isMainMethod()
       || isAnnotated(tree)
diff --git a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateFieldCheck.java b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateFieldCheck.java
index ccf26f177a..547040021b 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateFieldCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateFieldCheck.java
@@ -23,9 +23,10 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ListMultimap;
 import com.google.common.collect.Lists;
-
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.model.ModifiersUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
@@ -45,10 +46,6 @@
 import org.sonar.plugins.java.api.tree.Tree.Kind;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
 @Rule(key = "S1068")
 public class UnusedPrivateFieldCheck extends IssuableSubscriptionVisitor {
 
@@ -126,7 +123,7 @@ private static boolean isMethodIdentifier(IdentifierTree identifier) {
       return false;
     }
     if (parent.is(Tree.Kind.METHOD_INVOCATION)) {
-      return identifier.equals(MethodsHelper.methodName((MethodInvocationTree) parent));
+      return identifier.equals(ExpressionUtils.methodName((MethodInvocationTree) parent));
     } else {
       return identifier.equals(((MethodReferenceTree) parent).method());
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateMethodCheck.java b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateMethodCheck.java
index 837c9a1497..c8e057631c 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateMethodCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedPrivateMethodCheck.java
@@ -20,11 +20,14 @@
 package org.sonar.java.checks.unused;
 
 import com.google.common.collect.ImmutableList;
-
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import org.sonar.check.Rule;
 import org.sonar.java.RspecKey;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.checks.serialization.SerializableContract;
+import org.sonar.java.model.ExpressionUtils;
 import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.semantic.Symbol;
@@ -38,11 +41,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TypeTree;
 
-import java.util.ArrayList;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
-
 @Rule(key = "UnusedPrivateMethod")
 @RspecKey("S1144")
 public class UnusedPrivateMethodCheck extends IssuableSubscriptionVisitor {
@@ -102,7 +100,7 @@ public void visitNode(Tree tree) {
 
   private void checkIfUnknown(MethodInvocationTree mit) {
     if (mit.symbol().isUnknown()) {
-      unresolvedMethodNames.add(MethodsHelper.methodName(mit).name());
+      unresolvedMethodNames.add(ExpressionUtils.methodName(mit).name());
     }
   }
 
diff --git a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedReturnedDataCheck.java b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedReturnedDataCheck.java
index 90a47eff89..04b0ac2568 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedReturnedDataCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/unused/UnusedReturnedDataCheck.java
@@ -20,8 +20,10 @@
 package org.sonar.java.checks.unused;
 
 import com.google.common.collect.ImmutableList;
+import java.util.List;
+import java.util.Objects;
+import javax.annotation.CheckForNull;
 import org.sonar.check.Rule;
-import org.sonar.java.checks.helpers.MethodsHelper;
 import org.sonar.java.matcher.MethodMatcher;
 import org.sonar.java.matcher.TypeCriteria;
 import org.sonar.java.model.ExpressionUtils;
@@ -33,11 +35,6 @@
 import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import javax.annotation.CheckForNull;
-
-import java.util.List;
-import java.util.Objects;
-
 @Rule(key = "S2677")
 public class UnusedReturnedDataCheck extends IssuableSubscriptionVisitor {
 
@@ -62,7 +59,7 @@ public void visitNode(Tree tree) {
       CHECKED_METHODS.stream()
         .map(matcher -> isTreeMethodInvocation(((ExpressionStatementTree) tree).expression(), matcher))
         .filter(Objects::nonNull)
-        .forEach(mit -> raiseIssue(MethodsHelper.methodName(mit)));
+        .forEach(mit -> raiseIssue(ExpressionUtils.methodName(mit)));
     } else {
       BinaryExpressionTree expressionTree = (BinaryExpressionTree) tree;
       ExpressionTree leftOperand = expressionTree.leftOperand();
@@ -70,11 +67,11 @@ public void visitNode(Tree tree) {
       for (MethodMatcher matcher : CHECKED_METHODS) {
         MethodInvocationTree leftMit = isTreeMethodInvocation(leftOperand, matcher);
         if (leftMit != null && isTreeLiteralNull(rightOperand)) {
-          raiseIssue(MethodsHelper.methodName(leftMit));
+          raiseIssue(ExpressionUtils.methodName(leftMit));
         }
         MethodInvocationTree rightMit = isTreeMethodInvocation(rightOperand, matcher);
         if (rightMit != null && isTreeLiteralNull(leftOperand)) {
-          raiseIssue(MethodsHelper.methodName(rightMit));
+          raiseIssue(ExpressionUtils.methodName(rightMit));
         }
       }
     }
diff --git a/java-checks/src/main/java/org/sonar/java/checks/xml/maven/DisallowedDependenciesCheck.java b/java-checks/src/main/java/org/sonar/java/checks/xml/maven/DisallowedDependenciesCheck.java
index 40068c25b7..7dd83cf208 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/xml/maven/DisallowedDependenciesCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/xml/maven/DisallowedDependenciesCheck.java
@@ -26,10 +26,8 @@
 import org.sonar.java.xml.maven.PomCheck;
 import org.sonar.java.xml.maven.PomCheckContext;
 import org.sonar.maven.model.maven2.Dependency;
-import org.sonar.squidbridge.annotations.RuleTemplate;
 
 @Rule(key = DisallowedDependenciesCheck.KEY)
-@RuleTemplate
 public class DisallowedDependenciesCheck implements PomCheck {
 
   public static final String KEY = "S3417";
diff --git a/java-checks/src/main/java/org/sonar/java/checks/xml/maven/PomElementOrderCheck.java b/java-checks/src/main/java/org/sonar/java/checks/xml/maven/PomElementOrderCheck.java
index a63b3726d0..1edaccb859 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/xml/maven/PomElementOrderCheck.java
+++ b/java-checks/src/main/java/org/sonar/java/checks/xml/maven/PomElementOrderCheck.java
@@ -19,6 +19,13 @@
  */
 package org.sonar.java.checks.xml.maven;
 
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Collectors;
 import org.sonar.check.Rule;
 import org.sonar.java.xml.maven.PomCheck;
 import org.sonar.java.xml.maven.PomCheckContext;
@@ -26,15 +33,10 @@
 import org.sonar.maven.model.LocatedTree;
 import org.sonar.maven.model.maven2.MavenProject;
 
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.LinkedList;
-import java.util.List;
-
 @Rule(key = "S3423")
 public class PomElementOrderCheck implements PomCheck {
 
-  private static final Comparator<LocatedTree> LINE_COMPARATOR = new LineComparator();
+  private static final Comparator<LocatedTree> LINE_COMPARATOR = (l1, l2) -> Integer.compare(l1.startLocation().line(), l2.startLocation().line());
 
   @Override
   public void scanFile(PomCheckContext context) {
@@ -77,41 +79,31 @@ public void scanFile(PomCheckContext context) {
   }
 
   private static List<Location> checkPositions(LocatedTree... trees) {
-    List<Location> issues = new LinkedList<>();
-    List<LocatedTree> expectedOrder = getNonNullTrees(trees);
-    List<LocatedTree> observedOrder = sortByLine(expectedOrder);
+    List<LocatedTree> expectedOrder = Arrays.stream(trees).filter(Objects::nonNull).collect(Collectors.toList());
+    List<LocatedTree> observedOrder = expectedOrder.stream().sorted(LINE_COMPARATOR).collect(Collectors.toList());
+
+    int lastWrongPosition = -1;
+    int firstWrongPosition = -1;
 
     for (int index = 0; index < expectedOrder.size(); index++) {
-      LocatedTree expected = expectedOrder.get(index);
-      int indexObserved = observedOrder.indexOf(expected);
-      if (!issues.isEmpty() || index != indexObserved) {
-        issues.add(new Location("Expected position: " + (index + 1), expected.startLocation().line()));
+      if (observedOrder.indexOf(expectedOrder.get(index)) != index) {
+        lastWrongPosition = index;
+        if (firstWrongPosition == -1) {
+          firstWrongPosition = index;
+        }
       }
     }
 
-    return issues;
-  }
-
-  private static List<LocatedTree> getNonNullTrees(LocatedTree... trees) {
-    List<LocatedTree> result = new LinkedList<>();
-    for (LocatedTree locatedTree : trees) {
-      if (locatedTree != null) {
-        result.add(locatedTree);
-      }
+    if (lastWrongPosition == -1) {
+      return Collections.emptyList();
     }
-    return result;
-  }
 
-  private static List<LocatedTree> sortByLine(List<LocatedTree> expectedOrder) {
-    List<LocatedTree> result = new LinkedList<>(expectedOrder);
-    Collections.sort(result, LINE_COMPARATOR);
-    return result;
-  }
-
-  private static class LineComparator implements Comparator<LocatedTree> {
-    @Override
-    public int compare(LocatedTree o1, LocatedTree o2) {
-      return Integer.compare(o1.startLocation().line(), o2.startLocation().line());
+    List<Location> issues = new ArrayList<>();
+    // only reports between first and last wrong position
+    for (int index = firstWrongPosition; index <= lastWrongPosition; index++) {
+      issues.add(new Location("Expected position: " + (index + 1), expectedOrder.get(index).startLocation().line()));
     }
+
+    return issues;
   }
 }
diff --git a/java-checks/src/main/java/org/sonar/java/filters/PostAnalysisIssueFilter.java b/java-checks/src/main/java/org/sonar/java/filters/PostAnalysisIssueFilter.java
index 91a708b5d0..3722a727c1 100755
--- a/java-checks/src/main/java/org/sonar/java/filters/PostAnalysisIssueFilter.java
+++ b/java-checks/src/main/java/org/sonar/java/filters/PostAnalysisIssueFilter.java
@@ -21,16 +21,15 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
-
 import org.sonar.api.batch.fs.FileSystem;
 import org.sonar.api.batch.fs.InputFile;
 import org.sonar.api.scan.issue.filter.FilterableIssue;
 import org.sonar.api.scan.issue.filter.IssueFilterChain;
+import org.sonar.java.AnalysisException;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
-import org.sonar.squidbridge.api.AnalysisException;
 
-public class PostAnalysisIssueFilter implements JavaFileScanner, CodeVisitorIssueFilter {
+public class PostAnalysisIssueFilter implements JavaFileScanner, SonarJavaIssueFilter {
 
   private static final Iterable<JavaIssueFilter> DEFAULT_ISSUE_FILTERS = ImmutableList.<JavaIssueFilter>of(
     new EclipseI18NFilter(),
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1068_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1068_java.json
index ade594207b..e47aeb2f50 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1068_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1068_java.json
@@ -7,7 +7,6 @@
     "constantCost": "5min"
   },
   "tags": [
-    "cert",
     "unused"
   ],
   "defaultSeverity": "Major",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1116_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1116_java.html
index b8f160f96e..e47d4cf7a3 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1116_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1116_java.html
@@ -12,8 +12,6 @@ <h2>Noncompliant Code Example</h2>
 void doSomethingElse() {
   System.out.println("Hello, world!");;                     // Noncompliant - double ;
   ...
-  for (int i = 0; i &lt; 3; System.out.println(i), i++);       // Noncompliant - Rarely, they are used on purpose as the body of a loop. It is a bad practice to have side-effects outside of the loop body
-  ...
 }
 </pre>
 <h2>Compliant Solution</h2>
@@ -23,9 +21,7 @@ <h2>Compliant Solution</h2>
 void doSomethingElse() {
   System.out.println("Hello, world!");
   ...
-  for (int i = 0; i &lt; 3; i++){
-    System.out.println(i);
-  }
+  for (int i = 0; i &lt; 3; i++) ; // compliant if unique statement of a loop
   ...
 }
 </pre>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1121_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1121_java.html
index dc16bc731e..086dff5d29 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1121_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1121_java.html
@@ -33,7 +33,5 @@ <h2>See</h2>
   <li> <a href="https://www.securecoding.cert.org/confluence/x/nYFtAg">CERT, EXP45-C.</a> - Do not perform assignments in selection statements </li>
   <li> <a href="https://www.securecoding.cert.org/confluence/x/1gCTAw">CERT, EXP51-J.</a> - Do not perform assignments in conditional expressions
   </li>
-  <li> <a href="https://www.securecoding.cert.org/confluence/x/KQvhAg">CERT, EXP19-CPP.</a> - Do not perform assignments in conditional expressions
-  </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1130_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1130_java.html
index b40e42df69..cc07266168 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1130_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1130_java.html
@@ -17,4 +17,38 @@ <h2>Compliant Solution</h2>
 void bar() throws Throwable {}
 void baz() {}
 </pre>
+<h2>Exceptions</h2>
+<p>The rule will not raise any issue for exceptions that cannot be thrown from the method body:</p>
+<ul>
+  <li> in overriding and implementation methods </li>
+  <li> in interface <code>default</code> methods </li>
+  <li> in non-private methods that only <code>throw</code>, have empty bodies, or a single return statement . </li>
+  <li> in overridable methods (non-final, or not member of a final class, non-static, non-private), if the exception is documented with a proper
+  javadoc. </li>
+</ul>
+<pre>
+class A extends B {
+  @Override
+  void doSomething() throws IOException {
+    compute(a);
+  }
+
+  public void foo() throws IOException {}
+
+  protected void bar() throws IOException {
+    throw new UnsupportedOperationException("This method should be implemented in subclasses");
+  }
+
+  Object foobar(String s) throws IOException {
+    return null;
+  }
+
+  /**
+   * @throws IOException Overriding classes may throw this exception if they print values into a file
+   */
+  protected void print() throws IOException { // no issue, method is overridable and the exception has proper javadoc
+    System.out.println("foo");
+  }
+}
+</pre>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1144_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1144_java.json
index 4984ae115b..a800328d28 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1144_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1144_java.json
@@ -7,7 +7,6 @@
     "constantCost": "5min"
   },
   "tags": [
-    "cert",
     "unused"
   ],
   "defaultSeverity": "Major",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S126_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S126_java.html
new file mode 100755
index 0000000000..6ebae33158
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S126_java.html
@@ -0,0 +1,32 @@
+<p>This rule applies whenever an <code>if</code> statement is followed by one or more <code>else if</code> statements; the final <code>else if</code>
+should be followed by an <code>else</code> statement.</p>
+<p>The requirement for a final <code>else</code> statement is defensive programming.</p>
+<p>The <code>else</code> statement should either take appropriate action or contain a suitable comment as to why no action is taken. This is
+consistent with the requirement to have a final <code>default</code> clause in a <code>switch</code> statement.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+if (x == 0) {
+  doSomething();
+} else if (x == 1) {
+  doSomethingElse();
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+if (x == 0) {
+  doSomething();
+} else if (x == 1) {
+  doSomethingElse();
+} else {
+  throw new IllegalStateException();
+}
+</pre>
+<h2>See</h2>
+<ul>
+  <li> MISRA C:2004, 14.10 - All if...else if constructs shall be terminated with an else clause. </li>
+  <li> MISRA C++:2008, 6-4-2 - All if...else if constructs shall be terminated with an else clause. </li>
+  <li> MISRA C:2012, 15.7 - All if...else if constructs shall be terminated with an else statement </li>
+  <li> <a href="https://www.securecoding.cert.org/confluence/x/YgE">CERT, MSC01-C.</a> - Strive for logical completeness </li>
+  <li> <a href="https://www.securecoding.cert.org/confluence/x/PQHRAw">CERT, MSC57-J.</a> - Strive for logical completeness </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S126_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S126_java.json
new file mode 100755
index 0000000000..440df7a595
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S126_java.json
@@ -0,0 +1,19 @@
+{
+  "title": "\"if ... else if\" constructs should end with \"else\" clauses",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "misra",
+    "cert"
+  ],
+  "standards": [
+    "CERT"
+  ],
+  "defaultSeverity": "Critical",
+  "ruleSpecification": "RSPEC-126",
+  "sqKey": "S126"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.html
index 35c5f5ec88..8be83efd3c 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.html
@@ -1,39 +1,37 @@
-<p>Having an unconditional <code>break</code>, <code>return</code> or <code>throw</code> in a loop renders it useless; the loop will only execute once
-and the loop structure itself is simply wasted keystrokes.</p>
-<p>Having an unconditional <code>continue</code> in a loop is itself wasted keystrokes.</p>
-<p>For these reasons, unconditional jump statements should never be used except for the final <code>return</code> in a function or method.</p>
+<p>A loop with at most one iteration is equivalent to the use of an <code>if</code> statement to conditionally execute one piece of code. No developer
+expects to find such a use of a loop statement. If the initial intention of the author was really to conditionally execute one piece of code, an
+<code>if</code> statement should be used instead.</p>
+<p> </p>
+<p>At worst that was not the initial intention of the author and so the body of the loop should be fixed to use the nested <code>return</code>,
+<code>break</code> or <code>throw</code> statements in a more appropriate way.</p>
 <h2>Noncompliant Code Example</h2>
 <pre>
-int i;
-for (i = 0; i &lt; 10; ++i) {
-  System.out.println("i is " + i);
-  break;  // loop only executes once
+for (int i = 0; i &lt; 10; i++) { // noncompliant, loop only executes once
+  printf("i is %d", i);
+  break;
 }
-
-for (i = 0; i &lt; 10; ++i) {
-  System.out.println("i is " + i);
-  continue;  // this is meaningless; the loop would continue anyway
-}
-
-for (i = 0; i &lt; 10; ++i) {
-  System.out.println("i is " + i);
-  return;  // loop only executes once
+...
+for (int i = 0; i &lt; 10; i++) { // noncompliant, loop only executes once
+  if(i == x) {
+    break;
+  } else {
+    printf("i is %d", i);
+    return;
+  }
 }
 </pre>
 <h2>Compliant Solution</h2>
 <pre>
-int i;
-for (i = 0; i &lt; 10; ++i) {
-  System.out.println("i is " + i);
+for (int i = 0; i &lt; 10; i++) {
+  printf("i is %d", i);
+}
+...
+for (int i = 0; i &lt; 10; i++) {
+  if(i == x) {
+    break;
+  } else {
+    printf("i is %d", i);
+  }
 }
 </pre>
-<h2>See</h2>
-<ul>
-  <li> MISRA C:2004, 14.1 - There shall be no unreachable code. </li>
-  <li> MISRA C++:2008, 0-1-1 - A <em>project</em> shall not contain <em>unreachable code</em>. </li>
-  <li> MISRA C++:2008, 0-1-9 - There shall be no dead code. </li>
-  <li> MISRA C:2012, 2.2 - There shall be no dead code </li>
-  <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
-  executed </li>
-</ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.json
index 220180d5c3..86c9730e30 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1751_java.json
@@ -1,15 +1,13 @@
 {
-  "title": "Jump statements should not be used unconditionally",
-  "type": "CODE_SMELL",
+  "title": "Loops with at most one iteration should be refactored",
+  "type": "BUG",
   "status": "ready",
   "remediation": {
     "func": "Constant\/Issue",
     "constantCost": "5min"
   },
   "tags": [
-    "misra",
-    "cert",
-    "unused"
+    
   ],
   "defaultSeverity": "Major",
   "ruleSpecification": "RSPEC-1751",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1821_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1821_java.html
new file mode 100755
index 0000000000..57c0be8e94
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1821_java.html
@@ -0,0 +1,39 @@
+<p>Nested <code>switch</code> structures are difficult to understand because you can easily confuse the cases of an inner <code>switch</code> as
+belonging to an outer statement. Therefore nested <code>switch</code> statements should be avoided.</p>
+<p>Specifically, you should structure your code to avoid the need for nested <code>switch</code> statements, but if you cannot, then consider moving
+the inner <code>switch</code> to another function.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+void foo(int n, int m) {
+  switch (n) {
+    case 0:
+      switch (m) {  // Noncompliant; nested switch
+        // ...
+      }
+    case 1:
+      // ...
+    default:
+      // ...
+  }
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+void foo(int n, int m) {
+  switch (n) {
+    case 0:
+      bar(m);
+    case 1:
+      // ...
+    default:
+      // ...
+  }
+}
+
+void bar(int m){
+  switch(m) {
+    // ...
+  }
+}
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1821_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1821_java.json
new file mode 100755
index 0000000000..feb639a152
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1821_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "\"switch\" statements should not be nested",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "10min"
+  },
+  "tags": [
+    "pitfall"
+  ],
+  "defaultSeverity": "Critical",
+  "ruleSpecification": "RSPEC-1821",
+  "sqKey": "S1821"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1854_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1854_java.html
index 9e611a0236..4dc130443d 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1854_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1854_java.html
@@ -1,36 +1,18 @@
-<p>A dead store happens when a local variable is assigned a value, including <code>null</code>, that is not read by any subsequent instruction.
-Calculating or retrieving a value only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error,
-it is at best a waste of resources. </p>
-<p>Even assigning <code>null</code> to a variable is a dead store if the variable is not subsequently used. Assigning null as a hint to the garbage
-collector used to be common practice, but is no longer needed and such code should be eliminated.</p>
+<p>A dead store happens when a local variable is assigned a value that is not read by any subsequent instruction. Calculating or retrieving a value
+only to then overwrite it or throw it away, could indicate a serious error in the code. Even if it's not an error, it is at best a waste of resources.
+Therefore all calculated values should be used.</p>
 <h2>Noncompliant Code Example</h2>
 <pre>
-public void pow(int a, int b) {
-  if(b == 0) {
-    return 0;
-  }
-  int x = a;
-  for(int i= 1, i &lt; b, i++) {
-    x = x * a;  //Dead store because the last return statement should return x instead of returning a
-  }
-  return a;
-}
+i = a + b; // Noncompliant; calculation result not used before value is overwritten
+i = compute();
 </pre>
 <h2>Compliant Solution</h2>
 <pre>
-public void pow(int a, int b) {
-  if(b == 0) {
-    return 0;
-  }
-  int x = a;
-  for(int i= 1, i &lt; b, i++) {
-    x = x * a;
-  }
-  return x;
-}
+i = a + b;
+i += compute();
 </pre>
 <h2>Exceptions</h2>
-<p>This rule ignores initializations to -1, 0, 1, <code>null</code>, empty string (<code>""</code>), <code>true</code>, and <code>false</code>.</p>
+<p>This rule ignores initializations to -1, 0, 1, <code>null</code>, <code>true</code>, <code>false</code> and <code>""</code>.</p>
 <h2>See</h2>
 <ul>
   <li> <a href="http://cwe.mitre.org/data/definitions/563.html">MITRE, CWE-563</a> - Assignment to Variable without Use ('Unused Variable') </li>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1871_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1871_java.html
index 03cab3bd8e..e2d394e074 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1871_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1871_java.html
@@ -34,66 +34,26 @@ <h2>Noncompliant Code Example</h2>
   doTheRest();
 }
 </pre>
-<h2>Compliant Solution</h2>
+<h2>Exceptions</h2>
+<p>Blocks in an <code>if</code> chain that contain a single line of code are ignored, as are blocks in a <code>switch</code> statement that contain a
+single line of code with or without a following <code>break</code>.</p>
 <pre>
-switch (i) {
-  case 1:
-  case 3:
-    doFirstThing();
-    doSomething();
-    break;
-  case 2:
-    doSomethingDifferent();
-    break;
-  default:
-    doTheRest();
-}
-
-if ((a &gt;= 0 &amp;&amp; a &lt; 10) || (a &gt;= 20 &amp;&amp; a &lt; 50)) {
-  doFirstThing();
-  doTheThing();
-}
-else if (a &gt;= 10 &amp;&amp; a &lt; 20) {
-  doTheOtherThing();
-}
-else {
-  doTheRest();
+if(a == 1) {
+  doSomething();  //no issue, usually this is done on purpose to increase the readability
+} else if (a == 2) {
+  doSomethingElse();
+} else {
+  doSomething();
 }
 </pre>
-<p>or </p>
+<p>But this exception does not apply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without default clauses when
+all branches have the same single line of code. In case of <code>if</code> chains with <code>else</code>-s, or of <code>switch</code>-es with default
+clauses, rule {rule:squid:S3923} raises a bug. </p>
 <pre>
-switch (i) {
-  case 1:
-    doFirstThing();
-    doSomething();
-    break;
-  case 2:
-    doSomethingDifferent();
-    break;
-  case 3:
-    doFirstThing();
-    doThirdThing();
-    break;
-  default:
-    doTheRest();
-}
-
-if (a &gt;= 0 &amp;&amp; a &lt; 10) {
-  doFirstThing();
-  doTheThing();
-}
-else if (a &gt;= 10 &amp;&amp; a &lt; 20) {
-  doTheOtherThing();
-}
-else if (a &gt;= 20 &amp;&amp; a &lt; 50) {
-  doFirstThing();
-  doTheThirdThing();
-}
-else {
-  doTheRest();
+if(a == 1) {
+  doSomething();  //Noncompliant, this might have been done on purpose but probably not
+} else if (a == 2) {
+  doSomething();
 }
 </pre>
-<h2>Exceptions</h2>
-<p>Blocks in an <code>if</code> chain that contain a single line of code are ignored, as are blocks in a <code>switch</code> statement that contain a
-single line of code with or without a following <code>break</code>.</p>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1989_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1989_java.json
index a798e44f2d..f5a9742e8b 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1989_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S1989_java.json
@@ -10,7 +10,7 @@
     "cwe",
     "error-handling",
     "cert",
-    "owasp-a6"
+    "owasp-a3"
   ],
   "standards": [
     "CWE",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2070_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2070_java.html
index 2d32653f7a..36c7b4d35f 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2070_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2070_java.html
@@ -25,8 +25,7 @@ <h2>See</h2>
 <ul>
   <li> <a href="http://cwe.mitre.org/data/definitions/328">MITRE, CWE-328</a> - Reversible One-Way Hash </li>
   <li> <a href="http://cwe.mitre.org/data/definitions/327">MITRE, CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
-  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
+  <li> OWASP Top 10 2017 Category A6 - Security Misconfiguration </li>
   <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Porous Defenses </li>
-  <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#WEAK_MESSAGE_DIGEST">MessageDigest Is Weak</a> </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2076_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2076_java.html
index acff3f5423..ae2d8813c6 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2076_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2076_java.html
@@ -27,7 +27,5 @@ <h2>See</h2>
   <li> <a href="http://cwe.mitre.org/data/definitions/88">MITRE, CWE-88</a> - Argument Injection or Modification </li>
   <li> OWASP Top 10 2017 Category A1 - Injection </li>
   <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Insecure Interaction Between Components </li>
-  <li> Derived from the FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#COMMAND_INJECTION">Potential Command Injection</a>
-  </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2092_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2092_java.json
index 76458f869a..137a8a997f 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2092_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2092_java.json
@@ -8,8 +8,8 @@
   },
   "tags": [
     "cwe",
-    "owasp-a6",
-    "owasp-a2"
+    "owasp-a2",
+    "owasp-a3"
   ],
   "standards": [
     "CWE",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.html
index 5395fee785..236ec3bb5e 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.html
@@ -1,5 +1,6 @@
-<p>Constructors for <code>Strings</code> and the objects used to wrap primitives should never be used. Doing so is less clear and uses more memory
-than simply using the desired value in the case of strings, and using <code>valueOf</code> for everything else.</p>
+<p>Constructors for <code>Strings</code>, <code>BigInteger</code>, <code>BigDecimal</code> and the objects used to wrap primitives should never be
+used. Doing so is less clear and uses more memory than simply using the desired value in the case of strings, and using <code>valueOf</code> for
+everything else.</p>
 <p>Further, these constructors are deprecated in Java 9, which is an indication that they will eventually be removed from the language altogether.</p>
 <h2>Noncompliant Code Example</h2>
 <pre>
@@ -8,6 +9,8 @@ <h2>Noncompliant Code Example</h2>
 Double myDouble = new Double(1.1); // Noncompliant; use valueOf
 Integer integer = new Integer(1); // Noncompliant
 Boolean bool = new Boolean(true); // Noncompliant
+BigInteger bigInteger = new BigInteger("1"); // Noncompliant
+BigDecimal bigDecimal = new BigDecimal(1.1); // Noncompliant
 </pre>
 <h2>Compliant Solution</h2>
 <pre>
@@ -16,5 +19,7 @@ <h2>Compliant Solution</h2>
 Double myDouble = Double.valueOf(1.1);
 Integer integer = Integer.valueOf(1);
 Boolean bool = Boolean.valueOf(true);
+BigInteger bigInteger = BigInteger.valueOf(1);
+BigDecimal bigDecimal = BigDecimal.valueOf(1.1);
 </pre>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.json
index b85fee2974..22e9deeb90 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2129_java.json
@@ -1,5 +1,5 @@
 {
-  "title": "Constructors should not be used to instantiate \"String\" and primitive-wrapper classes",
+  "title": "Constructors should not be used to instantiate \"String\", \"BigInteger\", \"BigDecimal\" and primitive-wrapper classes",
   "type": "CODE_SMELL",
   "status": "ready",
   "remediation": {
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2183_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2183_java.json
index 0d56bcc7f1..3f2df159e7 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2183_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2183_java.json
@@ -7,7 +7,7 @@
     "constantCost": "5min"
   },
   "tags": [
-    "cert"
+    
   ],
   "defaultSeverity": "Minor",
   "ruleSpecification": "RSPEC-2183",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2211_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2211_java.html
index bdd7bccda2..756a4198b6 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2211_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2211_java.html
@@ -16,4 +16,10 @@ <h2>Compliant Solution</h2>
     }
 );
 </pre>
+<h2>Exceptions</h2>
+<p>When the lambda has one or two parameters and does not have a block this rule will not fire up an issue as things are considered more readable in
+those cases.</p>
+<pre>
+stream.map((a, b) -&gt; a.length); // compliant
+</pre>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2234_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2234_java.html
new file mode 100755
index 0000000000..37874494f5
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2234_java.html
@@ -0,0 +1,32 @@
+<p>When the names of parameters in a method call match the names of the method arguments, it contributes to clearer, more readable code. However, when
+the names match, but are passed in a different order than the method arguments, it indicates a mistake in the parameter order which will likely lead
+to unexpected results.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+public double divide(int divisor, int dividend) {
+  return divisor/dividend;
+}
+
+public void doTheThing() {
+  int divisor = 15;
+  int dividend = 5;
+
+  double result = divide(dividend, divisor);  // Noncompliant; operation succeeds, but result is unexpected
+  //...
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+public double divide(int divisor, int dividend) {
+  return divisor/dividend;
+}
+
+public void doTheThing() {
+  int divisor = 15;
+  int dividend = 5;
+
+  double result = divide(divisor, dividend);
+  //...
+}
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2234_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2234_java.json
new file mode 100755
index 0000000000..5fb547ff90
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2234_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "Parameters should be passed in the correct order",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-2234",
+  "sqKey": "S2234"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2245_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2245_java.json
index 8c5b39d923..6d9bc0589c 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2245_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2245_java.json
@@ -9,7 +9,7 @@
   "tags": [
     "cwe",
     "cert",
-    "owasp-a6"
+    "owasp-a3"
   ],
   "standards": [
     "CWE",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2254_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2254_java.html
index ccfda32ff0..c247f7a454 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2254_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2254_java.html
@@ -26,7 +26,5 @@ <h2>See</h2>
   <li> <a href="http://cwe.mitre.org/data/definitions/807">MITRE, CWE-807</a> - Reliance on Untrusted Inputs in a Security Decision </li>
   <li> <a href="http://www.sans.org/top25-software-errors/">SANS Top 25</a> - Porous Defenses </li>
   <li> OWASP Top 10 2017 Category A2 - Broken Authentication </li>
-  <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#SERVLET_SESSION_ID">Untrusted Session Cookie Value</a>
-  </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2257_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2257_java.json
index 8383d46da7..f2bbd1671a 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2257_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2257_java.json
@@ -8,8 +8,8 @@
   },
   "tags": [
     "cwe",
-    "owasp-a6",
-    "sans-top25-porous"
+    "sans-top25-porous",
+    "owasp-a3"
   ],
   "standards": [
     "CWE",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2258_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2258_java.html
index 7e17ecee3e..b736d0e33b 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2258_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2258_java.html
@@ -2,12 +2,11 @@
 any way. As a consequence, the ciphertext is identical to the plaintext. So this class should be used for testing, and never in production code.</p>
 <h2>Noncompliant Code Example</h2>
 <pre>
-NullCipher nc=new NullCipher();
+NullCipher nc = new NullCipher();
 </pre>
 <h2>See</h2>
 <ul>
-  <li> <a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327</a>: Use of a Broken or Risky Cryptographic Algorithm </li>
-  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
-  <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#NULL_CIPHER">NullCipher Unsafe</a> </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/327.html">CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
+  <li> OWASP Top 10 2017 Category A6 - Security Misconfiguration </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2277_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2277_java.json
index f5ced6a177..d3685b5332 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2277_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2277_java.json
@@ -10,7 +10,7 @@
     "cwe",
     "owasp-a6",
     "sans-top25-porous",
-    "owasp-a5"
+    "owasp-a3"
   ],
   "standards": [
     "CWE",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2278_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2278_java.html
index e559fa898d..34c237ae6e 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2278_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2278_java.html
@@ -15,9 +15,9 @@ <h2>Compliant Solution</h2>
 </pre>
 <h2>See</h2>
 <ul>
-  <li> <a href="http://cwe.mitre.org/data/definitions/326.html">MITRE CWE-326</a> - Inadequate Encryption Strength </li>
-  <li> <a href="http://cwe.mitre.org/data/definitions/327.html">MITRE CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
-  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/326.html">MITRE, CWE-326</a> - Inadequate Encryption Strength </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/327.html">MITRE, CWE-327</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
+  <li> OWASP Top 10 2017 Category A6 - Security Misconfiguration </li>
   <li> <a href="https://www.securecoding.cert.org/confluence/x/VwAZAg">CERT, MSC61-J.</a> - Do not use insecure or weak cryptographic algorithms </li>
   <li> Derived from FindSecBugs rule <a href="http://h3xstream.github.io/find-sec-bugs/bugs.htm#DES_USAGE">DES / DESede Unsafe</a> </li>
 </ul>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2583_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2583_java.html
index 104e435f0d..aecd31ae0b 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2583_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2583_java.html
@@ -13,6 +13,27 @@ <h2>Noncompliant Code Example</h2>
   doSomethingElse(); // never executed
 }
 </pre>
+<h2>Exceptions</h2>
+<p>This rule will not raise an issue in either of these cases:</p>
+<ul>
+  <li> When the condition is a single <code>final boolean</code> </li>
+</ul>
+<pre>
+final boolean debug = false;
+//...
+if (debug) {
+  // Print something
+}
+</pre>
+<ul>
+  <li> When the condition is literally <code>true</code> or <code>false</code>. </li>
+</ul>
+<pre>
+if (true) {
+  // do something
+}
+</pre>
+<p>In these cases it is obvious the code is as intended.</p>
 <h2>See</h2>
 <ul>
   <li> MISRA C:2004, 13.7 - Boolean operations whose results are invariant shall not be permitted. </li>
@@ -21,6 +42,5 @@ <h2>See</h2>
   <li> <a href="http://cwe.mitre.org/data/definitions/571">MITRE, CWE-571</a> - Expression is Always True </li>
   <li> <a href="https://www.securecoding.cert.org/confluence/x/NYA5">CERT, MSC12-C.</a> - Detect and remove code that has no effect or is never
   executed </li>
-  <li> <a href="https://www.securecoding.cert.org/confluence/x/SIIyAQ">CERT, MSC12-CPP.</a> - Detect and remove code that has no effect </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2694_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2694_java.html
index 5433f2e73c..31a9271673 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2694_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2694_java.html
@@ -3,7 +3,7 @@
 <p>If the reference to the outer class isn't used, it is more efficient to make the inner class <code>static</code> (also called nested). If the
 reference is used only in the class constructor, then explicitly pass a class reference to the constructor. If the inner class is anonymous, it will
 also be necessary to name it. </p>
-<p>However, while a nested/<code>static</code> class would be more efficient, it's worth nothing that there are semantic differences between an inner
+<p>However, while a nested/<code>static</code> class would be more efficient, it's worth noting that there are semantic differences between an inner
 class and a nested one:</p>
 <ul>
   <li> an inner class can only be instantiated within the context of an instance of the outer class. </li>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2718_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2718_java.html
index 669f593a93..7deda1fc0f 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2718_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2718_java.html
@@ -11,8 +11,10 @@ <h2>Compliant Solution</h2>
 <pre>
 public Date trunc(Date date) {
   Instant instant = date.toInstant();
-  instant = instant.truncatedTo(ChronoUnit.SECONDS);
-  return Date.from(instant);
+  ZonedDateTime zonedDateTime = instant.atZone(ZoneId.systemDefault());
+  ZonedDateTime truncatedZonedDateTime = zonedDateTime.truncatedTo(ChronoUnit.SECONDS);
+  Instant truncatedInstant = truncatedZonedDateTime.toInstant();
+  return Date.from(truncatedInstant);
 }
 </pre>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.html
index 6f4b0af760..be8f861754 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.html
@@ -1,5 +1,5 @@
 <p>A <code>catch</code> clause that only rethrows the caught exception has the same effect as omitting the <code>catch</code> altogether and letting
-it bubble up automatically, but with more code and the additional detrement of leaving maintainers scratching their heads. </p>
+it bubble up automatically, but with more code and the additional detriment of leaving maintainers scratching their heads. </p>
 <p>Such clauses should either be eliminated or populated with the appropriate logic.</p>
 <h2>Noncompliant Code Example</h2>
 <pre>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.json
index 9ec515b6b0..25abcd3854 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2737_java.json
@@ -7,7 +7,6 @@
     "constantCost": "5min"
   },
   "tags": [
-    "cert",
     "unused",
     "finding",
     "clumsy"
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2761_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2761_java.html
new file mode 100755
index 0000000000..a467d2dd86
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2761_java.html
@@ -0,0 +1,29 @@
+<p>The needless repetition of an operator is usually a typo. There is no reason to write <code>!!!i</code> when <code>!i</code> will do.</p>
+<p>On the other hand, the repetition of increment and decrement operators may have been done on purpose, but doing so obfuscates the meaning, and
+should be simplified.</p>
+<p>This rule raises an issue for sequences of: <code>!</code>, <code>~</code>, <code>-</code>, and <code>+</code>.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+int i = 1;
+
+int j = - - -i;  // Noncompliant; just use -i
+int k = ~~~i;    // Noncompliant; same as i
+int m = + +i;    // Noncompliant; operators are useless here
+
+boolean b = false;
+boolean c = !!!b;   // Noncompliant
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+int i =  1;
+
+int j = -i;
+int k = ~i;
+int m =  i;
+
+boolean b = false;
+boolean c = !b;
+</pre>
+<h2>Exceptions</h2>
+<p>Overflow handling for GWT compilation using <code>~~</code> is ignored.</p>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2761_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2761_java.json
new file mode 100755
index 0000000000..f998b11677
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2761_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "Unary prefix operators should not be repeated",
+  "type": "BUG",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-2761",
+  "sqKey": "S2761"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2976_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2976_java.json
index 4825e7c436..0372211aad 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2976_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S2976_java.json
@@ -9,6 +9,9 @@
   "tags": [
     "owasp-a9"
   ],
+  "standards": [
+    "OWASP Top Ten"
+  ],
   "defaultSeverity": "Critical",
   "ruleSpecification": "RSPEC-2976",
   "sqKey": "S2976"
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3306_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3306_java.json
index c8903a1477..ea20ec9701 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3306_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3306_java.json
@@ -7,7 +7,9 @@
     "constantCost": "5min"
   },
   "tags": [
+    "spring",
     "design",
+    "jee",
     "pitfall"
   ],
   "defaultSeverity": "Major",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.html
index cf8da4ac43..cfffbf77f1 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.html
@@ -9,5 +9,6 @@ <h2>Noncompliant Code Example</h2>
 <h2>See</h2>
 <ul>
   <li> <a href="http://cwe.mitre.org/data/definitions/501">MITRE, CWE-501</a> - Trust Boundary Violation </li>
+  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.json
index 73fe7b71b5..97a0d23f8e 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3318_java.json
@@ -7,10 +7,12 @@
     "constantCost": "20min"
   },
   "tags": [
-    "cwe"
+    "cwe",
+    "owasp-a3"
   ],
   "standards": [
-    "CWE"
+    "CWE",
+    "OWASP Top Ten"
   ],
   "defaultSeverity": "Major",
   "ruleSpecification": "RSPEC-3318",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3366_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3366_java.html
new file mode 100755
index 0000000000..42906bb31c
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3366_java.html
@@ -0,0 +1,33 @@
+<p>In single-threaded environments, the use of <code>this</code> in constructors is normal, and expected. But in multi-threaded environments, it could
+expose partially-constructed objects to other threads, and should be used with caution.</p>
+<p>The classic example is a class with a <code>static</code> list of its instances. If the constructor stores <code>this</code> in the list, another
+thread could access the object before it's fully-formed. Even when the storage of <code>this</code> is the last instruction in the constructor,
+there's still a danger if the class is not <code>final</code>. In that case, the initialization of subclasses won't be complete before
+<code>this</code> is exposed.</p>
+<p>This rule raises an issue when <code>this</code> is assigned to any globally-visible object in a constructor, and when it is passed to the method
+of another object in a constructor</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+public class Monument {
+
+  public static final List&lt;Monument&gt; ALL_MONUMENTS = new ArrayList()&lt;&gt;;
+  // ...
+
+  public Monument(String location, ...) {
+    ALL_MONUMENTS.add(this);  // Noncompliant; passed to a method of another object
+
+    this.location = location;
+    // ...
+  }
+}
+</pre>
+<h2>Exceptions</h2>
+<p>This rule ignores instances of assigning <code>this</code> directly to a <code>static</code> field of the same class because that case is covered
+by S3010.</p>
+<h2>See</h2>
+<ul>
+  <li> <a href="https://www.securecoding.cert.org/confluence/x/aAD1AQ">CERT, TSM01-J.</a> - Do not let the this reference escape during object
+  construction </li>
+  <li> <a href="https://www.securecoding.cert.org/confluence/x/7ABQAg">CERT, TSM03-J.</a> - Do not publish partially initialized objects </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3366_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3366_java.json
new file mode 100755
index 0000000000..e7683acb1a
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3366_java.json
@@ -0,0 +1,20 @@
+{
+  "title": "\"this\" should not be exposed from constructors",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "30min"
+  },
+  "tags": [
+    "multi-threading",
+    "cert",
+    "suspicious"
+  ],
+  "standards": [
+    "CERT"
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-3366",
+  "sqKey": "S3366"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.html
index da1aebb8a8..7cbb4be959 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.html
@@ -4,6 +4,6 @@
 <h2>See</h2>
 <ul>
   <li> <a href="https://cwe.mitre.org/data/definitions/284.html">MITRE, CWE-284</a> - Improper Access Control </li>
-  <li> OWASP Top 10 2017 Category A6 - Broken Access Control </li>
+  <li> OWASP Top 10 2017 Category A5 - Broken Access Control </li>
 </ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.json
index 9f5f72f53d..320b198cdb 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3369_java.json
@@ -10,7 +10,7 @@
     "cwe",
     "websphere",
     "jee",
-    "owasp-a7"
+    "owasp-a5"
   ],
   "standards": [
     "CWE",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3510_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3510_java.html
new file mode 100755
index 0000000000..e9144e1411
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3510_java.html
@@ -0,0 +1,46 @@
+<p>To prevent URL spoofing, <code>HostnameVerifier.verify()</code> methods should do more than simply <code>return true</code>. Doing so may get you
+quickly past an exception, but that comes at the cost of opening a security hole in your application. </p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+SSLContext sslcontext = SSLContext.getInstance( "TLS" );
+sslcontext.init(null, new TrustManager[]{new X509TrustManager() {
+  public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}
+  public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}
+  public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
+
+}}, new java.security.SecureRandom());
+
+Client client = ClientBuilder.newBuilder().sslContext(sslcontext).hostnameVerifier(new HostnameVerifier() {
+  @Override
+  public boolean verify(String requestedHost, SSLSession remoteServerSession) {
+    return true;  // Noncompliant
+  }
+}).build();
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+SSLContext sslcontext = SSLContext.getInstance( "TLSv1.2" );
+sslcontext.init(null, new TrustManager[]{new X509TrustManager() {
+  @Override
+  public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}
+  @Override
+  public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {}
+  @Override
+  public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
+
+}}, new java.security.SecureRandom());
+
+Client client = ClientBuilder.newBuilder().sslContext(sslcontext).hostnameVerifier(new HostnameVerifier() {
+  @Override
+  public boolean verify(String requestedHost, SSLSession remoteServerSession) {
+    return requestedHost.equalsIgnoreCase(remoteServerSession.getPeerHost()); // Compliant
+  }
+}).build();
+</pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/295.html">MITRE, CWE-295</a> - Improper Certificate Validation </li>
+  <li> OWASP Top 10 2017 Category A6 - Security Misconfiguration </li>
+  <li> Derived from FindSecBugs rule <a href="https://find-sec-bugs.github.io/bugs.htm#WEAK_HOSTNAME_VERIFIER">WEAK_HOSTNAME_VERIFIER</a> </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3510_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3510_java.json
new file mode 100755
index 0000000000..991975cecb
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3510_java.json
@@ -0,0 +1,21 @@
+{
+  "title": "\"HostnameVerifier.verify\" should not always return true",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "cwe",
+    "owasp-a6"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten"
+  ],
+  "defaultSeverity": "Blocker",
+  "ruleSpecification": "RSPEC-3510",
+  "sqKey": "S3510",
+  "scope": "Main"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3626_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3626_java.html
new file mode 100755
index 0000000000..d8e181f501
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3626_java.html
@@ -0,0 +1,26 @@
+<p>Jump statements such as <code>return</code> and <code>continue</code> let you change the default flow of program execution, but jump statements
+that direct the control flow to the original direction are just a waste of keystrokes.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+public void foo() {
+  while (condition1) {
+    if (condition2) {
+      continue; // Noncompliant
+    } else {
+      doTheThing();
+    }
+  }
+  return; // Noncompliant; this is a void method
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+public void foo() {
+  while (condition1) {
+    if (!condition2) {
+      doTheThing();
+    }
+  }
+}
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3626_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3626_java.json
new file mode 100755
index 0000000000..9d091aec43
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3626_java.json
@@ -0,0 +1,16 @@
+{
+  "title": "Jump statements should not be redundant",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "1min"
+  },
+  "tags": [
+    "redundant",
+    "clumsy"
+  ],
+  "defaultSeverity": "Minor",
+  "ruleSpecification": "RSPEC-3626",
+  "sqKey": "S3626"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.html
index b2b69247d3..3c77f1e62c 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.html
@@ -30,4 +30,8 @@ <h2>Noncompliant Code Example</h2>
   }
 }
 </pre>
+<h2>See</h2>
+<ul>
+  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
+</ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.json
index f7ad23bf6a..a0fd030182 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3749_java.json
@@ -7,7 +7,11 @@
     "constantCost": "15min"
   },
   "tags": [
-    "spring"
+    "spring",
+    "owasp-a3"
+  ],
+  "standards": [
+    "OWASP Top Ten"
   ],
   "defaultSeverity": "Critical",
   "ruleSpecification": "RSPEC-3749",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3923_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3923_java.html
index f6fd4fbc96..03b4ca912d 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3923_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S3923_java.html
@@ -1,12 +1,10 @@
 <p>Having all branches in a <code>switch</code> or <code>if</code> chain with the same implementation is an error. Either a copy-paste error was made
-and something different should be executed, or there shouldn't be a <code>switch</code>/<code>if</code> chain at all. Note that this rule does not
-apply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code> clauses.</p>
+and something different should be executed, or there shouldn't be a <code>switch</code>/<code>if</code> chain at all.</p>
 <h2>Noncompliant Code Example</h2>
 <pre>
 if (b == 0) {  // Noncompliant
   doOneMoreThing();
-}
-else {
+} else {
   doOneMoreThing();
 }
 
@@ -26,4 +24,14 @@ <h2>Noncompliant Code Example</h2>
     doSomething();
 }
 </pre>
+<h2>Exceptions</h2>
+<p>This rule does not apply to <code>if</code> chains without <code>else</code>-s, or to <code>switch</code>-es without <code>default</code>
+clauses.</p>
+<pre>
+if(b == 0) {    //no issue, this could have been done on purpose to make the code more readable
+  doSomething();
+} else if(b == 1) {
+  doSomething();
+}
+</pre>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4065_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4065_java.html
index 462e760220..e3fa03271f 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4065_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4065_java.html
@@ -1,4 +1,4 @@
-<p>Java 8 Introduced <code>ThreadLocal.withInitial</code> which is a simpler alternative to creating an anonymous inner class to initialise a
+<p>Java 8 introduced <code>ThreadLocal.withInitial</code> which is a simpler alternative to creating an anonymous inner class to initialise a
 <code>ThreadLocal</code> instance.</p>
 <p>This rule raises an issue when a <code>ThreadLocal</code> anonymous inner class can be replaced by a call to
 <code>ThreadLocal.withInitial</code>.</p>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.html
index b07e7f2840..af540a07fa 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.html
@@ -22,4 +22,6 @@ <h2>Compliant Solution</h2>
 &nbsp;&nbsp;// ...
 }
 </pre>
+<h2>Deprecated</h2>
+<p>This rule is deprecated, and will eventually be removed.</p>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.json
index 376716d3a7..a0e44787fc 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4142_java.json
@@ -1,13 +1,13 @@
 {
   "title": "Duplicate values should not be passed as arguments",
   "type": "CODE_SMELL",
-  "status": "ready",
+  "status": "deprecated",
   "remediation": {
     "func": "Constant\/Issue",
     "constantCost": "5min"
   },
   "tags": [
-    "suspicious"
+    
   ],
   "defaultSeverity": "Major",
   "ruleSpecification": "RSPEC-4142",
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4201_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4201_java.html
new file mode 100755
index 0000000000..1b3fcfbdc3
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4201_java.html
@@ -0,0 +1,15 @@
+<p>There's no need to null test in conjunction with an <code>instanceof</code> test. <code>null</code> is not an <code>instanceof</code> anything, so
+a null check is redundant.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+if (x != null &amp;&amp; x instanceof MyClass) { ... }  // Noncompliant
+
+if (x == null || ! x instanceof MyClass) { ... } // Noncompliant
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+if (x instanceof MyClass) { ... }
+
+if (! x instanceof MyClass) { ... }
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4201_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4201_java.json
new file mode 100755
index 0000000000..998f96e447
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4201_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "Null checks should not be used with \"instanceof\"",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "redundant"
+  ],
+  "defaultSeverity": "Minor",
+  "ruleSpecification": "RSPEC-4201",
+  "sqKey": "S4201"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4248_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4248_java.html
new file mode 100755
index 0000000000..a665c986ab
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4248_java.html
@@ -0,0 +1,44 @@
+<p>The <code>java.util.regex.Pattern.compile()</code> methods have a significant performance cost, and therefore should be used sensibly.</p>
+<p>Moreover they are the only mechanism available to create instances of the Pattern class, which are necessary to do any pattern matching using
+regular expressions. Unfortunately that can be hidden behind convenience methods like <code>String.matches()</code> or
+<code>String.split()</code>.</p>
+<p>It is therefore somewhat easy to inadvertently repeatedly compile the same regular expression at great performance cost with no valid reason.</p>
+<p>This rule raises an issue when:</p>
+<ul>
+  <li> A <code>Pattern</code> is compiled from a <code>String</code> literal or constant and is not stored in a static final reference. </li>
+  <li> <code>String.matches</code>, <code>String.split</code>, <code>String.replaceAll</code> or <code>String.replaceFirst</code> are invoked with a
+  <code>String</code> literal or constant. In which case the code should be refactored to use a <code>java.util.regex.Pattern</code> while respecting
+  the previous rule. </li>
+</ul>
+<h2>Noncompliant Code Example</h2>
+<pre>
+public void doingSomething(String stringToMatch) {
+  Pattern regex = Pattern.compile("myRegex");  // Noncompliant
+  Matcher matcher = regex.matcher("s");
+  // ...
+  if (stringToMatch.matches("myRegex2")) {  // Noncompliant
+    // ...
+  }
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+private static final Pattern myRegex = Pattern.compile("myRegex");
+private static final Pattern myRegex2 = Pattern.compile("myRegex2");
+
+public void doingSomething(String stringToMatch) {
+  Matcher matcher = myRegex.matcher("s");
+  // ...
+  if (myRegex2.matcher(stringToMatch).matches()) {
+    // ...
+  }
+}
+</pre>
+<h2>Exceptions</h2>
+<p><code>String.split</code> doesn't create a regex when the string passed as argument meets either of these 2 conditions:</p>
+<ul>
+  <li> It is a one-char String and this character is not one of the RegEx's meta characters ".$|()[{^?*+\" </li>
+  <li> It is a two-char String and the first char is the backslash and the second is not the ascii digit or ascii letter. </li>
+</ul>
+<p>In which case no issue will be raised.</p>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4248_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4248_java.json
new file mode 100755
index 0000000000..926a95bca1
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4248_java.json
@@ -0,0 +1,16 @@
+{
+  "title": "Regex patterns should not be created needlessly",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "10min"
+  },
+  "tags": [
+    "regex",
+    "performance"
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-4248",
+  "sqKey": "S4248"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4274_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4274_java.html
new file mode 100755
index 0000000000..f6f2f0b9ba
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4274_java.html
@@ -0,0 +1,24 @@
+<p>An <code>assert</code> is inappropriate for parameter validation because assertions can be disabled at runtime in the JVM, meaning that a bad
+operational setting would completely eliminate the intended checks. Further, <code>assert</code>s that fail throw <code>AssertionError</code>s, rather
+than throwing some type of <code>Exception</code>. Throwing <code>Error</code>s is completely outside of the normal realm of expected
+<code>catch</code>/<code>throw</code> behavior in normal programs.</p>
+<p>This rule raises an issue when a <code>public</code> method uses one or more of its parameters with <code>assert</code>s.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+ public void setPrice(int price) {
+  assert price &gt;= 0 &amp;&amp; price &lt;= MAX_PRICE;
+  // Set the price
+ }
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+ public void setPrice(int price) {
+  if (price &lt; 0 || price &gt; MAX_PRICE) {
+    throw new IllegalArgumentException("Invalid price: " + price);
+  }
+  // Set the price
+ }
+</pre>
+<h2>See</h2>
+<p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/language/assert.html">Programming With Assertions</a></p>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4274_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4274_java.json
new file mode 100755
index 0000000000..b1f48e5af6
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4274_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "Asserts should not be used to check the parameters of a public method",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "pitfall"
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-4274",
+  "sqKey": "S4274"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.html
index 2b24f91f15..a046f5bff0 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.html
@@ -21,4 +21,14 @@ <h2>Compliant Solution</h2>
 SecureRandom sr = new SecureRandom();
 int v = sr.next(32);
 </pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/330.html">MITRE, CWE-330</a> - Use of Insufficiently Random Values </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/332.html">MITRE, CWE-332</a> - Insufficient Entropy in PRNG </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/336.html">MITRE, CWE-336</a> - Same Seed in Pseudo-Random Number Generator (PRNG) </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/337.html">MITRE, CWE-337</a> - Predictable Seed in Pseudo-Random Number Generator (PRNG) </li>
+  <li> OWASP Top 10 2017 Category A6 - Security Misconfiguration </li>
+  <li> <a href="https://wiki.sei.cmu.edu/confluence/display/java/MSC63J.+Ensure+that+SecureRandom+is+properly+seeded">CERT, MSC63J.</a> - Ensure that
+  SecureRandom is properly seeded </li>
+</ul>
 
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.json
index a59470858f..5d539ac88b 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4347_java.json
@@ -7,9 +7,15 @@
     "constantCost": "2min"
   },
   "tags": [
-    "security",
+    "cwe",
+    "cert",
+    "owasp-a6",
     "pitfall"
   ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten"
+  ],
   "defaultSeverity": "Critical",
   "ruleSpecification": "RSPEC-4347",
   "sqKey": "S4347"
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4351_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4351_java.html
new file mode 100755
index 0000000000..ebeb29e7e3
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4351_java.html
@@ -0,0 +1,38 @@
+<p>When implementing the <code>Comparable&lt;T&gt;.compareTo</code> method, the parameter's type has to match the type used in the
+<code>Comparable</code> declaration. When a different type is used this creates an overload instead of an override, which is unlikely to be the
+intent.</p>
+<p>This rule raises an issue when the parameter of the <code>compareTo</code> method of a class implementing <code>Comparable&lt;T&gt;</code> is not
+same as the one used in the <code>Comparable</code> declaration.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+public class Foo {
+  static class Bar implements Comparable&lt;Bar&gt; {
+    public int compareTo(Bar rhs) {
+      return -1;
+    }
+  }
+
+  static class FooBar extends Bar {
+    public int compareTo(FooBar rhs) {  // Noncompliant: Parameter should be of type Bar
+      return 0;
+    }
+  }
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+public class Foo {
+  static class Bar implements Comparable&lt;Bar&gt; {
+    public int compareTo(Bar rhs) {
+      return -1;
+    }
+  }
+
+  static class FooBar extends Bar {
+    public int compareTo(Bar rhs) {
+      return 0;
+    }
+  }
+}
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4351_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4351_java.json
new file mode 100755
index 0000000000..394ecd476c
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4351_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "\"compareTo\" should not be overloaded",
+  "type": "BUG",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "pitfall"
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-4351",
+  "sqKey": "S4351"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4423_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4423_java.html
new file mode 100755
index 0000000000..24860871e4
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4423_java.html
@@ -0,0 +1,21 @@
+<p><code>javax.net.ssl.SSLContext.getInstance</code> returns a SSLContext object that implements the specified secure socket protocol. However, not
+all protocols are created equal and some legacy ones like "SSL", have been proven to be insecure.</p>
+<p>This rule raises an issue when an <code>SSLContext</code> is created with an insecure protocol (ie: a protocol different from "TLSv1.2" or
+"DTLSv1.2").</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+context = SSLContext.getInstance("SSL"); // Noncompliant
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+context = SSLContext.getInstance("TLSv1.2");
+</pre>
+<h2>See</h2>
+<ul>
+  <li> <a href="http://cwe.mitre.org/data/definitions/326.html">MITRE, CWE-327</a> - Inadequate Encryption Strength </li>
+  <li> <a href="http://cwe.mitre.org/data/definitions/327.html">MITRE, CWE-326</a> - Use of a Broken or Risky Cryptographic Algorithm </li>
+  <li> OWASP Top 10 2017 Category A3 - Sensitive Data Exposure </li>
+  <li> OWASP Top 10 2017 Category A6 - Security Misconfiguration </li>
+  <li> <a href="https://blogs.oracle.com/java-platform-group/diagnosing-tls,-ssl,-and-https">Diagnosing TLS, SSL, and HTTPS</a> </li>
+</ul>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4423_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4423_java.json
new file mode 100755
index 0000000000..16c74b4784
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4423_java.json
@@ -0,0 +1,23 @@
+{
+  "title": "Weak SSLContexts should not be used",
+  "type": "VULNERABILITY",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "2min"
+  },
+  "tags": [
+    "cwe",
+    "owasp-a6",
+    "sans-top25-porous",
+    "owasp-a3"
+  ],
+  "standards": [
+    "CWE",
+    "OWASP Top Ten",
+    "SANS Top 25"
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-4423",
+  "sqKey": "S4423"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4449_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4449_java.html
new file mode 100755
index 0000000000..f38146a079
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4449_java.html
@@ -0,0 +1,65 @@
+<p>When using null-related annotations at global scope level, for instance using <code>javax.annotation.ParametersAreNonnullByDefault</code> (from
+JSR-305) at package level, it means that all the parameters to all the methods included in the package will, or should, be considered
+Non-<code>null</code>. It is equivalent to annotating every parameter in every method with non-null annotations (such as <code>@Nonnull</code>).</p>
+<p>The rule raises an issue every time a parameter could be <code>null</code> for a method invocation, where the method is annotated as forbidding
+null parameters.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+@javax.annotation.ParametersAreNonnullByDefault
+class A {
+
+  void foo() {
+    bar(getValue()); // Noncompliant - method 'bar' do not expect 'null' values as parameter
+  }
+
+  void bar(Object o) { // 'o' is by contract expected never to be null
+    // ...
+  }
+
+  @javax.annotation.CheckForNull
+  abstract Object getValue();
+}
+</pre>
+<h2>Compliant Solution</h2>
+<p>Two solutions are possible: </p>
+<ul>
+  <li> The signature of the method is correct, and null check should be done prior to the call. </li>
+  <li> The signature of the method is not coherent and should be annotated to allow null values being passed as parameter </li>
+</ul>
+<pre>
+@javax.annotation.ParametersAreNonnullByDefault
+abstract class A {
+
+  void foo() {
+      Object o = getValue();
+      if (o != null) {
+        bar(); // Compliant - 'o' can not be null
+      }
+  }
+
+  void bar(Object o) {
+    // ...
+  }
+
+  @javax.annotation.CheckForNull
+  abstract Object getValue();
+}
+</pre>
+<p>or </p>
+<pre>
+@javax.annotation.ParametersAreNonnullByDefault
+abstract class A {
+
+  void foo() {
+    bar(getValue());
+  }
+
+  void bar(@javax.annotation.Nullable Object o) { // annotation was missing
+    // ...
+  }
+
+  @javax.annotation.CheckForNull
+  abstract Object getValue();
+}
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4449_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4449_java.json
new file mode 100755
index 0000000000..ec23ca15ad
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4449_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "Nullness of parameters should be guaranteed",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "10min"
+  },
+  "tags": [
+    
+  ],
+  "defaultSeverity": "Major",
+  "ruleSpecification": "RSPEC-4449",
+  "sqKey": "S4449"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4454_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4454_java.html
new file mode 100755
index 0000000000..b9a5d4a1cf
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4454_java.html
@@ -0,0 +1,23 @@
+<p>By contract, the <code>equals(Object)</code> method, from <code>java.lang.Object</code>, should accept a <code>null</code> argument. Among all the
+other cases, the <code>null</code> case is even explicitly detailed in the <code>Object.equals(...)</code> Javadoc, stating "_For any non-null
+reference value x, x.equals(null) should return false._"</p>
+<p>Assuming that the argument to <code>equals</code> is always non-null, and enforcing that assumption with an annotation is not only a fundamental
+violation of the contract of <code>equals</code>, but it is also likely to cause problems in the future as the use of the class evolves over time.</p>
+<p>The rule raises an issue when the <code>equals</code> method is overridden and its parameter annotated with any kind of <code>@Nonnull</code>
+annotation.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+public boolean equals(@javax.annotation.Nonnull Object obj) { // Noncompliant
+  // ...
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+public boolean equals(Object obj) {
+  if (obj == null) {
+    return false;
+  }
+  // ...
+}
+</pre>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4454_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4454_java.json
new file mode 100755
index 0000000000..42dbcded4a
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4454_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "\"equals\" method parameters should not be marked \"@Nonnull\"",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "3min"
+  },
+  "tags": [
+    
+  ],
+  "defaultSeverity": "Critical",
+  "ruleSpecification": "RSPEC-4454",
+  "sqKey": "S4454"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4524_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4524_java.html
new file mode 100755
index 0000000000..85a401f0ba
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4524_java.html
@@ -0,0 +1,39 @@
+<p><code>switch</code> can contain a <code>default</code> clause for various reason: to handle unexpected values, to show all the cases where properly
+considered.</p>
+<p>For readability purpose, to help a developer to quickly find the default behavior of a <code>switch</code> statement, it is recommended to put the
+<code>default</code> clause at the beginning or the end of the <code>switch</code> statement. This rule raised an issue if the <code>default</code>
+statement is not the first or the last one of the switch's cases.</p>
+<h2>Noncompliant Code Example</h2>
+<pre>
+switch (param) {
+  default: // default clause should be the last one
+    error();
+    break;
+  case 0:
+    doSomething();
+    break;
+  case 1:
+    doSomethingElse();
+    break;
+}
+</pre>
+<h2>Compliant Solution</h2>
+<pre>
+switch (param) {
+  case 0:
+    doSomething();
+    break;
+  case 1:
+    doSomethingElse();
+    break;
+  default:
+    error();
+    break;
+}
+</pre>
+<h2>See</h2>
+<p>- MISRA C:2004, 15.3 - The final clause of a switch statement shall be the default clause</p>
+<p>- MISRA C++:2008, 6-4-6 - The final clause of a switch statement shall be the default-clause</p>
+<p>- MISRA C:2012, 16.4 - Every switch statement shall have a default label</p>
+<p>- MISRA C:2012, 16.5 - A default label shall appear as either the first or the last switch label of a switch statement</p>
+
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4524_java.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4524_java.json
new file mode 100755
index 0000000000..2c626e0bc0
--- /dev/null
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S4524_java.json
@@ -0,0 +1,15 @@
+{
+  "title": "\"default\" clauses should be last",
+  "type": "CODE_SMELL",
+  "status": "ready",
+  "remediation": {
+    "func": "Constant\/Issue",
+    "constantCost": "5min"
+  },
+  "tags": [
+    "misra"
+  ],
+  "defaultSeverity": "Critical",
+  "ruleSpecification": "RSPEC-4524",
+  "sqKey": "S4524"
+}
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S899_java.html b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S899_java.html
index fed6dd70f7..e0999915cb 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S899_java.html
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/S899_java.html
@@ -9,7 +9,7 @@
   <li> non-void <code>Condition.await*</code> methods </li>
   <li> <code>CountDownLatch.await(long, TimeUnit)</code> </li>
   <li> <code>Semaphore.tryAcquire</code> </li>
-  <li> <code>BlockingQueue</code>: <code>offer</code>, <code>remove</code>, <code>drainTo</code>, </li>
+  <li> <code>BlockingQueue</code>: <code>offer</code>, <code>remove</code> </li>
 </ul>
 <h2>Noncompliant Code Example</h2>
 <pre>
diff --git a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
index af4f7fc81b..ab8fd1c3a3 100755
--- a/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
+++ b/java-checks/src/main/resources/org/sonar/l10n/java/rules/squid/Sonar_way_profile.json
@@ -187,6 +187,7 @@
     "S2226",
     "S2230",
     "S2232",
+    "S2234",
     "S2235",
     "S2236",
     "S2251",
@@ -233,6 +234,7 @@
     "S2718",
     "S2737",
     "S2757",
+    "S2761",
     "S2786",
     "S2789",
     "S2864",
@@ -266,9 +268,11 @@
     "S3436",
     "S3438",
     "S3457",
+    "S3510",
     "S3516",
     "S3518",
     "S3599",
+    "S3626",
     "S3631",
     "S3655",
     "S3725",
@@ -291,9 +295,15 @@
     "S4143",
     "S4144",
     "S4165",
+    "S4201",
+    "S4274",
     "S4275",
     "S4347",
     "S4348",
-    "S4349"
+    "S4349",
+    "S4351",
+    "S4423",
+    "S4449",
+    "S4454"
   ]
 }
diff --git a/java-checks/src/test/files/checks/AllBranchesAreIdentical.java b/java-checks/src/test/files/checks/AllBranchesAreIdentical.java
index 3a415a2017..622eba25b4 100755
--- a/java-checks/src/test/files/checks/AllBranchesAreIdentical.java
+++ b/java-checks/src/test/files/checks/AllBranchesAreIdentical.java
@@ -9,10 +9,30 @@ void conditionalExpression () {
   }
 
   void switchStatement() {
-    switch (1) { // Noncompliant [[sc=5;ec=11]] {{Remove this conditional structure or edit its code blocks so that they're not all the same.}}
+    switch (1) {  // Noncompliant [[sc=5;ec=11]] {{Remove this conditional structure or edit its code blocks so that they're not all the same.}}
       case 1:
+        doSomething();
         break;
       case 2:
+        doSomething();
+        break;
+      case 3:
+        doSomething();
+        break;
+      default:
+        doSomething();
+        break;
+    }
+
+    switch (1) {  // Compliant as there is no "default" clause in this "switch" statement, this precise case is handled by RSPEC-1871
+      case 1:
+        doSomething();
+        break;
+      case 2:
+        doSomething();
+        break;
+      case 3:
+        doSomething();
         break;
     }
 
@@ -46,6 +66,11 @@ void ifStatement() {
     if (true) f(); // Noncompliant
     else f();
 
+    if(b == 0) { // Compliant as there is no "else" clause in this "if" statement, this precise case is handled by RSPEC-1871
+      doSomething();
+    } else if(b == 1) {
+      doSomething();
+    }
 
   }
 
diff --git a/java-checks/src/test/files/checks/AnonymousClassShouldBeLambdaCheck.java b/java-checks/src/test/files/checks/AnonymousClassShouldBeLambdaCheck.java
index 7cd597c07f..62d3417a5b 100755
--- a/java-checks/src/test/files/checks/AnonymousClassShouldBeLambdaCheck.java
+++ b/java-checks/src/test/files/checks/AnonymousClassShouldBeLambdaCheck.java
@@ -1,3 +1,6 @@
+import com.google.common.base.Function;
+import java.util.Date;
+
 enum foo  {
   FOO{
     @Override
@@ -117,6 +120,7 @@ public void myMethod() {
       };
       main.myMethod();
       Object o1 = new Object() {
+        @Override
         public String toString(){
           return null;
         }
@@ -139,7 +143,8 @@ public String handle() {
   }
   void foo(I i) {
     foo(new I() { // Compliant : Cannot be nicely refactored as lamdba because of the checked exception
-      void apply(String s) throws MyCheckedException {
+      @Override
+      public void apply(String s) throws MyCheckedException {
         // doSomething
       }
     });
@@ -169,3 +174,80 @@ public void run() {
       });
   }
 }
+
+interface AB {
+  default void foo() {
+  }
+
+  default void bar() {
+  }
+
+  static void main() {
+    AB a = new AB() { // Compliant
+      @Override
+      public void foo() {
+      }
+    };
+  }
+}
+
+interface BA {
+  default void foo() {
+  }
+
+  void bar();
+
+  static void main() {
+    BA a = new BA() { // Noncompliant
+      @Override
+      public void bar() {
+      }
+    };
+  }
+}
+
+class Alpha {
+
+  interface Lvl1 {
+    void foo();
+  }
+
+  interface Lvl2 extends Lvl1 {
+    @Override
+    void foo();
+  }
+
+  Lvl2 level = new Lvl2() { // Noncompliant
+    @Override
+    public void foo() {
+    }
+  };
+  Lvl2 level2 = () -> {};
+
+  Function<Object, Date> a = new Function<Object, Date>() { // Noncompliant - function overrides equals from object
+    @Override
+    public Date apply(Object o) {
+      return new Date();
+    }
+  };
+
+  Function<Object, Date> b = o -> new Date();
+}
+
+abstract class AbstractClass {
+  public abstract void foo();
+
+  static void bar() {
+    AbstractClass ac1 = new AbstractClass() { // Compliant: not a SAM
+      @Override
+      public void foo() {
+      }
+    };
+
+    Unknown u = new Unknown() { // Compliant: can not resolve parent
+      @Override
+      void foo() {
+      }
+    };
+  }
+}
diff --git a/java-checks/src/test/files/checks/AssertsOnParametersOfPublicMethodCheck.java b/java-checks/src/test/files/checks/AssertsOnParametersOfPublicMethodCheck.java
new file mode 100755
index 0000000000..814c337f97
--- /dev/null
+++ b/java-checks/src/test/files/checks/AssertsOnParametersOfPublicMethodCheck.java
@@ -0,0 +1,75 @@
+class A {
+
+  public void setPrice(int price1) {
+    assert price1 >= 0 && price1 <= 10000; // Noncompliant [[sc=5;ec=43]] {{Replace this assert with a proper check.}}
+  }
+
+  public int getPrice(int a) {
+    int price2 = 10;
+    assert price2 >= 0 && price2 <= 10000; // Compliant
+    return 0;
+  }
+
+  public void setPrice1(int price3) {
+    if (true) {
+      assert price3 > 1000; // Noncompliant
+    }
+  }
+
+  private void setPrice2(int price4) {
+    assert price4 >= 0 && price4 <= 10000; // Compliant
+  }
+
+  public void foo(Object a) {
+    new B() {
+      void Bar() {
+        assert a != null; // Noncompliant
+      }
+    };
+    if (a != null) {
+      // ...
+    }
+
+    assert getPrice(5) > 1; // Compliant
+    assert getPrice(5) > 1 || a != null; // Noncompliant
+
+  }
+}
+
+class B {
+
+  public void foo(int a) {
+    new Thread() {
+      public void run() {
+        assert a > 0; // Noncompliant
+        System.out.println("blah");
+      }
+    }.start();
+  }
+}
+
+class C {
+
+  public C(int c) {
+    assert c > 0; // Noncompliant
+    // ...
+  }
+
+  public synchronized void put(String a) {
+    assert ((a != null) && (b != null)); // Noncompliant
+    assert (find1(a) == null); // Noncompliant
+  }
+
+  public synchronized Integer find1(String a) {
+    assert (a != null); // Noncompliant
+    return 0;
+  }
+
+  private static class D {
+
+    public D(int a) {
+      assert a > 0; // Noncompliant
+
+    }
+  }
+}
diff --git a/java-checks/src/test/files/checks/CompareToNotOverloadedCheck.java b/java-checks/src/test/files/checks/CompareToNotOverloadedCheck.java
new file mode 100755
index 0000000000..eaba36d1d6
--- /dev/null
+++ b/java-checks/src/test/files/checks/CompareToNotOverloadedCheck.java
@@ -0,0 +1,60 @@
+class test{
+  class A implements Comparable<A> {
+    
+    public int compareTo(A a) {
+      return -1; // Compliant
+    }
+  }  
+  class B extends A {
+    
+    public int compareTo(B b) {   // Noncompliant {{Refactor this method so that its argument is of type 'A'.}}
+      return 0;
+    }
+    
+    public int compareTo(A a) { // Compliant
+      return 0;
+    }
+    
+    public int compareTo(A a, B b) { // Compliant
+      return 0;
+    }
+  }
+  
+  class C implements Comparable{
+    public int compareTo(Object a) {  // Compliant
+      return 0;
+    }
+  }
+  
+  class E extends C {
+    public int compareTo(E e) {   // Noncompliant  {{Refactor this method so that its argument is of type 'Object'.}}
+      return -1;
+    }
+  }
+  
+  static class Bar implements Comparable<A> {  // Compliant
+    public int compareTo(A rhs) {
+      return -1;
+    }
+  }
+          
+  static class FooBar extends Bar {
+      public int compareTo(FooBar rhs) {  // Noncompliant: Parameter should be of type Bar
+        return 0;
+      }
+  }
+    
+  class D {
+    public int compareTo(A a) {      // Compliant
+      return 1;
+    }
+    
+  }
+  
+  class F extends B{
+    public int compareTo1(B b) {      // Compliant
+      return 1;
+    }
+  }
+  
+}
diff --git a/java-checks/src/test/files/checks/DateUtilsTruncateCheck.java b/java-checks/src/test/files/checks/DateUtilsTruncateCheck.java
index b6bb9f1f9f..8411ceafbc 100755
--- a/java-checks/src/test/files/checks/DateUtilsTruncateCheck.java
+++ b/java-checks/src/test/files/checks/DateUtilsTruncateCheck.java
@@ -6,7 +6,7 @@
 
 class A {
   public void foo(Date date, Calendar calendar, Object object, int field) {
-    DateUtils.truncate(date, field);      // Noncompliant [[sc=15;ec=23]] {{Use "Instant.truncatedTo" instead.}}
+    DateUtils.truncate(date, field);      // Noncompliant [[sc=15;ec=23]] {{Use "ZonedDateTime.truncatedTo" instead.}}
     DateUtils.truncate(calendar, field);  // Noncompliant
     DateUtils.truncate(object, field);    // Noncompliant
     truncate(date, field);      // Noncompliant
diff --git a/java-checks/src/test/files/checks/DateUtilsTruncateCheck_no_version.java b/java-checks/src/test/files/checks/DateUtilsTruncateCheck_no_version.java
index 37e67d49b5..933ed50b13 100755
--- a/java-checks/src/test/files/checks/DateUtilsTruncateCheck_no_version.java
+++ b/java-checks/src/test/files/checks/DateUtilsTruncateCheck_no_version.java
@@ -6,7 +6,7 @@
 
 class A {
   public void foo(Date date, Calendar calendar, Object object, int field) {
-    DateUtils.truncate(date, field);      // Noncompliant {{Use "Instant.truncatedTo" instead. (sonar.java.source not set. Assuming 8 or greater.)}}
+    DateUtils.truncate(date, field);      // Noncompliant {{Use "ZonedDateTime.truncatedTo" instead. (sonar.java.source not set. Assuming 8 or greater.)}}
     DateUtils.truncate(calendar, field);  // Noncompliant
     DateUtils.truncate(object, field);    // Noncompliant
     truncate(date, field);      // Noncompliant
diff --git a/java-checks/src/test/files/checks/DoublePrefixOperatorCheck/DoublePrefixOperatorCheck.java b/java-checks/src/test/files/checks/DoublePrefixOperatorCheck/DoublePrefixOperatorCheck.java
new file mode 100755
index 0000000000..16c695b1f5
--- /dev/null
+++ b/java-checks/src/test/files/checks/DoublePrefixOperatorCheck/DoublePrefixOperatorCheck.java
@@ -0,0 +1,41 @@
+class test1 {
+  int a = 1;
+  boolean flag = true;
+  int hash = 1;
+  int hashCode = 2;
+  
+  boolean flag2 = !!flag;  // Noncompliant  
+  int a1 = ~~~a; // Noncompliant [[sc=12;ec=14]]{{Remove multiple operator prefixes.}}
+
+  boolean flag3 = !!!flag; // Noncompliant
+
+  boolean flag4 = !!!foo(); // Noncompliant [[sc=19;ec=21]]
+
+  boolean flag5 = !(!flag4); // Noncompliant [[sc=19;ec=22]] {{Remove multiple operator prefixes.}}
+
+  int c = ~(~(~a3));    // Noncompliant [[sc=11;ec=14]] {{Remove multiple operator prefixes.}}
+  
+  boolean flag6 = !(!(!flag4)); // Noncompliant [[sc=19;ec=22]] {{Remove multiple operator prefixes.}}
+  
+  int a3 =  - - -a2;  // Noncompliant [[sc=13;ec=16]] 
+  
+  int a4 =  - -a2;  // Noncompliant [[sc=13;ec=16]]
+  
+  int a5 =  + + +a2;  // Noncompliant [[sc=13;ec=16]]
+  
+  int a6 =  + +a2;  // Noncompliant [[sc=13;ec=16]]
+  
+  int a2 = ~~a; // Compliant
+  
+  int a9 = ~(~a); // Compliant
+  
+  int a10 = ~(~(a9 - 9));  // Compliant
+  
+  int a7 = --a2;  // Compliant
+  int a8 = ++a2;  // Compliant
+  boolean flag1 = !flag4;  // Compliant
+  int b = ~a1;  // Compliant
+  boolean flag7 = !foo(); // Compliant
+  int h1 = ~~hash; // Compliant
+  int h2 = ~~hashCodep; // Compliant
+}
\ No newline at end of file
diff --git a/java-checks/src/test/files/checks/EmptyStatementUsageCheck.java b/java-checks/src/test/files/checks/EmptyStatementUsageCheck.java
index a09143c2e6..8a3c8167dc 100755
--- a/java-checks/src/test/files/checks/EmptyStatementUsageCheck.java
+++ b/java-checks/src/test/files/checks/EmptyStatementUsageCheck.java
@@ -18,7 +18,7 @@ public Foo() {
 
   void foo(boolean condition) {
     for (int i = 0; i < 42; i++)
-      ; // Noncompliant {{Remove this empty statement.}}
+      ; // compliant unique statement of a loop
     int i = 0;; // Noncompliant {{Remove this empty statement.}}
     ; // Noncompliant {{Remove this empty statement.}}
 
@@ -40,13 +40,13 @@ void foo(boolean condition) {
 
     class myInnerClass {}; // Noncompliant {{Remove this empty statement.}}
 
-    do ; while (condition); // Noncompliant {{Remove this empty statement.}}
+    do ; while (condition); // compliant
 
     while (condition)
-      ; // Noncompliant {{Remove this empty statement.}}
+      ; // compliant
 
     for (Object object : getCollection())
-      ; // Noncompliant {{Remove this empty statement.}}
+      ; // compliant
     
     return; // Compliant
   }
diff --git a/java-checks/src/test/files/checks/EqualsParametersMarkedNonNullCheck.java b/java-checks/src/test/files/checks/EqualsParametersMarkedNonNullCheck.java
new file mode 100755
index 0000000000..07b5a9f5a5
--- /dev/null
+++ b/java-checks/src/test/files/checks/EqualsParametersMarkedNonNullCheck.java
@@ -0,0 +1,29 @@
+class A{
+  public boolean equals(@javax.annotation.Nonnull Object obj) { // Noncompliant [[sc=25;ec=61]] {{"equals" method parameters should not be marked "@Nonnull".}}
+    return true;
+  }
+}
+
+class B {
+  public boolean equals(Object obj) { // Compliant
+  }
+}
+
+class C {
+  public boolean equal() {}  // Compliant
+
+  public boolean equals(Object a, Object b) {  // Compliant
+  }
+}
+
+class D {
+  public boolean equals(C c) {  // Compliant
+    return false;
+  }
+}
+
+class E {
+  public boolean equals(@javax.annotation.Nonnull C c) {  // Compliant
+    return false;
+  }
+}
diff --git a/java-checks/src/test/files/checks/IdenticalCasesInSwitchCheck.java b/java-checks/src/test/files/checks/IdenticalCasesInSwitchCheck.java
index 5dd61d6d45..adec920e05 100755
--- a/java-checks/src/test/files/checks/IdenticalCasesInSwitchCheck.java
+++ b/java-checks/src/test/files/checks/IdenticalCasesInSwitchCheck.java
@@ -28,12 +28,32 @@ void foo(){
         break;
     }
 
+    switch (1) {
+      case 1:
+        trivial();
+      case 2: // Noncompliant [[secondary=32]]
+        trivial();
+    }
+
+    switch (1) {
+      case 1:
+        trivial();
+        break;
+      case 2: // Noncompliant [[secondary=39]]
+        trivial();
+        break;
+      case 3: // Noncompliant [[secondary=39]]
+        trivial();
+        break;
+    }
+
     switch (1) {
       case 1:
         trivial();
       case 2:
         trivial();
       case 3:
+      default:
     }
 
     switch (1) {
@@ -44,6 +64,7 @@ void foo(){
         trivial();
         break;
       case 3:
+      default:
     }
 
     switch (1) {
@@ -67,7 +88,7 @@ void foo(){
         f(1);
         System.out.println(1);
         break;
-      case 2:
+      case 2: // Noncompliant
         f(1);
         System.out.println(1);
         break;
@@ -111,10 +132,10 @@ void ifStatement() {
       // skip empty blocks
     } else if (true) {
       System.out.println("bar");
-    } else if (true) { // Noncompliant [[sc=22;el=+3;ec=6;secondary=105]] {{This branch's code block is the same as the block for the branch on line 105.}}
+    } else if (true) { // Noncompliant [[sc=22;el=+3;ec=6;secondary=126]] {{This branch's code block is the same as the block for the branch on line 126.}}
       System.out.println("foo");
       System.out.println("foo");
-    } else { // Noncompliant [[sc=12;el=+3;ec=6;secondary=105]] {{This branch's code block is the same as the block for the branch on line 105.}}
+    } else { // Noncompliant [[sc=12;el=+3;ec=6;secondary=126]] {{This branch's code block is the same as the block for the branch on line 126.}}
       System.out.println("foo");
       System.out.println("foo");
     }
@@ -129,11 +150,14 @@ void ifStatement() {
     if (true) f();
     else f();
 
+    if (true) f();
+    else if (true) f(); // Noncompliant [[secondary=153]]
+
     if (true) {
       f();
       f();
     }
-    else if (true) { // Noncompliant [[secondary=132]]
+    else if (true) { // Noncompliant [[secondary=156]]
       f();
       f();
     }
@@ -141,7 +165,7 @@ else if (true) {
       g();
       g();
     }
-    else if (true) {  // Noncompliant [[secondary=140]]
+    else if (true) {  // Noncompliant [[secondary=164]]
       g();
       g();
     }
diff --git a/java-checks/src/test/files/checks/IfElseIfStatementEndsWithElseCheck.java b/java-checks/src/test/files/checks/IfElseIfStatementEndsWithElseCheck.java
new file mode 100755
index 0000000000..8bd5adbece
--- /dev/null
+++ b/java-checks/src/test/files/checks/IfElseIfStatementEndsWithElseCheck.java
@@ -0,0 +1,59 @@
+class A{
+  private static final boolean FALSE = false;
+  private int x = 2;
+
+  void foo() {
+    if (x == 0) {       // Compliant
+    } else if (x == 1) {
+        if(x == 2) { 
+        }
+        else if(x == 3) { // Noncompliant
+          if (x == 5) {  // Compliant
+          }else {
+          }
+        }
+    } else {
+    }
+    if(x == 0) {  
+    }else if( x == 1) { // Noncompliant [[sc=6;ec=13]] {{"if ... else if" constructs should end with "else" clauses.}}
+    }
+
+    if(x==0) {  // Compliant
+    }
+    for(;;){
+      if(x == 10) {  // Compliant
+      }
+      if(x == 11) {  
+      }else if(x == 12){// Noncompliant  [[sc=8;ec=15]] {{"if ... else if" constructs should end with "else" clauses.}}
+      }
+    }
+    if(x == 0) {} // Compliant
+    else {}
+    if(x == 13) { //Compliant 
+    } else {
+      if(x == 14) {  
+      }else if(x == 15) {// Noncompliant  [[sc=8;ec=15]] {{"if ... else if" constructs should end with "else" clauses.}}
+      }
+    }
+    if(x ==16) {
+    }else if(x == 17) {
+    }else if(x == 18) {  // Noncompliant
+    }
+    if(x ==16) {
+    }else if(x == 17) {
+    }else if(x == 18) {  // Compliant
+    }else {}
+    if(x ==16) {
+    }else if(x == 17) {
+    }else if(x == 18) {
+    }else if(x == 19){}  // Noncompliant
+  }
+
+  void foo2(int op) {
+    if (x == 20) {
+    } else {             // Compliant
+        if (x == 21) {
+        }  
+    }
+  }
+}
diff --git a/java-checks/src/test/files/checks/IgnoredOperationStatusCheck.java b/java-checks/src/test/files/checks/IgnoredOperationStatusCheck.java
index 2c8380242e..43660fcfa7 100755
--- a/java-checks/src/test/files/checks/IgnoredOperationStatusCheck.java
+++ b/java-checks/src/test/files/checks/IgnoredOperationStatusCheck.java
@@ -83,8 +83,8 @@ boolean blockingQueueOp(BlockingQueue<String> b, ArrayBlockingQueue<Object> a, L
     b.remove(); // Noncompliant {{Do something with the "String" value returned by "remove".}}
     b.remove(new Object()); // Noncompliant
 
-    b.drainTo(l); // Noncompliant
-    a.drainTo(lo, 42); // Noncompliant
+    b.drainTo(l); // not a status code
+    a.drainTo(lo, 42); // not a status code
 
     a.offer(new Object()); // Noncompliant
     b.offer("hello", 42L, TimeUnit.SECONDS); // Noncompliant
diff --git a/java-checks/src/test/files/checks/LeastSpecificTypeCheck.java b/java-checks/src/test/files/checks/LeastSpecificTypeCheck.java
index 1d8abd184b..4ed4864277 100755
--- a/java-checks/src/test/files/checks/LeastSpecificTypeCheck.java
+++ b/java-checks/src/test/files/checks/LeastSpecificTypeCheck.java
@@ -1,4 +1,7 @@
 import java.util.*;
+import javax.annotation.Resource;
+import javax.inject.Inject;
+import org.springframework.beans.factory.annotation.Autowired;
 
 class A {
 
@@ -26,6 +29,53 @@ public void ignoreStringParams(String s) { // Compliant
     s.charAt(0);
   }
 
+  @Resource
+  public void resourceAnnotatedMethod1(List<Object> list) { // Noncompliant {{Use 'java.util.Collection' here; it is a more general type than 'List'.}}
+    for (Object o : list) {
+      o.toString();
+    }
+  }
+
+  @Inject
+  public void injectAnnotatedMethod1(List<Object> list) { // Noncompliant {{Use 'java.util.Collection' here; it is a more general type than 'List'.}}
+    for (Object o : list) {
+      o.toString();
+    }
+  }
+
+  @Autowired
+  public void autowiredMethod1(List<Object> list) { // Noncompliant {{Use 'java.util.Collection' here; it is a more general type than 'List'.}}
+    for (Object o : list) {
+      o.toString();
+    }
+  }
+
+  @Resource
+  public void resourceAnnotatedMethod2(Collection<Object> list) { // Compliant - since Spring annotated methods cannot take 'Iterable' as argument
+    for (Object o : list) {
+      o.toString();
+    }
+  }
+
+  @Inject
+  public void injectAnnotatedMethod2(Collection<Object> list) { // Compliant - since Spring annotated methods cannot take 'Iterable' as argument
+    for (Object o : list) {
+      o.toString();
+    }
+  }
+
+  @Autowired
+  public void autowiredMethod2(Collection<Object> list) { // Compliant - since Spring annotated methods cannot take 'Iterable' as argument
+    for (Object o : list) {
+      o.toString();
+    }
+  }
+
+  @Autowired
+  public void autowiredMethod3(List<Object> list) { // Compliant - List interface is used in method body
+    list.sort(Comparator.comparingInt(Object::hashCode));
+  }
+
   public static void staticMethod(List<Object> list) { // Noncompliant {{Use 'java.util.Collection' here; it is a more general type than 'List'.}}
     list.size();
   }
@@ -221,5 +271,5 @@ public static void coverage2(PackageClass c) {
   }
 
   public static void primitiveTypesAreIgnored(int i, long l, double d, float f, byte b, short s, char c, boolean boo) { }
-  
+
 }
diff --git a/java-checks/src/test/files/checks/LoggersDeclarationCheck.java b/java-checks/src/test/files/checks/LoggersDeclarationCheck.java
index d768a68d3d..97a9f0bd9d 100755
--- a/java-checks/src/test/files/checks/LoggersDeclarationCheck.java
+++ b/java-checks/src/test/files/checks/LoggersDeclarationCheck.java
@@ -27,4 +27,7 @@ public A() {
   
   private void logExclusions(String[] exclusions, Logger logger) { // Compliant
   }
+
+  protected final org.slf4j.Logger logger; // Noncompliant
+ 
 }
diff --git a/java-checks/src/test/files/checks/UnconditionalJumpStatementCheck.java b/java-checks/src/test/files/checks/LoopExecutingAtMostOnceCheck.java
similarity index 87%
rename from java-checks/src/test/files/checks/UnconditionalJumpStatementCheck.java
rename to java-checks/src/test/files/checks/LoopExecutingAtMostOnceCheck.java
index e92a75d468..829a46180a 100755
--- a/java-checks/src/test/files/checks/UnconditionalJumpStatementCheck.java
+++ b/java-checks/src/test/files/checks/LoopExecutingAtMostOnceCheck.java
@@ -6,13 +6,6 @@ void m1() {
     }
   }
 
-  void m2() {
-    forLabel: for (int i = 0; i < 10; ++i) {
-      foo();
-      continue forLabel;  // Noncompliant {{Remove this "continue" statement or make it conditional.}}
-    }
-  }
-
   void m3() throws Exception {
     int i = 0;
     while (i++ < 10) {
@@ -32,7 +25,7 @@ void m4() {
   void m5(java.util.List<Object> myList) {
     for (Object object : myList) {
       foo(object);
-      continue; // Noncompliant {{Remove this "continue" statement or make it conditional.}}
+      continue;
     }
   }
 
@@ -149,7 +142,7 @@ void qix() throws Exception {
 
     while(foo()) {
       bar();
-      continue; // Noncompliant
+      continue;
     }
 
     while(foo()) {
@@ -178,11 +171,6 @@ void gul(java.util.List<Object> myList) {
       break; // Noncompliant
     }
 
-    for (Object o : myList) {
-      foo();
-      continue; // Noncompliant
-    }
-
     while(foo()) {
       if (baz()) {
         break;
@@ -199,14 +187,6 @@ void gul(java.util.List<Object> myList) {
       break; // Compliant - the loop can execute more than once
     }
 
-    while(foo()) {
-      if (baz()) {
-        continue;
-      }
-      baz();
-      continue; // Noncompliant
-    }
-
     for (int i = 0; foo(); i++) {
       if (baz()) {
         continue;
@@ -220,10 +200,6 @@ void gul(java.util.List<Object> myList) {
       break; // Noncompliant
     }
 
-    for (int i = 0; foo(); i++) {
-      baz();
-      continue; // Noncompliant
-    }
   }
 
   private static boolean baz() { return false; }
@@ -248,15 +224,6 @@ String m2(java.util.Enumeration<String> e) {
     return null;
   }
 
-  String m3(java.util.Enumeration<String> e) {
-    String s = null;
-    while(e.hasMoreElements()) {
-      s = e.nextElement();
-      continue; // Noncompliant - continue statement is always wrong here
-    }
-    return s;
-  }
-
   void m4() {
     while(true) {
       if (isItTrue()) {
diff --git a/java-checks/src/test/files/checks/MethodParametersOrderCheck.java b/java-checks/src/test/files/checks/MethodParametersOrderCheck.java
new file mode 100755
index 0000000000..72a14c36c1
--- /dev/null
+++ b/java-checks/src/test/files/checks/MethodParametersOrderCheck.java
@@ -0,0 +1,130 @@
+class A {
+  int a;
+
+  public double divide(int divisor, int dividend) {
+    return divisor / dividend;
+  }
+
+  public void alpha(int a) {
+  }
+  public void beta(Unknown e, String b) {
+  }
+  
+  public void doTheThing() {
+    Unknown u, A;
+    alpha(u);
+    alpha(A);
+    int divisor = 15;
+    int dividend = 5;
+    double result = divide(dividend, divisor); // Noncompliant [[sc=27;ec=46;secondary=4,4]] {{Parameters to divide have the same names but not the same order as the method arguments.}}
+    double result1 = divide(new B().alpha, divisor); // Compliant
+    double result2 = divide(new B().dividend, divisor); // Noncompliant [[sc=28;ec=55;secondary=4,4]] {{Parameters to divide have the same names but not the same order as the method arguments.}}
+    Unknown e;
+    String b ="";
+    beta(e, b);   // Compliant
+    beta(b, e);    // Compliant
+    beta(a,b); // Compliant
+    // coverage
+
+    alpha(divisor); // Compliant
+    alpha(e);   // Compliant
+    int a = 2;
+    alpha(a); // Compliant
+  }
+
+  public void doTheThing2() {
+    int divisor = 15;
+    int dividend = 5;
+    double result = divide(divisor, dividend); // Compliant
+    foo(dividend); // Compliant
+  }
+
+  int fun() {
+    return 0;
+  }
+
+  void test(int parameter1, int parameter2) {
+    int divisOr = 15;
+    int dividend = 5;
+    String a = "1", b = "2";
+    double result = divide(dividend, divisOr); // Noncompliant {{Parameters to divide have the same names but not the same order as the method arguments.}}
+
+    result = divide(divisOr, dividend); // Compliant
+    result = divide(parameter1, parameter2); // Compliant
+    result = divide(fun(), dividend); // Compliant
+
+    // coverage
+    fun();
+
+    // in the cases below we expect them not to raise an issue, because java.util.Objects.equals is declared in a different file
+    // even though equals is defined: java.util.Objects.equals(a, b);
+    java.util.Objects.equals(divisOr, dividend); // Compliant
+    java.util.Objects.equals(b, a); // Compliant
+  }
+
+  private void insert(Integer entry, Integer oldEntryForKey) {
+  }
+
+  private void foo(int a) {
+  }
+
+  public void test1() {
+    int a = 0, b = 1;
+    int newEntry = 0;
+    int oldEntryForKey = 0;
+    int entry = 0;
+    insert(newEntry, oldEntryForKey); // Compliant
+    insert(entry, entry); // Compliant
+    new B().test2(newEntry, entry); // Compliant
+    new B().test2(a, b); // Compliant
+    new B().test2(b, a); // Noncompliant
+    new B().test2(a, b, entry); // Compliant
+  }
+
+  public void foo2() {
+    int b = 0;
+    String a = "";
+    new B().test2(b, a); // Compliant
+  }
+}
+
+class B {
+  int alpha = 0, dividend = 1;
+  String b = "";
+  Integer upperBound = 0;
+
+  public void test2(int a, int b) {
+  };
+
+  public void test2(int a, int b, int c) {
+  };
+
+  public void test2(int a, String b) {
+  };
+
+  public void test2(int a, Object b, Object c, int d) {
+  };
+
+  public void test2(int a, Object b, String c, int d) {
+  }
+
+  public void foo(String a, int b) {
+    test2(b, a); // Compliant
+    test2(new A().a, new B().b); // Compliant
+  }
+
+  private void strange(Integer lowerBound, Integer upperBound, String value) {
+  }
+
+  void foo2(int a, int d) {
+    test2(d, toString(), toString(), a); // Noncompliant
+    test2(d, toString(), a, 6); // Noncompliant
+    test2(d, toString(), a, Integer.parseInt(toString())); // Noncompliant
+    test2(d, 0, a, 1); // Noncompliant
+    int c = 1;
+    String A = ((Integer) a).toString();
+    test2(d, null, A, Integer.parseInt(new B().b)); // Compliant -- because b is int not Object
+    strange(new B().upperBound, Integer.valueOf(0), A); // Compliant
+    strange(new B().upperBound, Integer.valueOf(0), null); // Compliant if only 1 argument matches a parameter in a different position
+  }
+}
diff --git a/java-checks/src/test/files/checks/NestedSwitchStatementCheck.java b/java-checks/src/test/files/checks/NestedSwitchStatementCheck.java
new file mode 100755
index 0000000000..8a8962be53
--- /dev/null
+++ b/java-checks/src/test/files/checks/NestedSwitchStatementCheck.java
@@ -0,0 +1,124 @@
+import java.util.List;
+
+class A{
+  void foo() {
+    int myVar = 0;
+    switch (myVar) {  // Compliant
+      case 0:
+        switch (0) {  // Noncompliant
+          case 0:
+          case 1:
+            System.out.println();
+            switch (1){ // Noncompliant [[sc=13;ec=19;el=+0]] {{Refactor the code to eliminate this nested "switch".}}
+              case 0:
+              case 1:
+                break;
+            }
+          case 2:
+            break;
+        }
+      case 1:
+        switch (2) { // Noncompliant
+          case 0:
+          case 1: 
+            switch (3) { // Noncompliant {{Refactor the code to eliminate this nested "switch".}}
+              case 0: 
+                System.out.println();
+              case 1:
+                break;
+            }
+            break;
+          case 2: 
+            break;
+        }
+        break;
+      case 2: 
+        break;
+      default:{
+        switch(4) {  // Noncompliant
+          case 0:
+            switch(5) { // Noncompliant
+              default:
+                break;
+            } 
+            break;
+          case 1: {
+            switch (6) {  // Noncompliant
+              case 0:
+                break;
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+class B{
+  List<Integer> list;
+  void foo2() {
+    int i = 0;
+    switch(i) {  // Compliant
+      case 1:
+        break;
+      case 2: {
+        for(;i<3;i++) {
+          switch(i) { // Noncompliant
+            case 0:
+              break;
+            case 2:{
+              new Thread() {
+                public void run() {
+                  System.out.println();
+                  int i = 0;
+                  switch(i) {  // Compliant
+                    case 0: 
+                      break;
+                    case 1:
+                      break;
+                  }
+                }
+              }.start();
+              break;
+            }
+            case 3:
+              list.stream().filter(x -> {
+                switch(x) {  // Compliant 
+                  case 0:
+                    return true;
+                  case 1:
+                    return false;
+                }
+              });
+              break;
+            default:
+              break;
+          }
+        }
+      }
+    }
+  }
+  void foo3(int i) {
+    switch (i) {
+      case 0:
+      case 42:
+        class B { // nested class
+          void bar(int j) {
+            switch (j) { // Compliant
+              case 42:
+                System.out.println("");
+                break;
+              case 0:
+                break;
+              default:
+                break;
+            }
+          }
+        }
+        new B().bar(i);
+        break;
+      default:
+        break;
+    }
+  }
+}
diff --git a/java-checks/src/test/files/checks/NullCheckWithInstanceofCheck.java b/java-checks/src/test/files/checks/NullCheckWithInstanceofCheck.java
new file mode 100755
index 0000000000..ddb564819c
--- /dev/null
+++ b/java-checks/src/test/files/checks/NullCheckWithInstanceofCheck.java
@@ -0,0 +1,70 @@
+import java.util.Map;
+import java.util.Map.Entry;
+
+class A {
+  private Integer a = 0;
+  Object c = new A();
+
+  private A getObject(A a) {
+    return a;
+  }
+
+  void foo1(Object x) {
+    if (x != null && x instanceof A) { // Noncompliant [[sc=9;ec=18]] {{Remove this unnecessary null check; "instanceof" returns false for nulls.}}
+    }
+    if (x instanceof A) { // Compliant
+    }
+    if (x == null || !(x instanceof A)) { // Noncompliant {{Remove this unnecessary null check; "instanceof" returns false for nulls.}}
+    }
+    if (x instanceof A || x == null) { // Compliant
+    }
+    if (!(x instanceof A) || x == null) { // Noncompliant [[sc=30;ec=39]] {{Remove this unnecessary null check; "instanceof" returns false for nulls.}}
+    }
+    if (getObject((A) c) instanceof A) { // Compliant
+    }
+    if (getObject((A) c) instanceof A && getObject((A) c) != null) { // Noncompliant
+    }
+
+    // coverage
+    A alpha = new A();
+    if (alpha.a != null && !(alpha instanceof A)) { // Compliant
+    }
+    if (alpha.a == null && (alpha instanceof A)) { // Compliant
+    }
+    if (alpha.a == 1 && (alpha instanceof A)) { // Compliant
+    }
+  }
+
+  void foo2(A a) {
+    if (a.c == null || a.c instanceof A) { // Compliant
+    } else if (a.c != null) { // Compliant
+    } else if (a != null && a.c instanceof A) { // Compliant
+    } else if (null != a && a instanceof A) { // Noncompliant
+    } else if (null == a || !(a instanceof A)) { // Noncompliant [[sc=16;ec=25]] {{Remove this unnecessary null check; "instanceof" returns false for nulls.}}
+    } else if (a.c != null && a.c instanceof A) { // Noncompliant
+    }
+    while (a != null && a instanceof A) { // Noncompliant
+      // ...
+    }
+  }
+
+  void foo3(A a) {
+    new Thread() {
+      public void run() {
+        if (a != null && a instanceof A) { // Noncompliant
+          System.out.println("blah");
+        }
+      }
+    }.start();
+  }
+
+  public boolean foo4(Object obj) {
+    if (obj instanceof Entry) {
+      Entry<?, ?> entry = (Entry<?, ?>) obj;
+      return entry.getKey() != null // Compliant
+        && entry.getValue() instanceof Map
+        && entry.toString() != null;
+    }
+    return false;
+  }
+}
diff --git a/java-checks/src/test/files/checks/PrintfFailCheck.java b/java-checks/src/test/files/checks/PrintfFailCheck.java
index e360be8234..12b839fe16 100755
--- a/java-checks/src/test/files/checks/PrintfFailCheck.java
+++ b/java-checks/src/test/files/checks/PrintfFailCheck.java
@@ -184,3 +184,16 @@ void foo(Calendar c){
     slf4jLog.warn("The resource for is not found, drilling down to the details of this test won't be possible");
   }
 }
+
+class UsingLambda {
+
+  private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(UsingLambda.class);
+
+  void start(int port) {
+
+    unknown((a, b) -> {
+      LOG.info(a.foo());
+    });
+
+  }
+}
diff --git a/java-checks/src/test/files/checks/PrintfMisuseCheck.java b/java-checks/src/test/files/checks/PrintfMisuseCheck.java
index 2da10637ea..274c7f02e8 100755
--- a/java-checks/src/test/files/checks/PrintfMisuseCheck.java
+++ b/java-checks/src/test/files/checks/PrintfMisuseCheck.java
@@ -175,6 +175,18 @@ void foo(Calendar c){
     slf4jLog.warn("message ", 1); // Noncompliant {{String contains no format specifiers.}}
     slf4jLog.warn("message {}", 1);
     slf4jLog.warn("message");
+  }
+}
+
+class UsingLambda {
+
+  private static final org.slf4j.Logger LOG = org.slf4j.LoggerFactory.getLogger(UsingLambda.class);
+
+  void start(int port) {
+
+    unknown((a, b) -> {
+      LOG.info(a.foo());
+    });
 
   }
 }
diff --git a/java-checks/src/test/files/checks/PublicStaticMutableMembersCheck.java b/java-checks/src/test/files/checks/PublicStaticMutableMembersCheck.java
index 236f3daeb3..d615f38283 100755
--- a/java-checks/src/test/files/checks/PublicStaticMutableMembersCheck.java
+++ b/java-checks/src/test/files/checks/PublicStaticMutableMembersCheck.java
@@ -81,6 +81,14 @@ public static int getDim() {
     put("c", "d");
   }});
 
+  public static final Set<Object> SINGLETON_UNMODIFIABLE_SET = Collections.singleton(new Object());
+  public static final List<Object> SINGLETON_UNMODIFIABLE_LIST = Collections.singletonList(new Object());
+  public static final Map<Object, Object> SINGLETON_UNMODIFIABLE_MAP = Collections.singletonMap(new Object(), new Object());
+
+  public static final Set<Object> EMTPY_SET = Collections.emptySet();
+  public static final List<Object> EMPTY_LIST2 = Collections.emptyList();
+  public static final Map<Object, Object> EMPTY_MAP = Collections.emptyMap();
+
   // guava
   public static final List<String> immutableList = ImmutableList.of("a");
   public static final Set<String> immutableSet = ImmutableSet.of("a");
diff --git a/java-checks/src/test/files/checks/RedundantJumpCheck.java b/java-checks/src/test/files/checks/RedundantJumpCheck.java
new file mode 100755
index 0000000000..e2149e1c35
--- /dev/null
+++ b/java-checks/src/test/files/checks/RedundantJumpCheck.java
@@ -0,0 +1,65 @@
+abstract class A {
+
+  public void loops() {
+
+    while (condition1) {
+      foo();
+      continue; // Noncompliant
+    }
+
+    while (condition1) {
+      foo();
+      break;
+    }
+
+    while (condition1) {
+      if (condition2) {
+        continue; // Noncompliant
+      } else {
+        foo();
+      }
+    }
+  }
+
+  public int return_in_non_void_method() {
+    foo();
+    return 42;
+  }
+
+  public void useless_return() {
+    foo();
+    return; // Noncompliant
+  }
+
+  public void void_method_with_useful_return_without_expression() {
+    if (condition) {
+      return;
+    }
+    foo();
+  }
+
+  public void switch_statements(int param) {
+    switch (param) {
+      case 0:
+        foo();
+        break;
+      default:
+    }
+    foo();
+    switch (param) {
+      case 0:
+        foo();
+        return;
+      case 1:
+        bar();
+        return;
+    }
+  }
+
+  public void throwing_exception() {
+    throw new UnsupportedOperationException();
+  }
+
+  public abstract void abstract_method();
+
+}
diff --git a/java-checks/src/test/files/checks/RedundantThrowsDeclaration.java b/java-checks/src/test/files/checks/RedundantThrowsDeclaration.java
index c9f38ba6b0..12d096347a 100755
--- a/java-checks/src/test/files/checks/RedundantThrowsDeclaration.java
+++ b/java-checks/src/test/files/checks/RedundantThrowsDeclaration.java
@@ -208,3 +208,78 @@ default Object qix(Object o) throws MyException, MyException { // Noncompliant
 class MyException extends Exception {}
 class MyError extends Error {}
 class MyRuntimeException extends RuntimeException {}
+class MyException2 extends Exception {}
+
+abstract class NonThrownExceptionClass {
+  abstract void bar();
+
+  final class FinalClass {
+
+    /**
+     * @throws MyException proper javadoc description
+     */
+    void nonOverrideableMethod() throws MyException { // Noncompliant {{Remove the declaration of thrown exception 'MyException', as it cannot be thrown from method's body.}}
+      bar();
+    }
+  }
+
+  class NormalClass {
+    /**
+     * @exception MyException proper javadoc description
+     */
+    private void nonOverrideableMethod1() throws MyException { // Noncompliant {{Remove the declaration of thrown exception 'MyException', as it cannot be thrown from method's body.}}
+      bar();
+    }
+
+    /**
+     * @throws MyException proper javadoc description
+     */
+    static void nonOverrideableMethod2() throws MyException { // Noncompliant {{Remove the declaration of thrown exception 'MyException', as it cannot be thrown from method's body.}}
+      bar();
+    }
+
+    /**
+     * @throws MyException proper javadoc description
+     */
+    final void nonOverrideableMethod3() throws MyException { // Noncompliant {{Remove the declaration of thrown exception 'MyException', as it cannot be thrown from method's body.}}
+      bar();
+    }
+
+    /**
+     * @throws MyException proper javadoc description
+     */
+    void overrideableMethod1() throws MyException { // Compliant : can be overridden and has javadoc associated
+      bar();
+    }
+
+    /**
+     * @throws MyException proper javadoc description
+     */
+    protected void overrideableMethod2() throws MyException { // Compliant : can be overridden and has javadoc associated
+      bar();
+    }
+
+    /**
+     * @exception MyException proper javadoc description
+     */
+    public void overrideableMethod3() throws MyException { // Compliant : can be overridden and has javadoc associated
+      bar();
+    }
+
+    /**
+     * Overridable method but javadoc for exception is missing proper description
+     * @exception MyException
+     */
+    public void overrideableMethod4() throws MyException { // Noncompliant
+      bar();
+    }
+
+    /**
+     * @exception MyException proper javadoc description
+     * @throws  MyException2 proper javadoc description
+     */
+    public void missingJavadocForException() throws MyException, MyException2, java.io.IOException { // Noncompliant {{Remove the declaration of thrown exception 'java.io.IOException', as it cannot be thrown from method's body.}}
+      bar();
+    }
+  }
+}
\ No newline at end of file
diff --git a/java-checks/src/test/files/checks/RedundantTypeCastCheck.java b/java-checks/src/test/files/checks/RedundantTypeCastCheck.java
index 1cc3ce4fcc..452d97a3c8 100755
--- a/java-checks/src/test/files/checks/RedundantTypeCastCheck.java
+++ b/java-checks/src/test/files/checks/RedundantTypeCastCheck.java
@@ -1,6 +1,8 @@
+import java.util.function.Predicate;
 import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Comparator;
 import java.util.Set;
 
@@ -36,9 +38,9 @@
     int c = (int)a; // Noncompliant {{Remove this unnecessary cast to "int".}}
     int e = (int) d;
   }
-  
+
   void foo(List<List<A>> a) {}
-  
+
   List<List<B>> foo2() {
     return null;
   }
@@ -176,6 +178,93 @@ void fun() {
   }
 }
 
+interface J {
+  default void foo() { }
+  default void bar() { }
+
+  interface K extends J {
+    void foo();
+  }
+
+  interface L extends J {
+    void foobar();
+  }
+
+  static void test() {
+    J j1 = (K) () -> { }; // compliant : cast is needed for it to be used as a lambda expression
+    J j2 = (L) () -> { }; // compliant : cast is needed for it to be used as a lambda expression
+  }
+}
+
+interface M {
+  default void foo() { }
+  default void bar() { }
+  void foobar();
+
+  interface N extends M {
+    default void foobar() { }
+    void foo();
+  }
+
+  interface O extends M { }
+
+  interface P extends M {
+    void foobar();
+  }
+
+  interface Q extends M {
+    default void foo() { }
+  }
+
+  static void test() {
+    M m1 = () -> { };
+    M m2 = (M) () -> { }; // Noncompliant {{Remove this unnecessary cast to "M".}}
+    M m3 = (N) () -> { }; // compliant : cast changes method associated to lambda expression
+    M m4 = (O) () -> { }; // Noncompliant {{Remove this unnecessary cast to "O".}}
+    M m5 = (P) () -> { }; // Noncompliant {{Remove this unnecessary cast to "P".}}
+    M m6 = (Q) () -> { }; // compliant : cast changes default definition of method foo
+  }
+}
+
+interface R {
+  void foo();
+  void bar();
+
+  interface S extends R {
+    default void foo();
+  }
+
+  static void test() {
+    R r1 = (S) () -> {  }; // compliant : cast is needed for it to be used as a lambda expression
+  }
+}
+
+class T {
+  Predicate<Object> methodReferenceCastNeeded() {
+    return ((Predicate<Object>) Objects::nonNull).negate(); // Compliant : cannot call Predicate#negate() without casting it first
+  }
+
+  Comparator<Integer> methodReferenceCastNeeded2() {
+    return (((Comparator<Integer>) Integer::compare)).reversed();   // Compliant : cannot call Comparator#reversed() without casting it first
+  }
+
+  Predicate<Object> methodReferenceCastNotNeeded() {
+    return (((Predicate<Object>) Objects::nonNull)); // Noncompliant
+  }
+
+  Comparator<Integer> methodReferenceCastNotNeeded2() {
+    return (Comparator<Integer>) Integer::compare; // Noncompliant
+  }
+}
+
+interface U<A extends Iterable> {
+  A foo(A param);
+
+  default void test() {
+    U u1 = (U<List>) (param) -> param.subList(0,1); // Compliant : cast needed to access sublist method
+  }
+}
+
 abstract class MyClass {
   public String field;
   abstract <U extends MyClass> U foo();
diff --git a/java-checks/src/test/files/checks/RegexPatternsNeedlesslyCheck.java b/java-checks/src/test/files/checks/RegexPatternsNeedlesslyCheck.java
new file mode 100755
index 0000000000..b9b5db7303
--- /dev/null
+++ b/java-checks/src/test/files/checks/RegexPatternsNeedlesslyCheck.java
@@ -0,0 +1,77 @@
+import java.util.regex.Pattern;
+
+class A {
+
+  private static final String STRCONST = "constant";
+  private final String finalField = "";
+  private static String staticNotFinal = "";
+
+  private static final Pattern myRegex = Pattern.compile("myRegex"); // Compliant
+  private static final Pattern myRegex1 = ((Pattern.compile("myRegex"))); // Compliant
+  private static final Pattern myRegex2;
+  private final Pattern myRegex3 = Pattern.compile("myRegex"); // Noncompliant
+  private static Pattern myRegex4 = Pattern.compile("myRegex"); // Noncompliant
+  private static final boolean bool1 = "".matches("myRegex2"); // Compliant
+  private static final String str1 = "".replaceFirst("a", "b"); // Compliant
+  private static final String str2 = "".replaceAll("a", "b"); // Compliant
+
+  static {
+    myRegex2 = ((Pattern.compile("myRegex"))); // Compliant
+  }
+
+  void foo(String param) {
+    Pattern regex = Pattern.compile("regex1"); // Noncompliant {{Refactor this code to use a "static final" Pattern.}}
+    Pattern.compile(STRCONST); // Noncompliant
+    Pattern.compile(param);
+    Pattern.compile(finalField); // Compliant
+    Pattern.compile(staticNotFinal); // Compliant
+    Pattern.compile(A.STRCONST); // Noncompliant
+    Pattern.compile(this.finalField); // Compliant
+    Pattern.compile(A.staticNotFinal); // Compliant
+    Pattern regex3 = Pattern.compile(param); // Compliant
+    Pattern regex4 = Pattern.compile(param.toString()); // Compliant
+
+    param.matches(param); // Compliant
+    param.matches("myRegex2"); // Noncompliant
+    param.matches(STRCONST); // Noncompliant
+    param.matches(A.STRCONST); // Noncompliant
+    param.matches(finalField); // Compliant
+    param.matches(staticNotFinal); // Compliant
+
+    param.replaceFirst("a", "b"); // Noncompliant
+    param.replaceFirst(STRCONST, "b"); // Noncompliant
+    param.replaceFirst(finalField, " "); // Compliant
+    param.replaceFirst(staticNotFinal, " "); // Compliant
+
+    param.replaceAll("a", " "); // Noncompliant
+    param.replaceAll(STRCONST, "b"); // Noncompliant
+    param.replaceAll(finalField, " "); // Compliant
+    param.replaceAll(staticNotFinal, " "); // Compliant
+
+    param.split("aa"); // Noncompliant
+    param.split(STRCONST); // Noncompliant
+    param.split(finalField); // Compliant
+    param.split(staticNotFinal); // Compliant
+
+    // RegEx metacharacters
+    param.split("$"); // Noncompliant
+    param.split("*"); // Noncompliant
+    param.split("."); // Noncompliant
+    param.split("a"); // Compliant not included in meta characters
+
+    param.split("\2"); // Noncompliant
+    param.split("\\"); // Compliant
+    param.split("/a"); // Noncompliant
+    param.split("\\a"); // Noncompliant
+
+    param.split("\\a"); // Noncompliant
+    param.split("\\2"); // Noncompliant
+    param.split("\\-"); // Noncompliant
+    param.split("\\*"); // Compliant    * is a metacharacter
+    param.split("\\."); // Compliant
+    param.split("\\|"); // Compliant
+    param.split("\\\\"); // Compliant
+    param.split("//++"); // Noncompliant
+    param.split("\\?q"); // Noncompliant
+  }
+}
diff --git a/java-checks/src/test/files/checks/SQLInjection.java b/java-checks/src/test/files/checks/SQLInjection.java
index ee7acde10e..c3043154cb 100755
--- a/java-checks/src/test/files/checks/SQLInjection.java
+++ b/java-checks/src/test/files/checks/SQLInjection.java
@@ -152,3 +152,19 @@ public void foo() {
     }
   }
 }
+
+class B {
+
+  private String user;
+  private JdbcTemplate tmpl = new JdbcTemplate();
+
+  private void foo() {
+    // field accessed with "this."
+    tmpl.batchUpdate(this.user); // Compliant
+    tmpl.queryForObject(this.user, String.class); // Compliant
+
+    // field accessed without "this."
+    tmpl.batchUpdate(user); // compliant
+    tmpl.queryForObject(user, String.class); // compliant
+  }
+}
diff --git a/java-checks/src/test/files/checks/StringPrimitiveConstructorCheck.java b/java-checks/src/test/files/checks/StringPrimitiveConstructorCheck.java
index 237f9c95ee..23ac2fec8b 100755
--- a/java-checks/src/test/files/checks/StringPrimitiveConstructorCheck.java
+++ b/java-checks/src/test/files/checks/StringPrimitiveConstructorCheck.java
@@ -1,7 +1,9 @@
+import java.math.BigDecimal;
+import java.math.BigInteger;
+
 class A {
 
   void bar(char[] chars) {
-
     String empty = new String(); // Noncompliant [[sc=24;ec=30]] {{Remove this "String" constructor}}
     String nonempty = new String("Hello world"); // Noncompliant
     nonempty = new String(chars);
@@ -14,6 +16,9 @@ void bar(char[] chars) {
     Short myShort = new Short((short) 0); // Noncompliant [[sc=25;ec=30]] {{Remove this "Short" constructor}}
     Float myFloat = new Float(1.0f); // Noncompliant [[sc=25;ec=30]] {{Remove this "Float" constructor}}
     byte b = 0;
+    BigInteger existingBigInteger = new BigInteger("1"); // Noncompliant {{Remove this "BigInteger" constructor}}
+    BigDecimal doubleBigDecimal = new BigDecimal(1.1); // Noncompliant {{Remove this "BigDecimal" constructor}}
+    BigDecimal stringBigDecimal = new BigDecimal("1.1");
   }
 
   void foo() {
@@ -22,5 +27,7 @@ void foo() {
     Double myDouble = Double.valueOf(1.1);
     Integer integer = Integer.valueOf(1);
     Boolean bool = Boolean.valueOf(true);
+    BigInteger existingBigInteger = BigInteger.valueOf(1);
+    BigDecimal doubleBigDecimal = BigDecimal.valueOf(1.1);
   }
-}
\ No newline at end of file
+}
diff --git a/java-checks/src/test/files/checks/SwitchDefaultLastCaseCheck.java b/java-checks/src/test/files/checks/SwitchDefaultLastCaseCheck.java
new file mode 100755
index 0000000000..8d6bd9f1f5
--- /dev/null
+++ b/java-checks/src/test/files/checks/SwitchDefaultLastCaseCheck.java
@@ -0,0 +1,59 @@
+class A {
+
+  void foo() {
+    switch (0) {
+      case 0:
+      default: // Noncompliant [[sc=7;ec=15]] {{Move this default to the end of the switch.}}
+        break;
+      case 1:
+        break;
+    }
+
+    switch (0) {
+      case 0: // Compliant
+        break;
+    }
+
+    switch (0) {
+      default: // Compliant
+        break;
+    }
+
+    switch (0) {
+      case 0:
+        break;
+      default: // Noncompliant
+        break;
+      case 1:
+        break;
+    }
+
+    switch (0) {
+      default: // Compliant
+      case 0:
+        break;
+      case 1:
+        break;
+    }
+
+    switch (0) {
+      default: // Noncompliant
+        break;
+      case 0:
+        break;
+      case 1:
+        break;
+    }
+    
+    switch (0) {
+      case 0:
+        break;
+      case 1:
+        break;
+      case 2:
+      default:  // Compliant default does not affect the normal execution of the switch, as it requires to match 3
+      case 3:
+        break;
+    }
+  }
+}
diff --git a/java-checks/src/test/files/checks/SwitchLastCaseIsDefaultCheck.java b/java-checks/src/test/files/checks/SwitchLastCaseIsDefaultCheck.java
index 38cb760a9d..63be3c2762 100755
--- a/java-checks/src/test/files/checks/SwitchLastCaseIsDefaultCheck.java
+++ b/java-checks/src/test/files/checks/SwitchLastCaseIsDefaultCheck.java
@@ -13,11 +13,6 @@ void foo(MyEnum myEnum, DayOfWeek dow) {
       default:
     }
 
-    switch (0) {
-      default:   // Noncompliant [[sc=7;ec=15]] {{Move this default to the end of the switch.}}
-      case 0:
-    }
-
     switch (myEnum) { // Noncompliant {{Complete cases by adding the missing enum constants or add a default case to this switch.}}
       case A:
         break;
diff --git a/java-checks/src/test/files/checks/ThisExposedFromConstructorCheck.java b/java-checks/src/test/files/checks/ThisExposedFromConstructorCheck.java
new file mode 100755
index 0000000000..ceac52a9d8
--- /dev/null
+++ b/java-checks/src/test/files/checks/ThisExposedFromConstructorCheck.java
@@ -0,0 +1,82 @@
+import java.util.List;
+
+class A{
+  private static final List<A> list;
+  private String location;
+  private static String loc;
+  private static A tempVal;
+  public A Instance;
+  private B Instance2;
+  
+  public A(String location) {
+    list.add(this);  // Noncompliant [sc=16;ec=20] {{Make sure the use of "this" doesn't expose partially-constructed instances of this class in multi-threaded environments.}}
+    foo(this);  // Compliant
+    this.location = location; // Compliant
+    this.tempVal = this;  // Compliant
+    Instance = this;  // Noncompliant
+    this.Instance = this; // Noncompliant
+    tempVal = this;  // Compliant
+    this.loc = "loc"; // Compliant
+    foo(Instance2.foo3(this)); // Noncompliant  
+    this.Instance2.foo(this); // Noncompliant
+    this.Instance.foo3(this.Instance2.foo(this)); // Noncompliant
+    this.tempVal = Instance.foo(this);  // Compliant
+    this.Instance2 = this;  // Noncompliant
+  }
+
+  public A() {
+    this.location = ""; // Compliant
+    foo2(this);  // Noncompliant
+    foo2(); // Compliant
+    foo3(); //  Compliant
+    foo1(new A());  // Compliant
+    B.foo2();  // Compliant
+    B.foo1(this);  // Noncompliant
+    B.field = this;  // Noncompliant
+    B.field3 = this; // Noncompliant
+    this.Instance2.foo3(this); // Noncompliant
+    this.foo3(this);  // Compliant
+    this.Instance = (this); // Noncompliant
+    this.tempVal = (this); // Compliant
+  }
+  
+  public void foo(A a) {}
+  
+  private void foo2() {
+    list.add(this);
+  }
+  
+  private void foo3(A a) {
+  }
+  
+}
+
+class B {
+  public static final List<A> list1;
+  public static A field;
+  public A field3;
+  public B field2;
+  public B[] arr1;
+    
+  public B() {
+    this.field2 = this;  // Noncompliant
+    this.field3 = foo2(this);  // Compliant
+    new A() {
+    };
+    new Thread() {
+      public void run() {
+        A a = new A();
+        a.Instance2 = this;  // Compliant
+      }
+    }.start();
+   arr1[0] = this;  // Noncompliant
+  }
+  
+  void foo(A a) {
+  }
+  
+  A foo2(B b) {}
+  
+  public void foo3(A a) {
+  }
+}
diff --git a/java-checks/src/test/files/checks/WeakSSLContextCheck.java b/java-checks/src/test/files/checks/WeakSSLContextCheck.java
new file mode 100755
index 0000000000..93c4e3bb40
--- /dev/null
+++ b/java-checks/src/test/files/checks/WeakSSLContextCheck.java
@@ -0,0 +1,30 @@
+import javax.net.ssl.SSLContext;
+
+class A {
+
+  void foo(String protocol, String provider) {
+    bar(SSLContext.getInstance());
+
+    bar(SSLContext.getInstance(protocol));
+
+    bar(SSLContext.getInstance("SSL")); // Noncompliant
+    bar(SSLContext.getInstance("SSLv2")); // Noncompliant
+    bar(SSLContext.getInstance("SSLv3")); // Noncompliant
+    bar(SSLContext.getInstance("TLS")); // Noncompliant
+    bar(SSLContext.getInstance("TLSv1")); // Noncompliant
+    bar(SSLContext.getInstance("TLSv1.1")); // Noncompliant
+    bar(SSLContext.getInstance("TLSv1.2"));
+    bar(SSLContext.getInstance("DTLS")); // Noncompliant
+    bar(SSLContext.getInstance("DTLSv1.0")); // Noncompliant
+    bar(SSLContext.getInstance("DTLSv1.2"));
+
+    bar(SSLContext.getInstance("SSL", provider)); // Noncompliant
+    bar(SSLContext.getInstance("TLSv1.2", provider));
+    bar(SSLContext.getInstance("TLSv1.2", "SSL"));
+  }
+
+  void bar(SSLContext ctx) {
+    System.out.println(ctx);
+  }
+
+}
diff --git a/java-checks/src/test/files/checks/WrongAssignmentOperatorCheck.java b/java-checks/src/test/files/checks/WrongAssignmentOperatorCheck.java
index b30e441fbd..f39d109a31 100755
--- a/java-checks/src/test/files/checks/WrongAssignmentOperatorCheck.java
+++ b/java-checks/src/test/files/checks/WrongAssignmentOperatorCheck.java
@@ -5,11 +5,17 @@
 
   void fun() {
     target =-num; // Noncompliant {{Was "-=" meant instead?}} [[sc=12;ec=14]]
+    target =
+            -num;
     target = -num; // Compliant intent to assign inverse value of num is clear
     target =--num;
 
     target += num;
     target =+ num; // Noncompliant {{Was "+=" meant instead?}} [[sc=12;ec=14]]
+    target =
+            + num;
+    target =
+            +num;
     target = +num;
     target =++num;
     target=+num; // Compliant - no spaces between variable, operator and expression
@@ -18,5 +24,10 @@ void fun() {
     a = b =! c; // Noncompliant {{Was "!=" meant instead?}} [[sc=11;ec=13]]
     a = b =!! c; // Noncompliant
     a = b = !c;
+    a =! c; // Noncompliant {{Add a space between "=" and "!" to avoid confusion.}}
+    a = ! c;
+    a = !c;
+    a =
+       !c;
   }
 }
diff --git a/java-checks/src/test/files/checks/helpers/JavadocTest.java b/java-checks/src/test/files/checks/helpers/JavadocTest.java
new file mode 100755
index 0000000000..edc8fe39d0
--- /dev/null
+++ b/java-checks/src/test/files/checks/helpers/JavadocTest.java
@@ -0,0 +1,85 @@
+import java.io.IOException;
+
+/**
+ * Some class documentation
+ *
+ * @param <B> description
+ * @param <C> FIXME
+ * @param <D> description non-existing param
+ */
+class A<B, C, E> {
+  /**
+   * Main description
+   * On serveral lines
+   *
+   * @param      a     param 1
+   * @param      b param 2 with some more desc
+   * @param      c
+   * @param      d multilines parameter
+   *               description
+   * @return     return description
+   * @exception  NullPointerException 1st exception description
+   * @throws     IndexOutOfBoundsException second exception
+   * description
+   * @exception  IOException
+   */
+  private int foo(int a, int c, int d, int e) throws java.lang.NullPointerException, IOException, IllegalStateException, B {
+    return 0;
+  }
+
+  /**
+   * @return
+   * return description starts on next line
+   * @return 2nd return description
+   */
+  private int bar(int a) {
+    return 0;
+  }
+
+  /**
+   *
+   * FIXME
+   * @param a .
+   * @param b
+   * @param c ...
+   * @param d TODO
+   * @param e FIXME
+   */
+  private int emptyDescription(int a, int b, int c, int d, int e) throws java.lang.NullPointerException {
+    return 0;
+  }
+
+  /**
+   *
+   * ...
+   *
+   * @param a a
+   * @param b b
+   * @param c c
+   * @param d d
+   * @param e e
+   * @throws java.lang.NullPointerException exception with fully qualified name
+   */
+  private int fullParamsDescription(int a, int b, int c, int d, int e) throws NullPointerException {
+    return 0;
+  }
+
+  /**
+   *
+   * @deprecated
+   *
+   * @throws IOException description is set
+   * @throws java.io.ObjectStreamException TODO
+   * @throws InvalidObjectException ...
+   */
+  private int genericExceptionThrown() throws Exception {
+    return 0;
+  }
+}
+
+/**
+ * TODO
+ */
+class NoDocClass {
+
+}
diff --git a/java-checks/src/test/files/checks/security/HostnameVerifierImplementationCheck.java b/java-checks/src/test/files/checks/security/HostnameVerifierImplementationCheck.java
new file mode 100755
index 0000000000..a1b6b576f9
--- /dev/null
+++ b/java-checks/src/test/files/checks/security/HostnameVerifierImplementationCheck.java
@@ -0,0 +1,88 @@
+import javax.net.ssl.HostnameVerifier;
+import javax.net.ssl.SSLSession;
+
+class A {
+  private B b;
+
+  A(B b) {
+    this.b = b;
+  }
+
+  void method1() {
+    b.method(new HostnameVerifier() {
+      @Override
+      public boolean verify(String a, SSLSession b) {
+        return true; // Noncompliant {{Do not unconditionally return true in this method.}}
+      }
+    });
+    b.method(new HostnameVerifier() {
+      @Override
+      public boolean verify(String a, SSLSession b) {
+        return a.equalsIgnoreCase(b.getPeerHost());
+      }
+    });
+  }
+
+  void method2() {
+    BiFunction<String, SSLSession, Boolean> lambda = (a, b) -> true;
+    b.method((a, b) -> true); // Noncompliant
+    b.method((a, b) -> (((true)))); // Noncompliant
+    b.method((a, b) -> a.equalsIgnoreCase(b.getPeerHost()));
+    b.method(lambda);
+  }
+
+  void method4() {
+    b.method((a, b) -> {
+      return true; // Noncompliant
+    });
+    b.method((a, b) -> {
+      return (((true))); // Noncompliant
+    });
+    b.method((a, b) -> {
+      return false;
+    });
+    b.method((a, b) -> {
+      boolean returnValue = true;
+      return returnValue;
+    });
+  }
+}
+
+class B {
+  void method(HostnameVerifier hostnameVerifier) {
+    this.hostnameVerifier = hostnameVerifier;
+  }
+}
+
+class C implements HostnameVerifier {
+  public boolean verify(String a, SSLSession b) {
+    return true; // Noncompliant
+  }
+}
+
+class D implements HostnameVerifier {
+  public boolean verify(String a, SSLSession b) {
+    return a.equals("");
+  }
+}
+
+class E implements HostnameVerifier {
+  public boolean verify(String a, SSLSession b) {
+    {
+      {
+        return true; // Noncompliant
+      }
+    }
+  }
+}
+
+class F implements HostnameVerifier {
+  public boolean verify(String a, SSLSession b) {
+    {
+      boolean bool = true;
+    }
+    {
+      return true;
+    }
+  }
+}
diff --git a/java-checks/src/test/files/checks/unused/UnusedMethodParameterCheck.java b/java-checks/src/test/files/checks/unused/UnusedMethodParameterCheck.java
index 10e93ca7fb..cfff710f39 100755
--- a/java-checks/src/test/files/checks/unused/UnusedMethodParameterCheck.java
+++ b/java-checks/src/test/files/checks/unused/UnusedMethodParameterCheck.java
@@ -203,30 +203,45 @@ void bar(ActionMapping mapping, ActionForm form, HttpServletRequest request, Htt
 
 class DocumentedMethod {
   /**
-   * @param firstArg
-   * @param secondArg
-   * @param fourthArg
+   * @param firstArg proper javadoc description
+   * @param secondArg proper javadoc description
+   * @param fourthArg proper javadoc description
    */
   void foo(String firstArg, int secondArg, double thirdArg, float fourthArg) { // Noncompliant {{Remove this unused method parameter "thirdArg".}}
     doSomething();
   }
 
   /**
+   * @param firstArg proper javadoc description
+   */
+  protected void bar(String firstArg) { // Compliant - parameter has proper javadoc
+    doSomething();
+  }
+
+  /**
+   * Overridable method, but a proper javadoc description is missing for unused parameter
    * @param firstArg
    */
+  public void foobar(String firstArg) { // Noncompliant
+    doSomething();
+  }
+
+  /**
+   * @param firstArg proper javadoc description
+   */
   private void nonOverrideableMethod(String firstArg) { // Noncompliant  {{Remove this unused method parameter "firstArg".}}
     doSomething();
   }
 
   /**
-   * @param firstArg
+   * @param firstArg proper javadoc description
    */
   static void nonOverrideableMethod(int firstArg) { // Noncompliant  {{Remove this unused method parameter "firstArg".}}
     doSomething();
   }
 
   /**
-   * @param firstArg
+   * @param firstArg proper javadoc description
    */
   final void nonOverrideableMethod(Object firstArg) { // Noncompliant  {{Remove this unused method parameter "firstArg".}}
     doSomething();
@@ -235,7 +250,7 @@ final void nonOverrideableMethod(Object firstArg) { // Noncompliant  {{Remove th
 
 final class FinalDocumentedMethod {
   /**
-   * @param firstArg
+   * @param firstArg proper javadoc description
    */
   void nonOverrideableMethod(int firstArg) { // Noncompliant  {{Remove this unused method parameter "firstArg".}}
     doSomething();
diff --git a/java-checks/src/test/files/checks/xml/maven/PomElementOrderCheck2.xml b/java-checks/src/test/files/checks/xml/maven/PomElementOrderCheck2.xml
new file mode 100755
index 0000000000..fd579a60ff
--- /dev/null
+++ b/java-checks/src/test/files/checks/xml/maven/PomElementOrderCheck2.xml
@@ -0,0 +1,21 @@
+<!-- Noncompliant@+1 [[secondary=8,9,10]] {{Reorder the elements of this pom to match the recommended order.}} -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+
+  <modelVersion>4.0.0</modelVersion> <!-- correct 1st -->
+  <groupId>org.sonarsource.java</groupId> <!-- correct 2nd -->
+
+  <packaging>jar</packaging> <!-- should be 5th -->
+  <artifactId>simple-project</artifactId> <!-- correct 3rd -->
+  <version>1.0-SNAPSHOT</version> <!-- should be 4th -->
+
+  <description>foo</description>  <!-- correct 6th -->
+
+  <dependencies> <!-- correct 7th -->
+    <dependency>
+      <groupId>commons-beanutils</groupId>
+      <artifactId>commons-beanutils</artifactId>
+      <version>1.8.3</version>
+    </dependency>
+  </dependencies>
+</project>
diff --git a/java-checks/src/test/java/org/sonar/java/checks/AssertsOnParametersOfPublicMethodCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/AssertsOnParametersOfPublicMethodCheckTest.java
new file mode 100755
index 0000000000..726cb94320
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/AssertsOnParametersOfPublicMethodCheckTest.java
@@ -0,0 +1,31 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class AssertsOnParametersOfPublicMethodCheckTest {
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/AssertsOnParametersOfPublicMethodCheck.java", new AssertsOnParametersOfPublicMethodCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/AssertsOnParametersOfPublicMethodCheck.java", new AssertsOnParametersOfPublicMethodCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/CommentRegularExpressionCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/CommentRegularExpressionCheckTest.java
index 6a45865859..f1c6b32247 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/CommentRegularExpressionCheckTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/CommentRegularExpressionCheckTest.java
@@ -20,8 +20,8 @@
 package org.sonar.java.checks;
 
 import org.junit.Test;
+import org.sonar.java.AnalysisException;
 import org.sonar.java.checks.verifier.JavaCheckVerifier;
-import org.sonar.squidbridge.api.AnalysisException;
 
 public class CommentRegularExpressionCheckTest {
 
diff --git a/java-checks/src/test/java/org/sonar/java/checks/CompareToNotOverloadedCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/CompareToNotOverloadedCheckTest.java
new file mode 100755
index 0000000000..5eae6c2249
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/CompareToNotOverloadedCheckTest.java
@@ -0,0 +1,32 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class CompareToNotOverloadedCheckTest {
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/CompareToNotOverloadedCheck.java", new CompareToNotOverloadedCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/CompareToNotOverloadedCheck.java", new CompareToNotOverloadedCheck());
+
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/DisallowedClassCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/DisallowedClassCheckTest.java
index 540d3a0576..6f7b9d8e41 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/DisallowedClassCheckTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/DisallowedClassCheckTest.java
@@ -19,9 +19,10 @@
  */
 package org.sonar.java.checks;
 
+import org.fest.assertions.Fail;
 import org.junit.Test;
+import org.sonar.java.AnalysisException;
 import org.sonar.java.checks.verifier.JavaCheckVerifier;
-import org.sonar.squidbridge.api.AnalysisException;
 
 public class DisallowedClassCheckTest {
 
@@ -53,10 +54,11 @@ public void checkBadRegex() throws Throwable {
     DisallowedClassCheck visitor = new DisallowedClassCheck();
     // bad regex
     visitor.disallowedClass = "java.lang(";
-      try {
-          JavaCheckVerifier.verify("src/test/files/checks/DisallowedClassCheckRegex.java", visitor);
-      } catch (AnalysisException e) {
-          throw e.getCause();
-      }
+    try {
+      JavaCheckVerifier.verify("src/test/files/checks/DisallowedClassCheckRegex.java", visitor);
+      Fail.fail("Should have failed");
+    } catch (AnalysisException e) {
+      throw e.getCause();
+    }
   }
 }
diff --git a/java-checks/src/test/java/org/sonar/java/checks/DoublePrefixOperatorCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/DoublePrefixOperatorCheckTest.java
new file mode 100755
index 0000000000..354ef9cf89
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/DoublePrefixOperatorCheckTest.java
@@ -0,0 +1,31 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class DoublePrefixOperatorCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/DoublePrefixOperatorCheck/DoublePrefixOperatorCheck.java", new DoublePrefixOperatorCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/EqualsParametersMarkedNonNullCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/EqualsParametersMarkedNonNullCheckTest.java
new file mode 100755
index 0000000000..98f832947b
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/EqualsParametersMarkedNonNullCheckTest.java
@@ -0,0 +1,33 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class EqualsParametersMarkedNonNullCheckTest {
+
+  @Test
+  public void detected() {
+    JavaCheckVerifier.verify("src/test/files/checks/EqualsParametersMarkedNonNullCheck.java", new EqualsParametersMarkedNonNullCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/EqualsParametersMarkedNonNullCheck.java", new EqualsParametersMarkedNonNullCheck());
+  }
+
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/IfElseIfStatementEndsWithElseCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/IfElseIfStatementEndsWithElseCheckTest.java
new file mode 100755
index 0000000000..967894f70b
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/IfElseIfStatementEndsWithElseCheckTest.java
@@ -0,0 +1,31 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class IfElseIfStatementEndsWithElseCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/IfElseIfStatementEndsWithElseCheck.java", new IfElseIfStatementEndsWithElseCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/UnconditionalJumpStatementCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/LoopExecutingAtMostOnceCheckTest.java
similarity index 84%
rename from java-checks/src/test/java/org/sonar/java/checks/UnconditionalJumpStatementCheckTest.java
rename to java-checks/src/test/java/org/sonar/java/checks/LoopExecutingAtMostOnceCheckTest.java
index 3e1d612cef..41eaa177ba 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/UnconditionalJumpStatementCheckTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/LoopExecutingAtMostOnceCheckTest.java
@@ -22,11 +22,11 @@
 import org.junit.Test;
 import org.sonar.java.checks.verifier.JavaCheckVerifier;
 
-public class UnconditionalJumpStatementCheckTest {
+public class LoopExecutingAtMostOnceCheckTest {
 
   @Test
   public void test() {
-    JavaCheckVerifier.verify("src/test/files/checks/UnconditionalJumpStatementCheck.java", new UnconditionalJumpStatementCheck());
+    JavaCheckVerifier.verify("src/test/files/checks/LoopExecutingAtMostOnceCheck.java", new LoopExecutingAtMostOnceCheck());
   }
 
 }
diff --git a/java-checks/src/test/java/org/sonar/java/checks/MethodParametersOrderCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/MethodParametersOrderCheckTest.java
new file mode 100755
index 0000000000..3d6e507abc
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/MethodParametersOrderCheckTest.java
@@ -0,0 +1,31 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class MethodParametersOrderCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/MethodParametersOrderCheck.java", new MethodParametersOrderCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/NestedSwitchStatementCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/NestedSwitchStatementCheckTest.java
new file mode 100755
index 0000000000..c38b89c5cf
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/NestedSwitchStatementCheckTest.java
@@ -0,0 +1,31 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class NestedSwitchStatementCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/NestedSwitchStatementCheck.java", new NestedSwitchStatementCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/NullCheckWithInstanceofCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/NullCheckWithInstanceofCheckTest.java
new file mode 100755
index 0000000000..d34e2f9764
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/NullCheckWithInstanceofCheckTest.java
@@ -0,0 +1,36 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class NullCheckWithInstanceofCheckTest {
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/NullCheckWithInstanceofCheck.java", new NullCheckWithInstanceofCheck());
+  }
+
+  @Test
+  public void test_no_semantic() {
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/NullCheckWithInstanceofCheck.java", new NullCheckWithInstanceofCheck());
+  }
+
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/RedundantJumpCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/RedundantJumpCheckTest.java
new file mode 100755
index 0000000000..8a9b73b765
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/RedundantJumpCheckTest.java
@@ -0,0 +1,32 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class RedundantJumpCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/RedundantJumpCheck.java", new RedundantJumpCheck());
+  }
+
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/RedundantThrowsDeclarationCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/RedundantThrowsDeclarationCheckTest.java
index edfc13de6b..4da548ec99 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/RedundantThrowsDeclarationCheckTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/RedundantThrowsDeclarationCheckTest.java
@@ -27,6 +27,7 @@
   @Test
   public void test() {
     JavaCheckVerifier.verify("src/test/files/checks/RedundantThrowsDeclaration.java", new RedundantThrowsDeclarationCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/RedundantThrowsDeclaration.java", new RedundantThrowsDeclarationCheck());
   }
 
 }
diff --git a/java-checks/src/test/java/org/sonar/java/checks/RegexPatternsNeedlesslyCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/RegexPatternsNeedlesslyCheckTest.java
new file mode 100755
index 0000000000..cd7464537a
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/RegexPatternsNeedlesslyCheckTest.java
@@ -0,0 +1,30 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class RegexPatternsNeedlesslyCheckTest {
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/RegexPatternsNeedlesslyCheck.java", new RegexPatternsNeedlesslyCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/SwitchDefaultLastCaseCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/SwitchDefaultLastCaseCheckTest.java
new file mode 100755
index 0000000000..6009df4a61
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/SwitchDefaultLastCaseCheckTest.java
@@ -0,0 +1,30 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class SwitchDefaultLastCaseCheckTest {
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/SwitchDefaultLastCaseCheck.java", new SwitchDefaultLastCaseCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/ThisExposedFromConstructorCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/ThisExposedFromConstructorCheckTest.java
new file mode 100755
index 0000000000..62f4c4569e
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/ThisExposedFromConstructorCheckTest.java
@@ -0,0 +1,32 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class ThisExposedFromConstructorCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/ThisExposedFromConstructorCheck.java", new ThisExposedFromConstructorCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/ThisExposedFromConstructorCheck.java", new ThisExposedFromConstructorCheck());
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/UndocumentedApiCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/UndocumentedApiCheckTest.java
index 3e4625e5c6..ec89f313bc 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/UndocumentedApiCheckTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/UndocumentedApiCheckTest.java
@@ -19,20 +19,15 @@
  */
 package org.sonar.java.checks;
 
-import java.io.File;
-import org.junit.Rule;
 import org.junit.Test;
-import org.sonar.api.utils.log.LogTester;
-import org.sonar.api.utils.log.LoggerLevel;
+import org.sonar.java.AnalysisException;
 import org.sonar.java.checks.verifier.JavaCheckVerifier;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 
 public class UndocumentedApiCheckTest {
 
-  @Rule
-  public LogTester logTester = new LogTester();
-
   @Test
   public void test() {
     UndocumentedApiCheck check = new UndocumentedApiCheck();
@@ -82,11 +77,8 @@ public void testIncompleteJavadoc() {
   public void testInvalidDeclaredException() {
     UndocumentedApiCheck check = new UndocumentedApiCheck();
     check.forClasses = "";
-    String filename = "src/test/files/checks/UndocumentedApiCheck/UndocumentedApiInvalidException.java";
-    JavaCheckVerifier.verifyNoIssue(filename, check);
-    assertThat(logTester.logs(LoggerLevel.ERROR)).hasSize(1).contains("Unable to run check class org.sonar.java.checks.UndocumentedApiCheck - UndocumentedApi on file "
-      + new File(filename).getPath()
-      + ", To help improve SonarJava, please report this problem to SonarSource : see https://www.sonarqube.org/community/");
+    assertThatExceptionOfType(AnalysisException.class).isThrownBy(() -> {
+      JavaCheckVerifier.verify("src/test/files/checks/UndocumentedApiCheck/UndocumentedApiInvalidException.java", check);
+    }).withCause(new IllegalStateException("Exceptions can not be specified other than with an identifier or a fully qualified name."));
   }
-
 }
diff --git a/java-checks/src/test/java/org/sonar/java/checks/WeakSSLContextCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/WeakSSLContextCheckTest.java
new file mode 100755
index 0000000000..5dd23da01e
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/WeakSSLContextCheckTest.java
@@ -0,0 +1,35 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class WeakSSLContextCheckTest {
+
+  @Test
+  public void test() {
+    WeakSSLContextCheck check = new WeakSSLContextCheck();
+    String filename = "src/test/files/checks/WeakSSLContextCheck.java";
+    JavaCheckVerifier.verify(filename, check);
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic(filename, check);
+  }
+
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/helpers/JavadocTest.java b/java-checks/src/test/java/org/sonar/java/checks/helpers/JavadocTest.java
new file mode 100755
index 0000000000..19387996f9
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/helpers/JavadocTest.java
@@ -0,0 +1,124 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.helpers;
+
+import java.io.File;
+import java.util.Collections;
+import java.util.Map;
+import java.util.function.Function;
+import java.util.stream.Collectors;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import org.sonar.java.ast.parser.JavaParser;
+import org.sonar.java.bytecode.loader.SquidClassLoader;
+import org.sonar.java.resolve.SemanticModel;
+import org.sonar.plugins.java.api.tree.ClassTree;
+import org.sonar.plugins.java.api.tree.CompilationUnitTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+public class JavadocTest {
+  private static CompilationUnitTree tree;
+  private static Javadoc fooJavadoc;
+  private static Javadoc barJavadoc;
+  private static Javadoc emptyDescriptionJavadoc;
+  private static Javadoc fullParamsDescriptionJavadoc;
+  private static Javadoc genericExceptionThrownJavadoc;
+
+  @BeforeClass
+  public static void setup() {
+    File file = new File("src/test/files/checks/helpers/JavadocTest.java");
+    tree = (CompilationUnitTree) JavaParser.createParser().parse(file);
+    SemanticModel.createFor(tree, new SquidClassLoader(Collections.emptyList()));
+
+    Map<String, MethodTree> methods = ((ClassTree) tree.types().get(0)).members().stream()
+      .filter(member -> member.is(Tree.Kind.METHOD))
+      .map(MethodTree.class::cast)
+      .collect(Collectors.toMap(methodTree -> methodTree.simpleName().name(), Function.identity()));
+
+    fooJavadoc = new Javadoc(methods.get("foo"));
+    barJavadoc = new Javadoc(methods.get("bar"));
+    emptyDescriptionJavadoc = new Javadoc(methods.get("emptyDescription"));
+    fullParamsDescriptionJavadoc = new Javadoc(methods.get("fullParamsDescription"));
+    genericExceptionThrownJavadoc = new Javadoc(methods.get("genericExceptionThrown"));
+  }
+
+  @Test
+  public void test_no_main_description() {
+    assertThat(fooJavadoc.noMainDescription()).isFalse();
+    assertThat(barJavadoc.noMainDescription()).isTrue();
+    assertThat(emptyDescriptionJavadoc.noMainDescription()).isTrue();
+    assertThat(fullParamsDescriptionJavadoc.noMainDescription()).isTrue();
+    assertThat(genericExceptionThrownJavadoc.noMainDescription()).isTrue();
+  }
+
+  @Test
+  public void test_no_return_description() {
+    assertThat(fooJavadoc.noReturnDescription()).isFalse();
+    assertThat(barJavadoc.noReturnDescription()).isFalse();
+    assertThat(emptyDescriptionJavadoc.noReturnDescription()).isTrue();
+    assertThat(fullParamsDescriptionJavadoc.noReturnDescription()).isTrue();
+    assertThat(genericExceptionThrownJavadoc.noReturnDescription()).isTrue();
+  }
+
+  @Test
+  public void test_undocumented_parameters() {
+    assertThat(fooJavadoc.undocumentedParameters()).containsExactlyInAnyOrder("c", "e");
+    assertThat(barJavadoc.undocumentedParameters()).containsExactlyInAnyOrder("a");
+    assertThat(emptyDescriptionJavadoc.undocumentedParameters()).containsExactlyInAnyOrder("a", "b", "c", "d", "e");
+    assertThat(fullParamsDescriptionJavadoc.undocumentedParameters()).isEmpty();
+    assertThat(genericExceptionThrownJavadoc.undocumentedParameters()).isEmpty();
+  }
+
+  @Test
+  public void test_undocumented_thrown_exceptions() {
+    assertThat(fooJavadoc.undocumentedThrownExceptions()).containsExactlyInAnyOrder("IOException", "IllegalStateException", "B");
+    assertThat(barJavadoc.undocumentedThrownExceptions()).isEmpty();
+    assertThat(emptyDescriptionJavadoc.undocumentedThrownExceptions()).containsExactlyInAnyOrder("NullPointerException");
+    assertThat(fullParamsDescriptionJavadoc.undocumentedThrownExceptions()).isEmpty();
+    assertThat(genericExceptionThrownJavadoc.undocumentedThrownExceptions()).containsExactlyInAnyOrder("ObjectStreamException", "InvalidObjectException");
+  }
+
+  @Test
+  public void test_no_exception_on_invalid_type() {
+    Javadoc invalidJavadoc = new Javadoc(tree);
+    assertThat(invalidJavadoc.undocumentedParameters()).isEmpty();
+    assertThat(invalidJavadoc.undocumentedThrownExceptions()).isEmpty();
+    assertThat(invalidJavadoc.getBlockTagDescriptions()).isEmpty();
+    assertThat(invalidJavadoc.getMainDescription()).isEmpty();
+  }
+
+  @Test
+  public void test_class_javadoc() {
+    Javadoc classJavadoc = new Javadoc(tree.types().get(0));
+    assertThat(classJavadoc.noMainDescription()).isFalse();
+    assertThat(classJavadoc.noReturnDescription()).isTrue();
+    assertThat(classJavadoc.undocumentedParameters()).containsExactlyInAnyOrder("<C>", "<E>");
+    assertThat(classJavadoc.undocumentedThrownExceptions()).isEmpty();
+
+    Javadoc classNoJavadoc = new Javadoc(tree.types().get(1));
+    assertThat(classNoJavadoc.noMainDescription()).isTrue();
+    assertThat(classNoJavadoc.noReturnDescription()).isTrue();
+    assertThat(classNoJavadoc.undocumentedParameters()).isEmpty();
+    assertThat(classNoJavadoc.undocumentedThrownExceptions()).isEmpty();
+  }
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/security/HostnameVerifierImplementationCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/security/HostnameVerifierImplementationCheckTest.java
new file mode 100755
index 0000000000..9c6032ca9c
--- /dev/null
+++ b/java-checks/src/test/java/org/sonar/java/checks/security/HostnameVerifierImplementationCheckTest.java
@@ -0,0 +1,33 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.checks.security;
+
+import org.junit.Test;
+import org.sonar.java.checks.verifier.JavaCheckVerifier;
+
+public class HostnameVerifierImplementationCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/checks/security/HostnameVerifierImplementationCheck.java", new HostnameVerifierImplementationCheck());
+    JavaCheckVerifier.verifyNoIssueWithoutSemantic("src/test/files/checks/security/HostnameVerifierImplementationCheck.java", new HostnameVerifierImplementationCheck());
+  }
+
+}
diff --git a/java-checks/src/test/java/org/sonar/java/checks/xml/maven/PomElementOrderCheckTest.java b/java-checks/src/test/java/org/sonar/java/checks/xml/maven/PomElementOrderCheckTest.java
index ab9a72cccc..c085cdabc6 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/xml/maven/PomElementOrderCheckTest.java
+++ b/java-checks/src/test/java/org/sonar/java/checks/xml/maven/PomElementOrderCheckTest.java
@@ -29,6 +29,11 @@ public void should_raise_issue_if_order_is_wrong() {
     PomCheckVerifier.verify("src/test/files/checks/xml/maven/PomElementOrderCheck.xml", new PomElementOrderCheck());
   }
 
+  @Test
+  public void should_raise_issue_with_location_only_between_first_and_last_wrong() {
+    PomCheckVerifier.verify("src/test/files/checks/xml/maven/PomElementOrderCheck2.xml", new PomElementOrderCheck());
+  }
+
   @Test
   public void should_not_raise_issue_if_order_is_correct() {
     PomCheckVerifier.verifyNoIssue("src/test/files/checks/xml/maven/PomElementOrderCheckCorrectOrder.xml", new PomElementOrderCheck());
diff --git a/java-checks/src/test/java/org/sonar/java/filters/FilterVerifier.java b/java-checks/src/test/java/org/sonar/java/filters/FilterVerifier.java
index dbbc8ef0e3..e153abc959 100755
--- a/java-checks/src/test/java/org/sonar/java/filters/FilterVerifier.java
+++ b/java-checks/src/test/java/org/sonar/java/filters/FilterVerifier.java
@@ -23,6 +23,13 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Multimap;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
 import org.apache.commons.io.FileUtils;
 import org.assertj.core.api.Fail;
 import org.sonar.api.rule.RuleKey;
@@ -36,15 +43,6 @@
 import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.plugins.java.api.tree.SyntaxTrivia;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.api.CodeVisitor;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Set;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -53,22 +51,22 @@
 
 public class FilterVerifier {
 
-  public static void verify(String filename, JavaIssueFilter filter, CodeVisitor... extraCodeVisitors) {
+  public static void verify(String filename, JavaIssueFilter filter, JavaCheck... extraJavaChecks) {
     // set the component to the filter
     filter.setComponentKey(filename);
 
     IssueCollector issueCollector = new IssueCollector();
-    ArrayList<CodeVisitor> codeVisitors = Lists.<CodeVisitor>newArrayList(filter, issueCollector);
+    ArrayList<JavaCheck> visitors = Lists.<JavaCheck>newArrayList(filter, issueCollector);
 
     // instantiate the rules filtered by the filter
-    codeVisitors.addAll(instantiateRules(filter.filteredRules()));
+    visitors.addAll(instantiateRules(filter.filteredRules()));
 
-    for (CodeVisitor codeVisitor : extraCodeVisitors) {
-      codeVisitors.add(codeVisitor);
+    for (JavaCheck visitor : extraJavaChecks) {
+      visitors.add(visitor);
     }
 
     Collection<File> classpath = FileUtils.listFiles(new File("target/test-jars"), new String[] {"jar", "zip"}, true);
-    VisitorsBridgeForTests visitorsBridge = new VisitorsBridgeForTests(codeVisitors, Lists.newArrayList(classpath), null);
+    VisitorsBridgeForTests visitorsBridge = new VisitorsBridgeForTests(visitors, Lists.newArrayList(classpath), null);
     JavaAstScanner.scanSingleFileForTests(new File(filename), visitorsBridge);
     VisitorsBridgeForTests.TestJavaFileScannerContext testJavaFileScannerContext = visitorsBridge.lastCreatedTestContext();
 
diff --git a/java-checks/src/test/java/org/sonar/java/filters/PostAnalysisIssueFilterTest.java b/java-checks/src/test/java/org/sonar/java/filters/PostAnalysisIssueFilterTest.java
index e6bd218cb8..2313c11526 100755
--- a/java-checks/src/test/java/org/sonar/java/filters/PostAnalysisIssueFilterTest.java
+++ b/java-checks/src/test/java/org/sonar/java/filters/PostAnalysisIssueFilterTest.java
@@ -20,24 +20,22 @@
 package org.sonar.java.filters;
 
 import com.google.common.collect.Lists;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.Set;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
-
 import org.sonar.api.batch.fs.InputFile;
 import org.sonar.api.batch.fs.internal.DefaultFileSystem;
 import org.sonar.api.batch.fs.internal.DefaultInputFile;
 import org.sonar.api.batch.fs.internal.TestInputFileBuilder;
 import org.sonar.api.scan.issue.filter.FilterableIssue;
 import org.sonar.api.scan.issue.filter.IssueFilterChain;
+import org.sonar.java.AnalysisException;
 import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
-import org.sonar.squidbridge.api.AnalysisException;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Set;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
diff --git a/java-frontend/pom.xml b/java-frontend/pom.xml
index bede2422ad..676b018f68 100755
--- a/java-frontend/pom.xml
+++ b/java-frontend/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-frontend</artifactId>
@@ -109,6 +109,12 @@
       <artifactId>javax.activation</artifactId>
       <scope>runtime</scope>
     </dependency>
+
+    <dependency>
+      <groupId>org.sonarsource.ucfg</groupId>
+      <artifactId>sonar-ucfg</artifactId>
+      <version>1.0.0.29</version>
+    </dependency>
   </dependencies>
 
   <build>
@@ -236,7 +242,7 @@
                 <artifactItem>
                   <groupId>com.google.guava</groupId>
                   <artifactId>guava</artifactId>
-                  <version>10.0.1</version>
+                  <version>20.0</version>
                   <type>jar</type>
                 </artifactItem>
                 <artifactItem>
@@ -269,6 +275,26 @@
                   <artifactId>aspectjtools</artifactId>
                   <version>1.8.10</version>
                 </artifactItem>
+                <artifactItem>
+                  <groupId>javax</groupId>
+                  <artifactId>javaee-api</artifactId>
+                  <version>7.0</version>
+                </artifactItem>
+                <artifactItem>
+                  <groupId>javax.servlet</groupId>
+                  <artifactId>javax.servlet-api</artifactId>
+                  <version>3.1.0</version>
+                </artifactItem>
+                <artifactItem>
+                  <groupId>org.springframework</groupId>
+                  <artifactId>spring-web</artifactId>
+                  <version>5.0.4.RELEASE</version>
+                </artifactItem>
+                <artifactItem>
+                  <groupId>org.springframework</groupId>
+                  <artifactId>spring-context</artifactId>
+                  <version>5.0.4.RELEASE</version>
+                </artifactItem>
               </artifactItems>
               <outputDirectory>${project.build.directory}/test-jars</outputDirectory>
             </configuration>
diff --git a/java-frontend/src/main/java/org/sonar/java/AnalysisException.java b/java-frontend/src/main/java/org/sonar/java/AnalysisException.java
new file mode 100755
index 0000000000..fef12924d0
--- /dev/null
+++ b/java-frontend/src/main/java/org/sonar/java/AnalysisException.java
@@ -0,0 +1,35 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java;
+
+/**
+ * Runtime exception to be thrown during analysis, in case of major issue, for instance invalid format of a report to be parsed
+ */
+public class AnalysisException extends RuntimeException {
+
+  public AnalysisException(String message) {
+    super(message);
+  }
+
+  public AnalysisException(String message, Throwable cause) {
+    super(message, cause);
+  }
+
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/AnalyzerMessage.java b/java-frontend/src/main/java/org/sonar/java/AnalyzerMessage.java
index 5538dcfd2a..63fcdfc891 100755
--- a/java-frontend/src/main/java/org/sonar/java/AnalyzerMessage.java
+++ b/java-frontend/src/main/java/org/sonar/java/AnalyzerMessage.java
@@ -20,18 +20,16 @@
 package org.sonar.java;
 
 import com.google.common.base.Preconditions;
-
-import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.plugins.java.api.tree.SyntaxToken;
-import org.sonar.plugins.java.api.tree.Tree;
-
-import javax.annotation.Nullable;
 import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
+import javax.annotation.Nullable;
+import org.sonar.plugins.java.api.JavaCheck;
+import org.sonar.plugins.java.api.tree.SyntaxToken;
+import org.sonar.plugins.java.api.tree.Tree;
 
 /**
- * Replacement for {@link org.sonar.squidbridge.api.CheckMessage}.
+ * Class used to represent analyzer issue messages
  */
 public class AnalyzerMessage {
 
diff --git a/java-frontend/src/main/java/org/sonar/java/ExceptionHandler.java b/java-frontend/src/main/java/org/sonar/java/ExceptionHandler.java
new file mode 100755
index 0000000000..abb52cc06f
--- /dev/null
+++ b/java-frontend/src/main/java/org/sonar/java/ExceptionHandler.java
@@ -0,0 +1,33 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java;
+
+import com.sonar.sslr.api.RecognitionException;
+
+/**
+ * Interface defining how a java check should react when errors are occurring during analysis.
+ */
+public interface ExceptionHandler {
+
+  void processRecognitionException(RecognitionException e);
+
+  void processException(Exception e);
+
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/JavaClasspath.java b/java-frontend/src/main/java/org/sonar/java/JavaClasspath.java
index 7ce2bc83f9..d3467f67d3 100755
--- a/java-frontend/src/main/java/org/sonar/java/JavaClasspath.java
+++ b/java-frontend/src/main/java/org/sonar/java/JavaClasspath.java
@@ -29,7 +29,6 @@
 import org.sonar.api.utils.log.Logger;
 import org.sonar.api.utils.log.Loggers;
 import org.sonar.api.utils.log.Profiler;
-import org.sonar.squidbridge.api.AnalysisException;
 
 public class JavaClasspath extends AbstractJavaClasspath {
 
diff --git a/java-frontend/src/main/java/org/sonar/java/JavaSquid.java b/java-frontend/src/main/java/org/sonar/java/JavaSquid.java
index 262a34b191..229dbe7391 100755
--- a/java-frontend/src/main/java/org/sonar/java/JavaSquid.java
+++ b/java-frontend/src/main/java/org/sonar/java/JavaSquid.java
@@ -22,6 +22,12 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.sonar.sslr.api.typed.ActionParser;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.sonar.api.utils.log.Logger;
 import org.sonar.api.utils.log.Loggers;
 import org.sonar.api.utils.log.Profiler;
@@ -29,20 +35,13 @@
 import org.sonar.java.ast.parser.JavaParser;
 import org.sonar.java.ast.visitors.FileLinesVisitor;
 import org.sonar.java.ast.visitors.SyntaxHighlighterVisitor;
-import org.sonar.java.filters.CodeVisitorIssueFilter;
+import org.sonar.java.filters.SonarJavaIssueFilter;
 import org.sonar.java.model.VisitorsBridge;
 import org.sonar.java.se.SymbolicExecutionMode;
+import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.plugins.java.api.JavaResourceLocator;
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.api.CodeVisitor;
-
-import javax.annotation.Nullable;
-import java.io.File;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.List;
 
 public class JavaSquid {
 
@@ -53,23 +52,23 @@
 
   public JavaSquid(JavaVersion javaVersion,
     @Nullable SonarComponents sonarComponents, @Nullable Measurer measurer,
-    JavaResourceLocator javaResourceLocator, @Nullable CodeVisitorIssueFilter postAnalysisIssueFilter, CodeVisitor... visitors) {
+    JavaResourceLocator javaResourceLocator, @Nullable SonarJavaIssueFilter postAnalysisIssueFilter, JavaCheck... visitors) {
     this(javaVersion, false, sonarComponents, measurer, javaResourceLocator, postAnalysisIssueFilter, visitors);
   }
 
   public JavaSquid(JavaVersion javaVersion, boolean xFileEnabled,
                    @Nullable SonarComponents sonarComponents, @Nullable Measurer measurer,
-                   JavaResourceLocator javaResourceLocator, @Nullable CodeVisitorIssueFilter postAnalysisIssueFilter, CodeVisitor... visitors) {
+                   JavaResourceLocator javaResourceLocator, @Nullable SonarJavaIssueFilter postAnalysisIssueFilter, JavaCheck... visitors) {
 
-    List<CodeVisitor> commonVisitors = Lists.newArrayList(javaResourceLocator);
+    List<JavaCheck> commonVisitors = Lists.newArrayList(javaResourceLocator);
     if (postAnalysisIssueFilter != null) {
       commonVisitors.add(postAnalysisIssueFilter);
     }
 
-    Iterable<CodeVisitor> codeVisitors = Iterables.concat(commonVisitors, Arrays.asList(visitors));
-    Collection<CodeVisitor> testCodeVisitors = Lists.newArrayList(commonVisitors);
+    Iterable<JavaCheck> codeVisitors = Iterables.concat(commonVisitors, Arrays.asList(visitors));
+    Collection<JavaCheck> testCodeVisitors = Lists.newArrayList(commonVisitors);
     if (measurer != null) {
-      Iterable<CodeVisitor> measurers = Collections.singletonList(measurer);
+      Iterable<JavaCheck> measurers = Collections.singletonList(measurer);
       codeVisitors = Iterables.concat(measurers, codeVisitors);
       testCodeVisitors.add(measurer.new TestFileMeasurer());
     }
@@ -77,13 +76,10 @@ public JavaSquid(JavaVersion javaVersion, boolean xFileEnabled,
     List<File> testClasspath = Lists.newArrayList();
     if (sonarComponents != null) {
       if(!sonarComponents.isSonarLintContext()) {
-        codeVisitors = Iterables.concat(
-          codeVisitors,
-          Arrays.asList(
-            new FileLinesVisitor(sonarComponents),
-            new SyntaxHighlighterVisitor(sonarComponents)
-          )
-        );
+        codeVisitors = Iterables.concat(codeVisitors, Arrays.asList(new FileLinesVisitor(sonarComponents), new SyntaxHighlighterVisitor(sonarComponents)));
+        if (sonarComponents.shouldGenerateUCFG()) {
+          codeVisitors = Iterables.concat(codeVisitors, Collections.singletonList(new UCFGJavaVisitor(sonarComponents.workDir())));
+        }
         testCodeVisitors.add(new SyntaxHighlighterVisitor(sonarComponents));
       }
       classpath = sonarComponents.getJavaClasspath();
@@ -103,25 +99,25 @@ public JavaSquid(JavaVersion javaVersion, boolean xFileEnabled,
   }
 
   private static VisitorsBridge createVisitorBridge(
-    Iterable<CodeVisitor> codeVisitors, List<File> classpath, JavaVersion javaVersion, @Nullable SonarComponents sonarComponents, SymbolicExecutionMode symbolicExecutionMode) {
+    Iterable<JavaCheck> codeVisitors, List<File> classpath, JavaVersion javaVersion, @Nullable SonarComponents sonarComponents, SymbolicExecutionMode symbolicExecutionMode) {
     VisitorsBridge visitorsBridge = new VisitorsBridge(codeVisitors, classpath, sonarComponents, symbolicExecutionMode);
     visitorsBridge.setJavaVersion(javaVersion);
     return visitorsBridge;
   }
 
 
-  public void scan(Iterable<File> sourceFiles, Iterable<File> testFiles) {
+  public void scan(Collection<File> sourceFiles, Collection<File> testFiles) {
     scanSources(sourceFiles);
     scanTests(testFiles);
   }
 
-  private void scanSources(Iterable<File> sourceFiles) {
+  private void scanSources(Collection<File> sourceFiles) {
     Profiler profiler = Profiler.create(LOG).startInfo("Java Main Files AST scan");
     astScanner.scan(sourceFiles);
     profiler.stopInfo();
   }
 
-  private void scanTests(Iterable<File> testFiles) {
+  private void scanTests(Collection<File> testFiles) {
     Profiler profiler = Profiler.create(LOG).startInfo("Java Test Files AST scan");
     astScannerForTests.scan(testFiles);
     profiler.stopInfo();
diff --git a/java-frontend/src/main/java/org/sonar/java/SonarComponents.java b/java-frontend/src/main/java/org/sonar/java/SonarComponents.java
index 46f6451c9b..0b0c3a0485 100755
--- a/java-frontend/src/main/java/org/sonar/java/SonarComponents.java
+++ b/java-frontend/src/main/java/org/sonar/java/SonarComponents.java
@@ -27,17 +27,23 @@
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Scanner;
+import java.util.Set;
+import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 import org.sonar.api.SonarProduct;
 import org.sonar.api.batch.ScannerSide;
 import org.sonar.api.batch.fs.FileSystem;
 import org.sonar.api.batch.fs.InputFile;
 import org.sonar.api.batch.fs.InputPath;
+import org.sonar.api.batch.rule.ActiveRule;
 import org.sonar.api.batch.rule.CheckFactory;
 import org.sonar.api.batch.rule.Checks;
 import org.sonar.api.batch.sensor.SensorContext;
@@ -46,18 +52,25 @@
 import org.sonar.api.measures.FileLinesContext;
 import org.sonar.api.measures.FileLinesContextFactory;
 import org.sonar.api.measures.Metric;
-import org.sonar.api.platform.Server;
 import org.sonar.api.rule.RuleKey;
+import org.sonar.api.utils.log.Logger;
+import org.sonar.api.utils.log.Loggers;
 import org.sonar.plugins.java.api.CheckRegistrar;
 import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.squidbridge.api.AnalysisException;
-import org.sonar.squidbridge.api.CodeVisitor;
 import org.sonarsource.api.sonarlint.SonarLintSide;
 
 @ScannerSide
 @SonarLintSide
 public class SonarComponents {
 
+  private static final Logger LOG = Loggers.get(SonarComponents.class);
+
+  /**
+   * Metric to collect
+   */
+  public static final Metric<String> FEEDBACK_METRIC = new Metric.Builder("sonarjava_feedback", "SonarJava feedback", Metric.ValueType.DATA).setHidden(true).create();
+  public static final String COLLECT_ANALYSIS_ERRORS_KEY = "sonar.java.collectAnalysisErrors";
+  public static final String FAIL_ON_EXCEPTION_KEY = "sonar.java.failOnException";
   /**
    * Approximate limit of feedback of 200ko to roughly 100_000 characters of useful feedback.
    * This does not take into account eventual overhead of serialization.
@@ -67,38 +80,29 @@
   private final FileLinesContextFactory fileLinesContextFactory;
   private final JavaTestClasspath javaTestClasspath;
   private final CheckFactory checkFactory;
-  @Nullable
-  private final Server server;
   private final FileSystem fs;
   private final JavaClasspath javaClasspath;
   private final List<Checks<JavaCheck>> checks;
   private final List<Checks<JavaCheck>> testChecks;
   private final List<Checks<JavaCheck>> allChecks;
   private SensorContext context;
+  private String ruleRepositoryKey;
   @VisibleForTesting
   public List<AnalysisError> analysisErrors;
   private int errorsSize = 0;
   public SonarComponents(FileLinesContextFactory fileLinesContextFactory, FileSystem fs,
                          JavaClasspath javaClasspath, JavaTestClasspath javaTestClasspath,
                          CheckFactory checkFactory) {
-    this(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory, null, null);
-
-  }
-  public SonarComponents(FileLinesContextFactory fileLinesContextFactory, FileSystem fs,
-                         JavaClasspath javaClasspath, JavaTestClasspath javaTestClasspath,
-                         CheckFactory checkFactory, Server server) {
-    this(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory, server, null);
+    this(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory, null);
   }
 
   public SonarComponents(FileLinesContextFactory fileLinesContextFactory, FileSystem fs,
-                         JavaClasspath javaClasspath, JavaTestClasspath javaTestClasspath, CheckFactory checkFactory,
-                         @Nullable Server server, @Nullable CheckRegistrar[] checkRegistrars) {
+                         JavaClasspath javaClasspath, JavaTestClasspath javaTestClasspath, CheckFactory checkFactory, @Nullable CheckRegistrar[] checkRegistrars) {
     this.fileLinesContextFactory = fileLinesContextFactory;
     this.fs = fs;
     this.javaClasspath = javaClasspath;
     this.javaTestClasspath = javaTestClasspath;
     this.checkFactory = checkFactory;
-    this.server = server;
     this.checks = new ArrayList<>();
     this.testChecks = new ArrayList<>();
     this.allChecks = new ArrayList<>();
@@ -119,6 +123,10 @@ public void setSensorContext(SensorContext context) {
     this.context = context;
   }
 
+  public void setRuleRepositoryKey(String ruleRepositoryKey) {
+    this.ruleRepositoryKey = ruleRepositoryKey;
+  }
+
   public InputFile inputFromIOFile(File file) {
     return fs.inputFile(fs.predicates().is(file));
   }
@@ -165,8 +173,8 @@ public void registerCheckClasses(String repositoryKey, Iterable<Class<? extends
     allChecks.add(createdChecks);
   }
 
-  public CodeVisitor[] checkClasses() {
-    return checks.stream().flatMap(ce -> ce.all().stream()).toArray(CodeVisitor[]::new);
+  public JavaCheck[] checkClasses() {
+    return checks.stream().flatMap(ce -> ce.all().stream()).toArray(JavaCheck[]::new);
   }
 
   public Iterable<Checks<JavaCheck>> checks() {
@@ -243,11 +251,15 @@ void reportIssue(AnalyzerMessage analyzerMessage, RuleKey key, InputPath inputPa
   }
 
   public boolean reportAnalysisError(RecognitionException re, File file) {
+    reportAnalysisError(file, re.getMessage());
+    return isSonarLintContext();
+  }
+
+  public void reportAnalysisError(File file, String message) {
     context.newAnalysisError()
       .onFile(inputFromIOFile(file))
-      .message(re.getMessage())
+      .message(message)
       .save();
-    return isSonarLintContext();
   }
 
   public boolean isSonarLintContext() {
@@ -294,16 +306,51 @@ public void addAnalysisError(AnalysisError analysisError) {
   }
 
   public void saveAnalysisErrors() {
-    if (!isSonarLintContext() && !analysisErrors.isEmpty() && server.getPublicRootUrl().equals("https://sonarcloud.io")) {
-      Metric.Builder metricBuilder = new Metric.Builder("sonarjava_feedback", "SonarJava feedback", Metric.ValueType.DATA);
-      metricBuilder.setHidden(true);
+    if (!isSonarLintContext() && !analysisErrors.isEmpty() && shouldCollectAnalysisErrors()) {
       Gson gson = new Gson();
       String metricValue = gson.toJson(analysisErrors);
-      context.<String>newMeasure().forMetric(metricBuilder.create()).on(context.module()).withValue(metricValue).save();
+      context.<String>newMeasure().forMetric(FEEDBACK_METRIC).on(context.module()).withValue(metricValue).save();
     }
   }
 
   public boolean shouldFailAnalysisOnException() {
-    return context.config().getBoolean("sonar.java.failOnException").orElse(false);
+    return context.config().getBoolean(FAIL_ON_EXCEPTION_KEY).orElse(false);
   }
+
+  private boolean shouldCollectAnalysisErrors() {
+    return context.config().getBoolean(COLLECT_ANALYSIS_ERRORS_KEY).orElse(false);
+  }
+
+  public File workDir() {
+    return context.fileSystem().workDir();
+  }
+
+  public boolean shouldGenerateUCFG() {
+    Set<String> activeRuleKeys = context.activeRules().findByRepository(this.ruleRepositoryKey).stream()
+      .map(ActiveRule::ruleKey)
+      .map(RuleKey::rule)
+      .collect(Collectors.toSet());
+    Set<String> securityRuleKeys = getSecurityRuleKeys();
+    activeRuleKeys.retainAll(securityRuleKeys);
+    return !activeRuleKeys.isEmpty();
+  }
+
+  public static Set<String> getSecurityRuleKeys() {
+    try {
+      Class<?> javaRulesClass = Class.forName("com.sonar.plugins.security.api.JavaRules");
+      Method getRuleKeysMethod = javaRulesClass.getMethod("getRuleKeys");
+      return (Set<String>) getRuleKeysMethod.invoke(null);
+    } catch (ClassNotFoundException e) {
+      LOG.debug("com.sonar.plugins.security.api.JavaRules is not found, no security rules added to Sonar way java profile: " + e.getMessage());
+    } catch (NoSuchMethodException e) {
+      LOG.debug("com.sonar.plugins.security.api.JavaRules#getRuleKeys is not found, no security rules added to Sonar way java profile: " + e.getMessage());
+    } catch (IllegalAccessException e) {
+      LOG.debug("[IllegalAccessException] no security rules added to Sonar way java profile: " + e.getMessage());
+    } catch (InvocationTargetException e) {
+      LOG.debug("[InvocationTargetException] no security rules added to Sonar way java profile: " + e.getMessage());
+    }
+
+    return new HashSet<>();
+  }
+
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java b/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
new file mode 100755
index 0000000000..987d010907
--- /dev/null
+++ b/java-frontend/src/main/java/org/sonar/java/UCFGJavaVisitor.java
@@ -0,0 +1,378 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Sets;
+import java.io.File;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import javax.annotation.Nullable;
+import org.sonar.api.utils.log.Logger;
+import org.sonar.api.utils.log.Loggers;
+import org.sonar.java.cfg.CFG;
+import org.sonar.java.cfg.VariableReadExtractor;
+import org.sonar.java.model.LiteralUtils;
+import org.sonar.java.resolve.JavaSymbol;
+import org.sonar.plugins.java.api.JavaFileScanner;
+import org.sonar.plugins.java.api.JavaFileScannerContext;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.semantic.Type;
+import org.sonar.plugins.java.api.tree.AnnotationTree;
+import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.LiteralTree;
+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.ReturnStatementTree;
+import org.sonar.plugins.java.api.tree.SyntaxToken;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.VariableTree;
+import org.sonar.ucfg.Expression;
+import org.sonar.ucfg.Label;
+import org.sonar.ucfg.LocationInFile;
+import org.sonar.ucfg.UCFG;
+import org.sonar.ucfg.UCFGBuilder;
+import org.sonar.ucfg.UCFGBuilder.BlockBuilder;
+import org.sonar.ucfg.UCFGtoProtobuf;
+
+import static org.sonar.plugins.java.api.tree.Tree.Kind.ASSIGNMENT;
+import static org.sonar.plugins.java.api.tree.Tree.Kind.MEMBER_SELECT;
+import static org.sonar.plugins.java.api.tree.Tree.Kind.METHOD_INVOCATION;
+import static org.sonar.plugins.java.api.tree.Tree.Kind.PLUS;
+import static org.sonar.plugins.java.api.tree.Tree.Kind.PLUS_ASSIGNMENT;
+import static org.sonar.ucfg.UCFGBuilder.call;
+import static org.sonar.ucfg.UCFGBuilder.constant;
+import static org.sonar.ucfg.UCFGBuilder.variableWithId;
+
+public class UCFGJavaVisitor extends BaseTreeVisitor implements JavaFileScanner {
+  private static final Logger LOG = Loggers.get(JavaSquid.class);
+  private final File protobufDirectory;
+  String fileKey;
+  private int index = 0;
+
+  public UCFGJavaVisitor(File workdir) {
+    this.protobufDirectory = new File(new File(workdir, "ucfg"), "java");
+    if(!protobufDirectory.exists()) {
+      protobufDirectory.mkdirs();
+    }
+  }
+
+  public void scanFile(JavaFileScannerContext context) {
+    this.fileKey = context.getFileKey();
+    scan(context.getTree());
+  }
+
+  @Override
+  public void visitMethod(MethodTree tree) {
+    super.visitMethod(tree);
+    if (tree.block() != null) {
+      CFG cfg = CFG.build(tree);
+      try {
+        UCFG uCFG = buildUCfg(tree, cfg);
+        UCFGtoProtobuf.toProtobufFile(uCFG, filePath());
+      } catch (Exception e) {
+        LOG.error("Cannot generate ucfg in file " + fileKey + " for method at line" + tree.firstToken().line(), e);
+      }
+    }
+  }
+
+  private String filePath() {
+    String absolutePath = new File(protobufDirectory, "ucfg_" + index + ".proto").getAbsolutePath();
+    index++;
+    return absolutePath;
+  }
+
+  private UCFG buildUCfg(MethodTree methodTree, CFG cfg) {
+    String signature = signatureFor(methodTree.symbol());
+
+    IdentifierGenerator idGenerator = new IdentifierGenerator(methodTree);
+    UCFGBuilder builder = UCFGBuilder.createUCFGForMethod(signature);
+
+    methodTree.parameters().stream()
+      .map(p -> idGenerator.lookupIdFor(p.symbol()))
+      .map(UCFGBuilder::variableWithId)
+      .forEach(builder::addMethodParam);
+
+    BlockBuilder entryBlockBuilder = buildBasicBlock(cfg.entry(), methodTree, idGenerator);
+
+    if (getAnnotatedStringParameters(methodTree).count() > 0) {
+      builder.addStartingBlock(buildParameterAnnotationsBlock(methodTree, idGenerator, cfg));
+      builder.addBasicBlock(entryBlockBuilder);
+    } else {
+      builder.addStartingBlock(entryBlockBuilder);
+    }
+
+    cfg.blocks().stream()
+      .filter(b -> !b.equals(cfg.entry()))
+      .forEach(b -> builder.addBasicBlock(buildBasicBlock(b, methodTree, idGenerator)));
+    return builder.build();
+  }
+
+  private BlockBuilder buildParameterAnnotationsBlock(MethodTree methodTree, IdentifierGenerator idGenerator, CFG cfg) {
+    LocationInFile parametersLocation = location(methodTree.openParenToken(), methodTree.closeParenToken());
+    UCFGBuilder.BlockBuilder blockBuilder = UCFGBuilder.newBasicBlock("paramAnnotations", parametersLocation);
+
+    getAnnotatedStringParameters(methodTree).forEach(parameter -> buildBlockForParameter(parameter, blockBuilder, idGenerator));
+
+    Label nextBlockLabel = UCFGBuilder.createLabel(Integer.toString(cfg.entry().id()));
+    blockBuilder.jumpTo(nextBlockLabel);
+    return blockBuilder;
+  }
+
+  private void buildBlockForParameter(VariableTree parameter, BlockBuilder blockBuilder, IdentifierGenerator idGenerator) {
+    Expression.Variable parameterVariable = variableWithId(idGenerator.lookupIdFor(parameter.symbol()));
+    List<AnnotationTree> annotationList = parameter.modifiers().annotations();
+    List<Expression> annotationVariables = new ArrayList<>();
+
+    annotationList.forEach(annotationTree -> {
+      Expression.Variable var = variableWithId(idGenerator.newIdFor(annotationTree));
+      annotationVariables.add(var);
+      blockBuilder.assignTo(var, call(annotationTree.annotationType().symbolType().fullyQualifiedName()).withArgs(parameterVariable), location(annotationTree));
+    });
+
+    Expression[] args = annotationVariables.toArray(new Expression[annotationVariables.size()]);
+    blockBuilder.assignTo(parameterVariable, call("__annotation").withArgs(args), location(parameter.simpleName()));
+  }
+
+  private static Stream<VariableTree> getAnnotatedStringParameters(MethodTree methodTree) {
+    return methodTree.parameters().stream().filter(parameter -> isString(parameter.type().symbolType())).filter(parameter -> !parameter.modifiers().annotations().isEmpty());
+  }
+
+  private UCFGBuilder.BlockBuilder buildBasicBlock(CFG.Block javaBlock, MethodTree methodTree, IdentifierGenerator idGenerator) {
+    UCFGBuilder.BlockBuilder blockBuilder = UCFGBuilder.newBasicBlock(String.valueOf(javaBlock.id()), location(javaBlock));
+
+    javaBlock.elements().forEach(e -> buildCall(e, blockBuilder, idGenerator));
+
+    Tree terminator = javaBlock.terminator();
+    if (terminator != null && terminator.is(Tree.Kind.RETURN_STATEMENT)) {
+      ExpressionTree returnedExpression = ((ReturnStatementTree) terminator).expression();
+      Expression retExpr = constant(IdentifierGenerator.CONST);
+      if (methodTree.returnType() != null && isString(methodTree.returnType().symbolType())) {
+        retExpr = idGenerator.lookupExpressionFor(returnedExpression);
+      }
+      blockBuilder.ret(retExpr, location(terminator));
+      return blockBuilder;
+    }
+
+    Set<CFG.Block> successors = javaBlock.successors();
+    if (!successors.isEmpty()) {
+      blockBuilder.jumpTo(successors.stream().map(b -> UCFGBuilder.createLabel(Integer.toString(b.id()))).toArray(Label[]::new));
+      return blockBuilder;
+    }
+    Preconditions.checkState(javaBlock.id() == 0);
+    blockBuilder.ret(constant("implicit return"), location(methodTree.lastToken()));
+    return blockBuilder;
+  }
+
+  private void buildCall(Tree element, UCFGBuilder.BlockBuilder blockBuilder, IdentifierGenerator idGenerator) {
+    if (isStringVarDecl(element)) {
+      VariableTree variableTree = (VariableTree) element;
+
+      String lhs = idGenerator.lookupIdFor(variableTree.simpleName());
+      if (!idGenerator.isConst(lhs)) {
+        ExpressionTree initializer = variableTree.initializer();
+        String source = idGenerator.lookupIdFor(initializer);
+        blockBuilder.assignTo(variableWithId(lhs), UCFGBuilder.call("__id").withArgs(variableWithId(source)), location(element));
+      }
+      return;
+    }
+
+    if (element.is(METHOD_INVOCATION)) {
+      MethodInvocationTree methodInvocationTree = (MethodInvocationTree) element;
+      buildMethodInvocation(blockBuilder, idGenerator, methodInvocationTree);
+    } else if (element.is(PLUS, PLUS_ASSIGNMENT, ASSIGNMENT) && isString(((ExpressionTree) element).symbolType())) {
+      if (element.is(PLUS)) {
+        BinaryExpressionTree binaryExpressionTree = (BinaryExpressionTree) element;
+        Expression lhs = idGenerator.lookupExpressionFor(binaryExpressionTree.leftOperand());
+        Expression rhs = idGenerator.lookupExpressionFor(binaryExpressionTree.rightOperand());
+        Expression.Variable var = variableWithId(idGenerator.newIdFor(binaryExpressionTree));
+        blockBuilder.assignTo(var, call("__concat").withArgs(lhs, rhs), location(element));
+      } else if (element.is(PLUS_ASSIGNMENT)) {
+        Expression var = idGenerator.lookupExpressionFor(((AssignmentExpressionTree) element).variable());
+        Expression expr = idGenerator.lookupExpressionFor(((AssignmentExpressionTree) element).expression());
+        if (!var.isConstant()) {
+          idGenerator.varForExpression(element, ((Expression.Variable) var).id());
+          blockBuilder.assignTo((Expression.Variable) var, call("__concat").withArgs(var, expr), location(element));
+        }
+      } else if (element.is(ASSIGNMENT)) {
+        Expression var = idGenerator.lookupExpressionFor(((AssignmentExpressionTree) element).variable());
+        Expression expr = idGenerator.lookupExpressionFor(((AssignmentExpressionTree) element).expression());
+        if (!var.isConstant()) {
+          blockBuilder.assignTo((Expression.Variable) var, call("__id").withArgs(expr), location(element));
+        }
+      }
+    }
+  }
+
+  private void buildMethodInvocation(UCFGBuilder.BlockBuilder blockBuilder, IdentifierGenerator idGenerator, MethodInvocationTree mit) {
+    if (mit.symbol().isUnknown()) {
+      return;
+    }
+
+    List<String> arguments = null;
+
+    if (isString(mit.symbol().owner().type())) {
+      // myStr.myMethod(args) -> myMethod(myStr, args)
+      arguments = new ArrayList<>();
+      if (mit.methodSelect().is(MEMBER_SELECT)) {
+        arguments.add(idGenerator.lookupIdFor(((MemberSelectExpressionTree) mit.methodSelect()).expression()));
+      }
+      arguments.addAll(argumentIds(idGenerator, mit));
+    } else if (isString(mit.symbolType()) || mit.arguments().stream().map(ExpressionTree::symbolType).anyMatch(UCFGJavaVisitor::isString)) {
+      arguments = argumentIds(idGenerator, mit);
+    }
+
+    if (arguments != null) {
+      String destination = idGenerator.newIdFor(mit);
+      blockBuilder.assignTo(variableWithId(destination),
+        UCFGBuilder.call(signatureFor((Symbol.MethodSymbol) mit.symbol()))
+          .withArgs(arguments.stream().map(UCFGBuilder::variableWithId).toArray(Expression.Variable[]::new)),
+        location(mit));
+    }
+  }
+
+  private static List<String> argumentIds(IdentifierGenerator idGenerator, MethodInvocationTree mit) {
+    return mit.arguments().stream().map(idGenerator::lookupIdFor).collect(Collectors.toList());
+  }
+
+  private static String signatureFor(Symbol.MethodSymbol methodSymbol) {
+    return ((JavaSymbol.MethodJavaSymbol) methodSymbol).completeSignature();
+  }
+
+  @Nullable
+  private LocationInFile location(CFG.Block javaBlock) {
+    Tree firstTree = null;
+    List<Tree> elements = javaBlock.elements();
+    if (!elements.isEmpty()) {
+      firstTree = elements.get(0);
+    } else if (javaBlock.terminator() != null) {
+      firstTree = javaBlock.terminator();
+    }
+    if (firstTree == null) {
+      return null;
+    }
+    return location(firstTree);
+  }
+
+
+  private LocationInFile location(Tree tree) {
+    return location(tree.firstToken(), tree.lastToken());
+  }
+
+  private LocationInFile location(SyntaxToken firstToken, SyntaxToken lastToken) {
+    return new LocationInFile(
+      fileKey,
+      firstToken.line(), firstToken.column(),
+      lastToken.line(), lastToken.column() + lastToken.text().length()
+    );
+  }
+
+  private static boolean isStringVarDecl(Tree tree) {
+    if (!tree.is(Tree.Kind.VARIABLE)) {
+      return false;
+    }
+
+    VariableTree var = (VariableTree) tree;
+    return isString(var.type().symbolType());
+  }
+
+  private static boolean isString(Type type) {
+    return type.is("java.lang.String");
+  }
+
+  public static class IdentifierGenerator {
+
+    private static final String CONST = "\"\"";
+
+    private final Map<Symbol, String> vars;
+    private final Map<Tree, String> temps;
+    private int counter;
+
+    public IdentifierGenerator(MethodTree methodTree) {
+      List<Symbol> parameters = methodTree.parameters().stream().map(VariableTree::symbol).collect(Collectors.toList());
+      VariableReadExtractor variableReadExtractor = new VariableReadExtractor(methodTree.symbol(), false);
+      methodTree.accept(variableReadExtractor);
+      Set<Symbol> locals = variableReadExtractor.usedVariables().stream().filter(s -> s.type().is("java.lang.String")).collect(Collectors.toSet());
+      vars = Sets.union(new HashSet<>(parameters), locals).stream().collect(Collectors.toMap(s -> s, Symbol::name));
+      temps = new HashMap<>();
+      counter = 0;
+    }
+
+    public boolean isConst(String id) {
+      return CONST.equals(id);
+    }
+
+    public String newIdFor(@Nullable Tree tree) {
+      String id = lookupIdFor(tree);
+      if (isConst(id)) {
+        return temps.computeIfAbsent(tree, t -> newId());
+      } else {
+        return id;
+      }
+    }
+
+    private String newId() {
+      String result = "%" + counter;
+      counter++;
+      return result;
+    }
+
+    public Expression lookupExpressionFor(@Nullable Tree tree) {
+      String id = lookupIdFor(tree);
+      if (isConst(id)) {
+        if (tree != null && tree.is(Tree.Kind.STRING_LITERAL)) {
+          return constant(LiteralUtils.trimQuotes(((LiteralTree) tree).value()));
+        }
+        return constant(id);
+      }
+      return variableWithId(id);
+    }
+
+    public String lookupIdFor(@Nullable Tree tree) {
+      if (tree == null) {
+        return CONST;
+      } else if (tree.is(Tree.Kind.IDENTIFIER)) {
+        return lookupIdFor(((IdentifierTree) tree).symbol());
+      } else {
+        return temps.getOrDefault(tree, CONST);
+      }
+    }
+
+    public String lookupIdFor(Symbol symbol) {
+      return vars.getOrDefault(symbol, CONST);
+    }
+
+    public void varForExpression(Tree element, String id) {
+      temps.put(element, id);
+    }
+  }
+
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/ast/JavaAstScanner.java b/java-frontend/src/main/java/org/sonar/java/ast/JavaAstScanner.java
index 571eaf1a89..0b85ff701b 100755
--- a/java-frontend/src/main/java/org/sonar/java/ast/JavaAstScanner.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/JavaAstScanner.java
@@ -21,11 +21,18 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.base.Throwables;
-import com.google.common.collect.Lists;
 import com.sonar.sslr.api.RecognitionException;
 import com.sonar.sslr.api.typed.ActionParser;
+import java.io.File;
+import java.io.InterruptedIOException;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import javax.annotation.Nullable;
 import org.sonar.api.utils.log.Logger;
 import org.sonar.api.utils.log.Loggers;
+import org.sonar.java.AnalysisException;
 import org.sonar.java.SonarComponents;
 import org.sonar.java.ast.parser.JavaParser;
 import org.sonar.java.model.JavaVersionImpl;
@@ -33,13 +40,6 @@
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.squidbridge.ProgressReport;
-import org.sonar.squidbridge.api.AnalysisException;
-
-import javax.annotation.Nullable;
-import java.io.File;
-import java.io.InterruptedIOException;
-import java.util.Collections;
-import java.util.concurrent.TimeUnit;
 
 public class JavaAstScanner {
   private static final Logger LOG = Loggers.get(JavaAstScanner.class);
@@ -53,9 +53,9 @@ public JavaAstScanner(ActionParser<Tree> parser, @Nullable SonarComponents sonar
     this.sonarComponents = sonarComponents;
   }
 
-  public void scan(Iterable<File> files) {
+  public void scan(Collection<File> files) {
     ProgressReport progressReport = new ProgressReport("Report about progress of Java AST analyzer", TimeUnit.SECONDS.toMillis(10));
-    progressReport.start(Lists.newArrayList(files));
+    progressReport.start(files.stream().map(File::getAbsolutePath).collect(Collectors.toList()));
 
     boolean successfullyCompleted = false;
     boolean cancelled = false;
diff --git a/java-checks/src/main/java/org/sonar/java/checks/helpers/MethodsHelper.java b/java-frontend/src/main/java/org/sonar/java/ast/api/JavaSpecialIdentifier.java
similarity index 57%
rename from java-checks/src/main/java/org/sonar/java/checks/helpers/MethodsHelper.java
rename to java-frontend/src/main/java/org/sonar/java/ast/api/JavaSpecialIdentifier.java
index 4c98e19e8c..bc188bf577 100755
--- a/java-checks/src/main/java/org/sonar/java/checks/helpers/MethodsHelper.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/api/JavaSpecialIdentifier.java
@@ -17,26 +17,31 @@
  * along with this program; if not, write to the Free Software Foundation,
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
-package org.sonar.java.checks.helpers;
+package org.sonar.java.ast.api;
 
-import org.sonar.plugins.java.api.tree.IdentifierTree;
-import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
-import org.sonar.plugins.java.api.tree.MethodInvocationTree;
-import org.sonar.plugins.java.api.tree.Tree;
+import com.google.common.annotations.Beta;
+import org.sonar.sslr.grammar.GrammarRuleKey;
 
-public class MethodsHelper {
+/**
+ *
+ * Introduced with java 10 'var' special identifier for local variable declaration
+ *
+ * JLS10 - $14.4
+ *
+ * @since Java 10
+ */
+@Beta
+public enum JavaSpecialIdentifier implements GrammarRuleKey {
+  VAR("var");
 
-  private MethodsHelper() {
+  private final String value;
 
+  JavaSpecialIdentifier(String word) {
+    this.value = word;
   }
 
-  public static IdentifierTree methodName(MethodInvocationTree mit) {
-    IdentifierTree id;
-    if (mit.methodSelect().is(Tree.Kind.IDENTIFIER)) {
-      id = (IdentifierTree) mit.methodSelect();
-    } else {
-      id = ((MemberSelectExpressionTree) mit.methodSelect()).identifier();
-    }
-    return id;
+  public String getValue() {
+    return value;
   }
+
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaGrammar.java b/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaGrammar.java
index 9eff5c44a4..63a4405ed0 100755
--- a/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaGrammar.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaGrammar.java
@@ -19,9 +19,13 @@
  */
 package org.sonar.java.ast.parser;
 
+import com.sonar.sslr.api.typed.GrammarBuilder;
+import com.sonar.sslr.api.typed.Optional;
+import java.util.List;
 import org.sonar.java.ast.api.JavaKeyword;
 import org.sonar.java.ast.api.JavaPunctuator;
 import org.sonar.java.ast.api.JavaRestrictedKeyword;
+import org.sonar.java.ast.api.JavaSpecialIdentifier;
 import org.sonar.java.ast.api.JavaTokenType;
 import org.sonar.java.ast.parser.TreeFactory.Tuple;
 import org.sonar.java.model.InternalSyntaxToken;
@@ -43,6 +47,7 @@
 import org.sonar.java.model.expression.NewClassTreeImpl;
 import org.sonar.java.model.expression.ParenthesizedTreeImpl;
 import org.sonar.java.model.expression.TypeArgumentListTreeImpl;
+import org.sonar.java.model.expression.VarTypeTreeImpl;
 import org.sonar.java.model.statement.AssertStatementTreeImpl;
 import org.sonar.java.model.statement.BlockTreeImpl;
 import org.sonar.java.model.statement.BreakStatementTreeImpl;
@@ -63,8 +68,6 @@
 import org.sonar.java.model.statement.ThrowStatementTreeImpl;
 import org.sonar.java.model.statement.TryStatementTreeImpl;
 import org.sonar.java.model.statement.WhileStatementTreeImpl;
-import com.sonar.sslr.api.typed.GrammarBuilder;
-import com.sonar.sslr.api.typed.Optional;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.ImportClauseTree;
 import org.sonar.plugins.java.api.tree.ModifierTree;
@@ -76,8 +79,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TypeTree;
 
-import java.util.List;
-
 import static org.sonar.java.ast.api.JavaPunctuator.COLON;
 import static org.sonar.java.ast.api.JavaTokenType.IDENTIFIER;
 
@@ -674,7 +675,7 @@ public VariableTreeImpl FORMAL_PARAMETER() {
       .is(
         f.newFormalParameter(
           MODIFIERS(),
-          TYPE(),
+          LOCAL_VARIABLE_TYPE(),
           VARIABLE_DECLARATOR_ID()));
   }
 
@@ -684,7 +685,17 @@ public VariableTreeImpl FORMAL_PARAMETER() {
 
   public VariableDeclaratorListTreeImpl LOCAL_VARIABLE_DECLARATION_STATEMENT() {
     return b.<VariableDeclaratorListTreeImpl>nonterminal(JavaLexer.LOCAL_VARIABLE_DECLARATION_STATEMENT)
-      .is(f.completeLocalVariableDeclaration(MODIFIERS(), TYPE(), VARIABLE_DECLARATORS(), b.token(JavaPunctuator.SEMI)));
+      .is(f.completeLocalVariableDeclaration(MODIFIERS(), LOCAL_VARIABLE_TYPE(), VARIABLE_DECLARATORS(), b.token(JavaPunctuator.SEMI)));
+  }
+
+  public TypeTree LOCAL_VARIABLE_TYPE() {
+    return b.<TypeTree>nonterminal(JavaLexer.LOCAL_VARIABLE_TYPE)
+      .is(b.firstOf(VAR_TYPE(), TYPE()));
+  }
+
+  public VarTypeTreeImpl VAR_TYPE() {
+    return b.<VarTypeTreeImpl>nonterminal(JavaLexer.VAR_TYPE)
+      .is(f.newVarType(b.token(JavaSpecialIdentifier.VAR)));
   }
 
   public VariableDeclaratorListTreeImpl VARIABLE_DECLARATORS() {
@@ -778,7 +789,7 @@ public StatementExpressionListTreeImpl FOR_INIT() {
 
   public StatementExpressionListTreeImpl FOR_INIT_DECLARATION() {
     return b.<StatementExpressionListTreeImpl>nonterminal()
-      .is(f.newForInitDeclaration(MODIFIERS(), TYPE(), VARIABLE_DECLARATORS()));
+      .is(f.newForInitDeclaration(MODIFIERS(), LOCAL_VARIABLE_TYPE(), VARIABLE_DECLARATORS()));
   }
 
   public StatementExpressionListTreeImpl FOR_INIT_EXPRESSIONS() {
@@ -887,7 +898,14 @@ public ResourceListTreeImpl RESOURCES() {
   public Tree RESOURCE() {
     return b.<Tree>nonterminal(JavaLexer.RESOURCE)
       .is(b.firstOf(
-        f.newResource(MODIFIERS(), TYPE_QUALIFIED_IDENTIFIER(), VARIABLE_DECLARATOR_ID(), b.token(JavaPunctuator.EQU), EXPRESSION()),
+        f.newResource(
+          MODIFIERS(),
+          b.firstOf(
+            VAR_TYPE(),
+            TYPE_QUALIFIED_IDENTIFIER()),
+          VARIABLE_DECLARATOR_ID(),
+          b.token(JavaPunctuator.EQU),
+          EXPRESSION()),
         PRIMARY_WITH_SELECTOR()));
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaLexer.java b/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaLexer.java
index 42de6b735a..d18d2bc9b5 100755
--- a/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaLexer.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/parser/JavaLexer.java
@@ -20,15 +20,15 @@
 package org.sonar.java.ast.parser;
 
 import com.sonar.sslr.api.GenericTokenType;
+import java.util.Arrays;
 import org.apache.commons.lang.ArrayUtils;
 import org.sonar.java.ast.api.JavaKeyword;
 import org.sonar.java.ast.api.JavaRestrictedKeyword;
+import org.sonar.java.ast.api.JavaSpecialIdentifier;
 import org.sonar.java.ast.api.JavaTokenType;
 import org.sonar.sslr.grammar.GrammarRuleKey;
 import org.sonar.sslr.grammar.LexerlessGrammarBuilder;
 
-import java.util.Arrays;
-
 import static org.sonar.java.ast.api.JavaKeyword.ENUM;
 import static org.sonar.java.ast.api.JavaPunctuator.AND;
 import static org.sonar.java.ast.api.JavaPunctuator.ANDAND;
@@ -163,6 +163,8 @@
   ARGUMENTS,
 
   LOCAL_VARIABLE_DECLARATION_STATEMENT,
+  LOCAL_VARIABLE_TYPE,
+  VAR_TYPE,
   VARIABLE_DECLARATOR,
 
   FORMAL_PARAMETER,
@@ -404,6 +406,11 @@ private static void keywords(LexerlessGrammarBuilder b) {
         restrictedKeywords[1],
         ArrayUtils.subarray(restrictedKeywords, 2, restrictedKeywords.length)),
       b.nextNot(LETTER_OR_DIGIT));
+
+    // special identifier introduced for java10: 'var'
+    for (JavaSpecialIdentifier tokenType : JavaSpecialIdentifier.values()) {
+      b.rule(tokenType).is(tokenType.getValue(), b.nextNot(LETTER_OR_DIGIT), SPACING);
+    }
   }
 
   private static void punctuator(LexerlessGrammarBuilder b, GrammarRuleKey ruleKey, String value) {
diff --git a/java-frontend/src/main/java/org/sonar/java/ast/parser/TreeFactory.java b/java-frontend/src/main/java/org/sonar/java/ast/parser/TreeFactory.java
index 01c69597a3..27d4ac9e96 100755
--- a/java-frontend/src/main/java/org/sonar/java/ast/parser/TreeFactory.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/parser/TreeFactory.java
@@ -22,7 +22,11 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.sonar.sslr.api.typed.Optional;
-
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.CheckForNull;
+import javax.annotation.Nullable;
 import org.sonar.java.ast.api.JavaKeyword;
 import org.sonar.java.ast.api.JavaPunctuator;
 import org.sonar.java.ast.api.JavaRestrictedKeyword;
@@ -72,6 +76,7 @@
 import org.sonar.java.model.expression.ParenthesizedTreeImpl;
 import org.sonar.java.model.expression.TypeArgumentListTreeImpl;
 import org.sonar.java.model.expression.TypeCastExpressionTreeImpl;
+import org.sonar.java.model.expression.VarTypeTreeImpl;
 import org.sonar.java.model.statement.AssertStatementTreeImpl;
 import org.sonar.java.model.statement.BlockTreeImpl;
 import org.sonar.java.model.statement.BreakStatementTreeImpl;
@@ -105,7 +110,6 @@
 import org.sonar.plugins.java.api.tree.ModuleDirectiveTree;
 import org.sonar.plugins.java.api.tree.ModuleNameTree;
 import org.sonar.plugins.java.api.tree.PackageDeclarationTree;
-import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
 import org.sonar.plugins.java.api.tree.StatementTree;
 import org.sonar.plugins.java.api.tree.SyntaxToken;
 import org.sonar.plugins.java.api.tree.Tree;
@@ -114,13 +118,6 @@
 import org.sonar.plugins.java.api.tree.TypeTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.CheckForNull;
-import javax.annotation.Nullable;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
 public class TreeFactory {
 
   private final KindMaps kindMaps = new KindMaps();
@@ -345,6 +342,11 @@ public TypeTree newType(TypeTree basicOrClassType,
     }
   }
 
+  public VarTypeTreeImpl newVarType(InternalSyntaxToken varToken) {
+    // JLS10 - $14.4
+    return new VarTypeTreeImpl(varToken);
+  }
+
   public TypeArgumentListTreeImpl newTypeArgumentList(InternalSyntaxToken openBracketToken,
     Tree typeArgument, Optional<List<Tuple<InternalSyntaxToken, Tree>>> rests, InternalSyntaxToken closeBracketToken) {
     ImmutableList.Builder<Tree> typeArguments = ImmutableList.builder();
@@ -365,13 +367,8 @@ public TypeArgumentListTreeImpl newDiamondTypeArgument(InternalSyntaxToken openB
     return new TypeArgumentListTreeImpl(openBracketToken, ImmutableList.<Tree>of(), ImmutableList.<SyntaxToken>of(), closeBracketToken);
   }
 
-  public Tree completeTypeArgument(Optional<List<AnnotationTreeImpl>> annotations, Tree partial) {
-    if (partial.is(Tree.Kind.UNBOUNDED_WILDCARD, Tree.Kind.EXTENDS_WILDCARD, Tree.Kind.SUPER_WILDCARD)) {
-      List<AnnotationTree> annotationList = ImmutableList.copyOf(annotations.or(ImmutableList.of()));
-      ((WildcardTreeImpl) partial).complete(annotationList);
-    } else {
-      completeTypeTreeWithAnnotations((TypeTree) partial, annotations);
-    }
+  public Tree completeTypeArgument(Optional<List<AnnotationTreeImpl>> annotations, TypeTree partial) {
+    completeTypeTreeWithAnnotations(partial, annotations);
     return partial;
   }
 
@@ -1656,35 +1653,19 @@ public TypeTree annotationIdentifier(InternalSyntaxToken firstIdentifier, Option
           throw new IllegalArgumentException();
         }
       }
-      moveAnnotations(result, firstIdentifier);
+      moveAnnotations((TypeTree) result, (TypeTree) firstIdentifier);
     }
 
     return (T) result;
   }
 
-  private static void moveAnnotations(ExpressionTree result, ExpressionTree firstIdentifier) {
-    List<AnnotationTree> firstIdentifierAnnotations;
-    boolean isParameterizedType = firstIdentifier.is(Tree.Kind.PARAMETERIZED_TYPE);
-
-    if (isParameterizedType) {
-      firstIdentifierAnnotations = ((ParameterizedTypeTree) firstIdentifier).annotations();
-    } else {
-      firstIdentifierAnnotations = ((IdentifierTree) firstIdentifier).annotations();
-    }
+  private static void moveAnnotations(TypeTree result, TypeTree firstIdentifier) {
+    List<AnnotationTree> firstIdentifierAnnotations = firstIdentifier.annotations();
     // move the annotations from the first identifier to the member select or the parameterized type
     if (!firstIdentifierAnnotations.isEmpty()) {
-      if (result.is(Tree.Kind.MEMBER_SELECT)) {
-        ((MemberSelectExpressionTreeImpl) result).complete(firstIdentifierAnnotations);
-      } else {
-        ((ParameterizedTypeTreeImpl) result).complete(firstIdentifierAnnotations);
-      }
-      if (isParameterizedType) {
-        ((ParameterizedTypeTreeImpl) firstIdentifier).complete(ImmutableList.<AnnotationTree>of());
-      } else {
-        ((IdentifierTreeImpl) firstIdentifier).complete(ImmutableList.<AnnotationTree>of());
-      }
+      ((JavaTree.AnnotatedTypeTree) result).complete(firstIdentifierAnnotations);
+      ((JavaTree.AnnotatedTypeTree) firstIdentifier).complete(ImmutableList.<AnnotationTree>of());
     }
-
   }
 
   public ExpressionTree newAnnotatedParameterizedIdentifier(
@@ -1695,11 +1676,11 @@ public ExpressionTree newAnnotatedParameterizedIdentifier(
     ExpressionTree result = new IdentifierTreeImpl(identifierToken);
 
     if (typeArguments.isPresent()) {
-      result = new ParameterizedTypeTreeImpl((TypeTree) result, typeArguments.get()).complete(annotationList);
-    } else {
-      result = ((IdentifierTreeImpl) result).complete(annotationList);
+      result = new ParameterizedTypeTreeImpl((TypeTree) result, typeArguments.get());
     }
 
+    ((JavaTree.AnnotatedTypeTree) result).complete(annotationList);
+
     return result;
   }
 
@@ -2012,24 +1993,8 @@ private static ArrayTypeTreeImpl newArrayTypeTree(Optional<List<Tuple<InternalSy
   }
 
   private static void completeTypeTreeWithAnnotations(TypeTree type, Optional<List<AnnotationTreeImpl>> annotations) {
-    if (annotations.isPresent()) {
-      List<AnnotationTree> typeAnnotations = ImmutableList.copyOf(annotations.get());
-      completeTypeTreeWithAnnotations(type, typeAnnotations);
-    }
-  }
-
-  private static void completeTypeTreeWithAnnotations(TypeTree type, List<AnnotationTree> typeAnnotations) {
-    if (type.is(Tree.Kind.IDENTIFIER)) {
-      ((IdentifierTreeImpl) type).complete(typeAnnotations);
-    } else if (type.is(Tree.Kind.MEMBER_SELECT)) {
-      ((MemberSelectExpressionTreeImpl) type).complete(typeAnnotations);
-    } else if (type.is(Tree.Kind.PARAMETERIZED_TYPE)) {
-      ((ParameterizedTypeTreeImpl) type).complete(typeAnnotations);
-    } else if (type.is(Kind.ARRAY_TYPE)) {
-      ((ArrayTypeTreeImpl) type).complete(typeAnnotations);
-    } else {
-      ((PrimitiveTypeTreeImpl) type).complete(typeAnnotations);
-    }
+    List<AnnotationTree> annotationList = ImmutableList.copyOf(annotations.or(ImmutableList.of()));
+    ((JavaTree.AnnotatedTypeTree) type).complete(annotationList);
   }
 
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/ast/visitors/CommentLinesVisitor.java b/java-frontend/src/main/java/org/sonar/java/ast/visitors/CommentLinesVisitor.java
index 91104f9891..691a8df11b 100755
--- a/java-frontend/src/main/java/org/sonar/java/ast/visitors/CommentLinesVisitor.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/visitors/CommentLinesVisitor.java
@@ -21,21 +21,18 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Sets;
+import java.util.List;
+import java.util.Set;
 import org.sonar.plugins.java.api.tree.CompilationUnitTree;
 import org.sonar.plugins.java.api.tree.SyntaxToken;
 import org.sonar.plugins.java.api.tree.SyntaxTrivia;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.CommentAnalyser;
-
-import java.util.List;
-import java.util.Set;
 
 public class CommentLinesVisitor extends SubscriptionVisitor {
 
   private Set<Integer> comments = Sets.newHashSet();
   private Set<Integer> noSonarLines = Sets.newHashSet();
   private boolean seenFirstToken;
-  private JavaCommentAnalyser commentAnalyser = new JavaCommentAnalyser();
 
   @Override
   public List<Tree.Kind> nodesToVisit() {
@@ -62,12 +59,12 @@ public void visitToken(SyntaxToken syntaxToken) {
   }
 
   private void handleCommentsForTrivia(SyntaxTrivia trivia) {
-    String[] commentLines = commentAnalyser.getContents(trivia.comment()).split("(\r)?\n|\r", -1);
+    String[] commentLines = getContents(trivia.comment()).split("(\r)?\n|\r", -1);
     int line = trivia.startLine();
     for (String commentLine : commentLines) {
       if(commentLine.contains("NOSONAR")) {
         noSonarLines.add(line);
-      } else if (!commentAnalyser.isBlank(commentLine)) {
+      } else if (!isBlank(commentLine)) {
         comments.add(line);
       }
       line++;
@@ -82,24 +79,19 @@ public int commentLinesMetric() {
     return comments.size();
   }
 
-  public static class JavaCommentAnalyser extends CommentAnalyser {
-
-    @Override
-    public boolean isBlank(String line) {
-      // Implementation of this method was taken from org.sonar.squidbridge.text.Line#isThereBlankComment()
-      // TODO Godin: for some languages we use Character.isLetterOrDigit instead of Character.isWhitespace
-      for (int i = 0; i < line.length(); i++) {
-        char character = line.charAt(i);
-        if (!Character.isWhitespace(character) && character != '*' && character != '/') {
-          return false;
-        }
+  private static boolean isBlank(String line) {
+    // TODO Godin: for some languages we use Character.isLetterOrDigit instead of Character.isWhitespace
+    for (int i = 0; i < line.length(); i++) {
+      char character = line.charAt(i);
+      if (!Character.isWhitespace(character) && character != '*' && character != '/') {
+        return false;
       }
-      return true;
     }
+    return true;
+  }
 
-    @Override
-    public String getContents(String comment) {
-      return comment.startsWith("//") ? comment.substring(2) : comment.substring(2, comment.length() - 2);
-    }
+
+  private static String getContents(String comment) {
+    return comment.startsWith("//") ? comment.substring(2) : comment.substring(2, comment.length() - 2);
   }
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitor.java b/java-frontend/src/main/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitor.java
index e3b18d0e95..7fb9a2b399 100755
--- a/java-frontend/src/main/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitor.java
+++ b/java-frontend/src/main/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitor.java
@@ -22,7 +22,10 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.ImmutableSet;
-
+import java.io.File;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
 import org.sonar.api.batch.sensor.highlighting.NewHighlighting;
 import org.sonar.api.batch.sensor.highlighting.TypeOfText;
 import org.sonar.java.SonarComponents;
@@ -35,11 +38,6 @@
 import org.sonar.plugins.java.api.tree.SyntaxTrivia;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.io.File;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
 public class SyntaxHighlighterVisitor extends SubscriptionVisitor {
 
   private final SonarComponents sonarComponents;
@@ -64,6 +62,7 @@ public SyntaxHighlighterVisitor(SonarComponents sonarComponents) {
     typesByKindBuilder.put(Tree.Kind.LONG_LITERAL, TypeOfText.CONSTANT);
     typesByKindBuilder.put(Tree.Kind.INT_LITERAL, TypeOfText.CONSTANT);
     typesByKindBuilder.put(Tree.Kind.ANNOTATION, TypeOfText.ANNOTATION);
+    typesByKindBuilder.put(Tree.Kind.VAR_TYPE, TypeOfText.KEYWORD);
     typesByKind = typesByKindBuilder.build();
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/cfg/CFG.java b/java-frontend/src/main/java/org/sonar/java/cfg/CFG.java
index 0b9912bd9f..a3626237a4 100755
--- a/java-frontend/src/main/java/org/sonar/java/cfg/CFG.java
+++ b/java-frontend/src/main/java/org/sonar/java/cfg/CFG.java
@@ -172,6 +172,7 @@ public Block entry() {
     private Block trueBlock;
     private Block falseBlock;
     private Block exitBlock;
+    private Block successorWithoutJump;
 
     private Tree terminator;
 
@@ -284,6 +285,15 @@ private void prune(Block inactiveBlock) {
     public boolean isMethodExitBlock() {
       return successors().isEmpty();
     }
+
+    /**
+     * This method makes the implementation of RSPEC-3626 almost trivial.
+     * @return the block which would be the successor of this one if this one didn't terminate with a jump
+     */
+    @CheckForNull
+    public Block successorWithoutJump() {
+      return successorWithoutJump;
+    }
   }
 
   private static void computePredecessors(List<Block> blocks) {
@@ -546,7 +556,7 @@ private void build(Tree tree) {
   }
 
   private void buildReturnStatement(ReturnStatementTree returnStatement) {
-    currentBlock = createUnconditionalJump(returnStatement, exitBlock());
+    currentBlock = createUnconditionalJump(returnStatement, exitBlock(), currentBlock);
     ExpressionTree expression = returnStatement.expression();
     if (expression != null) {
       build(expression);
@@ -734,7 +744,7 @@ private void buildBreakStatement(BreakStatementTree tree) {
     } else {
       targetBlock = labelsBreakTarget.get(label.name());
     }
-    currentBlock = createUnconditionalJump(tree, targetBlock);
+    currentBlock = createUnconditionalJump(tree, targetBlock, currentBlock);
     if(currentBlock.exitBlock != null) {
       currentBlock.exitBlock = null;
     }
@@ -754,7 +764,7 @@ private void buildContinueStatement(ContinueStatementTree tree) {
     } else {
       targetBlock = labelsContinueTarget.get(label.name());
     }
-    currentBlock = createUnconditionalJump(tree, targetBlock);
+    currentBlock = createUnconditionalJump(tree, targetBlock, currentBlock);
     // cleanup for continue statement to a finally: continue block can't have an exit block.
     currentBlock.exitBlock = null;
   }
@@ -841,7 +851,7 @@ private void buildForStatement(ForStatementTree tree) {
       currentBlock = createBranch(tree, body, falseBranch);
       buildCondition(condition, body, falseBranch);
     } else {
-      currentBlock = createUnconditionalJump(tree, body);
+      currentBlock = createUnconditionalJump(tree, body, null);
     }
     updateBlock.addSuccessor(currentBlock);
     // process init
@@ -902,7 +912,7 @@ private void buildThrowStatement(ThrowStatementTree throwStatementTree) {
         .map(t -> enclosingTryCatch.catches.get(t))
         .orElse(exitBlock());
     }
-    currentBlock = createUnconditionalJump(throwStatementTree, jumpTo);
+    currentBlock = createUnconditionalJump(throwStatementTree, jumpTo, currentBlock);
     build(throwStatementTree.expression());
   }
 
@@ -910,7 +920,7 @@ private void buildSynchronizedStatement(SynchronizedStatementTree sst) {
     // First create the block of the statement,
     build(sst.block());
     // Then create a single block with the SYNCHRONIZED tree as terminator
-    currentBlock = createUnconditionalJump(sst, currentBlock);
+    currentBlock = createUnconditionalJump(sst, currentBlock, null);
     build(sst.expression());
   }
 
@@ -1002,7 +1012,7 @@ private void buildAssertStatement(AssertStatementTree assertStatementTree) {
     build(assertStatementTree.condition());
   }
 
-  private Block createUnconditionalJump(Tree terminator, @Nullable Block target) {
+  private Block createUnconditionalJump(Tree terminator, @Nullable Block target, @Nullable Block successorWithoutJump) {
     Block result = createBlock();
     result.terminator = terminator;
     if (target != null) {
@@ -1012,6 +1022,7 @@ private Block createUnconditionalJump(Tree terminator, @Nullable Block target) {
         result.addSuccessor(target);
       }
     }
+    result.successorWithoutJump = successorWithoutJump;
     return result;
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/cfg/VariableReadExtractor.java b/java-frontend/src/main/java/org/sonar/java/cfg/VariableReadExtractor.java
index c1a09e54d4..f336e7699d 100755
--- a/java-frontend/src/main/java/org/sonar/java/cfg/VariableReadExtractor.java
+++ b/java-frontend/src/main/java/org/sonar/java/cfg/VariableReadExtractor.java
@@ -25,9 +25,12 @@
 import org.sonar.plugins.java.api.semantic.Symbol.MethodSymbol;
 import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
 import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.ClassTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
+import org.sonar.plugins.java.api.tree.LambdaExpressionTree;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.Tree.Kind;
+import org.sonar.plugins.java.api.tree.VariableTree;
 
 public class VariableReadExtractor extends BaseTreeVisitor {
 
@@ -54,6 +57,24 @@ public void visitAssignmentExpression(AssignmentExpressionTree tree) {
     scan(tree.expression());
   }
 
+  @Override
+  public void visitVariable(VariableTree tree) {
+    // skip variable modifiers and simple name
+    scan(tree.initializer());
+  }
+
+  @Override
+  public void visitClass(ClassTree tree) {
+    // skip modifiers, parameters, simple name and superclass/interface
+    scan(tree.members());
+  }
+
+  @Override
+  public void visitLambdaExpression(LambdaExpressionTree lambdaExpressionTree) {
+    // skip variable declaration
+    scan(lambdaExpressionTree.body());
+  }
+
   @Override
   public void visitIdentifier(IdentifierTree tree) {
     Symbol owner = tree.symbol().owner();
diff --git a/java-frontend/src/main/java/org/sonar/java/filters/CodeVisitorIssueFilter.java b/java-frontend/src/main/java/org/sonar/java/filters/SonarJavaIssueFilter.java
similarity index 88%
rename from java-frontend/src/main/java/org/sonar/java/filters/CodeVisitorIssueFilter.java
rename to java-frontend/src/main/java/org/sonar/java/filters/SonarJavaIssueFilter.java
index e8d6912b6f..bc8dc88e76 100755
--- a/java-frontend/src/main/java/org/sonar/java/filters/CodeVisitorIssueFilter.java
+++ b/java-frontend/src/main/java/org/sonar/java/filters/SonarJavaIssueFilter.java
@@ -20,8 +20,8 @@
 package org.sonar.java.filters;
 
 import org.sonar.api.scan.issue.filter.IssueFilter;
-import org.sonar.squidbridge.api.CodeVisitor;
+import org.sonar.plugins.java.api.JavaCheck;
 
-public interface CodeVisitorIssueFilter extends CodeVisitor, IssueFilter {
+public interface SonarJavaIssueFilter extends JavaCheck, IssueFilter {
 
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/model/ExpressionUtils.java b/java-frontend/src/main/java/org/sonar/java/model/ExpressionUtils.java
index 89fdd200b2..dc92c10cdb 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/ExpressionUtils.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/ExpressionUtils.java
@@ -23,6 +23,7 @@
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
 import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.ParenthesizedTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
@@ -105,4 +106,18 @@ public static ExpressionTree skipParentheses(ExpressionTree tree) {
   public static boolean isNullLiteral(ExpressionTree tree) {
     return skipParentheses(tree).is(Tree.Kind.NULL_LITERAL);
   }
+
+  /**
+   * Retrieve the identifier corresponding to the method name associated to the method invocation
+   */
+  public static IdentifierTree methodName(MethodInvocationTree mit) {
+    ExpressionTree methodSelect = mit.methodSelect();
+    IdentifierTree id;
+    if (methodSelect.is(Tree.Kind.IDENTIFIER)) {
+      id = (IdentifierTree) methodSelect;
+    } else {
+      id = ((MemberSelectExpressionTree) methodSelect).identifier();
+    }
+    return id;
+  }
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/model/JavaTree.java b/java-frontend/src/main/java/org/sonar/java/model/JavaTree.java
index 765290dfb7..d60744f900 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/JavaTree.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/JavaTree.java
@@ -23,6 +23,12 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Deque;
+import java.util.LinkedList;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.sonar.java.ast.parser.TypeUnionListTreeImpl;
 import org.sonar.java.model.declaration.AnnotationTreeImpl;
 import org.sonar.java.model.expression.TypeArgumentListTreeImpl;
@@ -48,13 +54,6 @@
 import org.sonar.plugins.java.api.tree.WildcardTree;
 import org.sonar.sslr.grammar.GrammarRuleKey;
 
-import javax.annotation.Nullable;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Deque;
-import java.util.LinkedList;
-import java.util.List;
-
 public abstract class JavaTree implements Tree {
 
   @Nullable
@@ -362,7 +361,7 @@ public void accept(TreeVisitor visitor) {
     }
   }
 
-  public static class WildcardTreeImpl extends JavaTree implements WildcardTree {
+  public static class WildcardTreeImpl extends AbstractTypedTree implements WildcardTree, AnnotatedTypeTree {
 
     private SyntaxToken queryToken;
     @Nullable
@@ -396,9 +395,9 @@ public WildcardTreeImpl complete(InternalSyntaxToken queryToken) {
       return this;
     }
 
-    public WildcardTreeImpl complete(List<AnnotationTree> annotations) {
+    @Override
+    public void complete(List<AnnotationTree> annotations) {
       this.annotations = annotations;
-      return this;
     }
 
     @Override
@@ -507,7 +506,7 @@ public boolean isLeaf() {
     }
   }
 
-  public static class PrimitiveTypeTreeImpl extends AbstractTypedTree implements PrimitiveTypeTree {
+  public static class PrimitiveTypeTreeImpl extends AbstractTypedTree implements PrimitiveTypeTree, AnnotatedTypeTree {
 
     private final InternalSyntaxToken token;
     private List<AnnotationTree> annotations;
@@ -518,9 +517,9 @@ public PrimitiveTypeTreeImpl(InternalSyntaxToken token) {
       this.annotations = ImmutableList.of();
     }
 
-    public PrimitiveTypeTreeImpl complete(List<AnnotationTree> annotations) {
+    @Override
+    public void complete(List<AnnotationTree> annotations) {
       this.annotations = annotations;
-      return this;
     }
 
     @Override
@@ -549,7 +548,7 @@ public SyntaxToken keyword() {
     }
   }
 
-  public static class ParameterizedTypeTreeImpl extends AbstractTypedTree implements ParameterizedTypeTree, ExpressionTree {
+  public static class ParameterizedTypeTreeImpl extends AbstractTypedTree implements ParameterizedTypeTree, ExpressionTree, AnnotatedTypeTree {
 
     private final TypeTree type;
     private final TypeArguments typeArguments;
@@ -562,9 +561,9 @@ public ParameterizedTypeTreeImpl(TypeTree type, TypeArgumentListTreeImpl typeArg
       this.annotations = ImmutableList.<AnnotationTree>of();
     }
 
-    public ParameterizedTypeTreeImpl complete(List<AnnotationTree> annotations) {
+    @Override
+    public void complete(List<AnnotationTree> annotations) {
       this.annotations = annotations;
-      return this;
     }
 
     @Override
@@ -598,7 +597,7 @@ public void accept(TreeVisitor visitor) {
     }
   }
 
-  public static class ArrayTypeTreeImpl extends AbstractTypedTree implements ArrayTypeTree {
+  public static class ArrayTypeTreeImpl extends AbstractTypedTree implements ArrayTypeTree, AnnotatedTypeTree {
     private TypeTree type;
     private List<AnnotationTree> annotations;
     private final InternalSyntaxToken openBracketToken;
@@ -687,8 +686,18 @@ public SyntaxToken ellipsisToken() {
       return annotationBuilder.build();
     }
 
+    @Override
     public void complete(List<AnnotationTree> typeAnnotations) {
       this.annotations = typeAnnotations;
     }
   }
+
+  /**
+   * This interface is dedicated to mark TypeTrees which will requires completion of their annotations during parsing.
+   *
+   * Note that {@link org.sonar.plugins.java.api.tree.InferedTypeTree} and {@link UnionTypeTree} can not have annotations.
+   */
+  public interface AnnotatedTypeTree extends TypeTree {
+    void complete(List<AnnotationTree> annotations);
+  }
 }
diff --git a/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridge.java b/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridge.java
index a53f1687c3..a1f9e48604 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridge.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridge.java
@@ -37,6 +37,7 @@
 import org.sonar.api.utils.log.Loggers;
 import org.sonar.check.Rule;
 import org.sonar.java.AnalysisError;
+import org.sonar.java.ExceptionHandler;
 import org.sonar.java.IllegalRuleParameterException;
 import org.sonar.java.JavaVersionAwareVisitor;
 import org.sonar.java.SonarComponents;
@@ -52,7 +53,6 @@
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.CompilationUnitTree;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.AstScannerExceptionHandler;
 
 public class VisitorsBridge {
 
@@ -111,6 +111,7 @@ public void visitFile(@Nullable Tree parsedTree) {
         } catch (Exception e) {
           LOG.error("Unable to create symbol table for : " + currentFile.getAbsolutePath(), e);
           addAnalysisError(e, currentFile.getPath(), AnalysisError.Kind.SEMANTIC_ERROR);
+          sonarComponents.reportAnalysisError(currentFile, e.getMessage());
           return;
         }
         createSonarSymbolTable(tree);
@@ -212,8 +213,8 @@ public void processRecognitionException(RecognitionException e, File file) {
     if(sonarComponents == null || !sonarComponents.reportAnalysisError(e, file)) {
       this.visitFile(null);
       scanners.stream()
-        .filter(scanner -> scanner instanceof AstScannerExceptionHandler)
-        .forEach(scanner -> ((AstScannerExceptionHandler) scanner).processRecognitionException(e));
+        .filter(scanner -> scanner instanceof ExceptionHandler)
+        .forEach(scanner -> ((ExceptionHandler) scanner).processRecognitionException(e));
     }
 
   }
diff --git a/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridgeForTests.java b/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridgeForTests.java
index 0f05127044..b620104882 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridgeForTests.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/VisitorsBridgeForTests.java
@@ -40,7 +40,6 @@
 import org.sonar.plugins.java.api.JavaVersion;
 import org.sonar.plugins.java.api.tree.CompilationUnitTree;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.api.CodeVisitor;
 
 public class VisitorsBridgeForTests extends VisitorsBridge {
 
@@ -59,7 +58,7 @@ public VisitorsBridgeForTests(Iterable visitors, SonarComponents sonarComponents
   }
 
   public VisitorsBridgeForTests(Iterable visitors, List<File> projectClasspath, @Nullable SonarComponents sonarComponents) {
-    super(visitors, projectClasspath, sonarComponents, SymbolicExecutionMode.getMode(Iterables.<CodeVisitor>toArray(visitors, CodeVisitor.class), true));
+    super(visitors, projectClasspath, sonarComponents, SymbolicExecutionMode.getMode(Iterables.<JavaCheck>toArray(visitors, JavaCheck.class), true));
   }
 
   @Override
diff --git a/java-frontend/src/main/java/org/sonar/java/model/expression/IdentifierTreeImpl.java b/java-frontend/src/main/java/org/sonar/java/model/expression/IdentifierTreeImpl.java
index 4af2a00f55..fc3253ec9d 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/expression/IdentifierTreeImpl.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/expression/IdentifierTreeImpl.java
@@ -22,8 +22,11 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
+import java.util.Collections;
+import java.util.List;
 import org.sonar.java.model.AbstractTypedTree;
 import org.sonar.java.model.InternalSyntaxToken;
+import org.sonar.java.model.JavaTree;
 import org.sonar.java.resolve.Symbols;
 import org.sonar.plugins.java.api.semantic.Symbol;
 import org.sonar.plugins.java.api.tree.AnnotationTree;
@@ -32,10 +35,7 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TreeVisitor;
 
-import java.util.Collections;
-import java.util.List;
-
-public class IdentifierTreeImpl extends AbstractTypedTree implements IdentifierTree {
+public class IdentifierTreeImpl extends AbstractTypedTree implements IdentifierTree, JavaTree.AnnotatedTypeTree {
 
   private final InternalSyntaxToken nameToken;
   private Symbol symbol = Symbols.unknownSymbol;
@@ -47,9 +47,9 @@ public IdentifierTreeImpl(InternalSyntaxToken nameToken) {
     this.annotations = ImmutableList.<AnnotationTree>of();
   }
 
-  public IdentifierTreeImpl complete(List<AnnotationTree> annotations) {
+  @Override
+  public void complete(List<AnnotationTree> annotations) {
     this.annotations = Preconditions.checkNotNull(annotations);
-    return this;
   }
 
   @Override
diff --git a/java-frontend/src/main/java/org/sonar/java/model/expression/MemberSelectExpressionTreeImpl.java b/java-frontend/src/main/java/org/sonar/java/model/expression/MemberSelectExpressionTreeImpl.java
index a402980711..ceb6da82a4 100755
--- a/java-frontend/src/main/java/org/sonar/java/model/expression/MemberSelectExpressionTreeImpl.java
+++ b/java-frontend/src/main/java/org/sonar/java/model/expression/MemberSelectExpressionTreeImpl.java
@@ -23,8 +23,11 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.sonar.java.model.AbstractTypedTree;
 import org.sonar.java.model.InternalSyntaxToken;
+import org.sonar.java.model.JavaTree;
 import org.sonar.plugins.java.api.tree.AnnotationTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.IdentifierTree;
@@ -34,10 +37,7 @@
 import org.sonar.plugins.java.api.tree.TreeVisitor;
 import org.sonar.plugins.java.api.tree.TypeTree;
 
-import javax.annotation.Nullable;
-import java.util.List;
-
-public class MemberSelectExpressionTreeImpl extends AbstractTypedTree implements MemberSelectExpressionTree {
+public class MemberSelectExpressionTreeImpl extends AbstractTypedTree implements MemberSelectExpressionTree, JavaTree.AnnotatedTypeTree {
 
   private ExpressionTree expression;
 
@@ -80,9 +80,9 @@ public MemberSelectExpressionTreeImpl completeWithExpression(ExpressionTree expr
     return this;
   }
 
-  public MemberSelectExpressionTreeImpl complete(List<AnnotationTree> annotations) {
+  @Override
+  public void complete(List<AnnotationTree> annotations) {
     this.annotations = annotations;
-    return this;
   }
 
   @Override
diff --git a/java-frontend/src/main/java/org/sonar/java/model/expression/VarTypeTreeImpl.java b/java-frontend/src/main/java/org/sonar/java/model/expression/VarTypeTreeImpl.java
new file mode 100755
index 0000000000..e673d2e21a
--- /dev/null
+++ b/java-frontend/src/main/java/org/sonar/java/model/expression/VarTypeTreeImpl.java
@@ -0,0 +1,66 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.model.expression;
+
+import java.util.Collections;
+import java.util.List;
+import org.sonar.java.model.AbstractTypedTree;
+import org.sonar.java.model.InternalSyntaxToken;
+import org.sonar.plugins.java.api.tree.AnnotationTree;
+import org.sonar.plugins.java.api.tree.SyntaxToken;
+import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.TreeVisitor;
+import org.sonar.plugins.java.api.tree.VarTypeTree;
+
+public class VarTypeTreeImpl extends AbstractTypedTree implements VarTypeTree {
+
+  private final InternalSyntaxToken varToken;
+
+  public VarTypeTreeImpl(InternalSyntaxToken varToken) {
+    super(Tree.Kind.VAR_TYPE);
+    this.varToken = varToken;
+  }
+
+  @Override
+  public SyntaxToken varToken() {
+    return varToken;
+  }
+
+  @Override
+  public Tree.Kind kind() {
+    return Tree.Kind.VAR_TYPE;
+  }
+
+  @Override
+  public void accept(TreeVisitor visitor) {
+    visitor.visitVarType(this);
+  }
+
+  @Override
+  protected Iterable<Tree> children() {
+    return Collections.singletonList(varToken);
+  }
+
+  @Override
+  public List<AnnotationTree> annotations() {
+    return Collections.emptyList();
+  }
+
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/FirstPass.java b/java-frontend/src/main/java/org/sonar/java/resolve/FirstPass.java
index ed9e4d4135..683631e15c 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/FirstPass.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/FirstPass.java
@@ -22,6 +22,9 @@
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import java.util.Collections;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.sonar.java.ast.api.JavaPunctuator;
 import org.sonar.java.model.LiteralUtils;
 import org.sonar.java.model.ModifiersUtils;
@@ -55,11 +58,6 @@
 import org.sonar.plugins.java.api.tree.TypeParameterTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import javax.annotation.Nullable;
-
-import java.util.Collections;
-import java.util.List;
-
 /**
  * Defines scopes and symbols.
  */
@@ -270,12 +268,15 @@ public void visitClass(ClassTree tree) {
       ArrayJavaType enumArrayType = new ArrayJavaType(symbol.type, symbols.arrayClass);
       MethodJavaType valuesMethodType = new MethodJavaType(ImmutableList.<JavaType>of(), enumArrayType, ImmutableList.<JavaType>of(), symbol);
       valuesMethod.setMethodType(valuesMethodType);
+      valuesMethod.parameters = new Scope(valuesMethod);
       classEnv.scope.enter(valuesMethod);
 
       // add 'public static E valueOf(String name)'
       JavaSymbol.MethodJavaSymbol valueOfMethod = new JavaSymbol.MethodJavaSymbol((symbol.flags & Flags.ACCESS_FLAGS) | Flags.STATIC, "valueOf", symbol);
       MethodJavaType valueOfMethodType = new MethodJavaType(ImmutableList.<JavaType>of(symbols.stringType), symbol.type, ImmutableList.<JavaType>of(), symbol);
       valueOfMethod.setMethodType(valueOfMethodType);
+      valueOfMethod.parameters = new Scope(valueOfMethod);
+      valueOfMethod.parameters.enter(new JavaSymbol.VariableJavaSymbol(0, "name", symbols.stringType, valueOfMethod));
       classEnv.scope.enter(valueOfMethod);
     }
     restoreEnvironment(tree);
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/JavaSymbol.java b/java-frontend/src/main/java/org/sonar/java/resolve/JavaSymbol.java
index f9248d3050..f9b71476f9 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/JavaSymbol.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/JavaSymbol.java
@@ -729,6 +729,10 @@ public MethodTree declaration() {
       return declaration;
     }
 
+    public boolean isOverridable() {
+      return !(isPrivate() || isStatic() || isFinal() || owner().isFinal());
+    }
+
     public boolean isParametrized() {
       return !typeVariableTypes.isEmpty();
     }
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/LeastUpperBound.java b/java-frontend/src/main/java/org/sonar/java/resolve/LeastUpperBound.java
index c034abf8b2..1245e20262 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/LeastUpperBound.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/LeastUpperBound.java
@@ -127,6 +127,12 @@ private Type cachedLeastUpperBound(Set<Type> types) {
 
     Symbol.TypeSymbol symbol = type.symbol();
     TypeSubstitution substitution = getTypeSubstitution(type);
+    if(substitution.size() == 0 && !((JavaSymbol.TypeJavaSymbol) symbol).typeVariableTypes.isEmpty()) {
+      // raw type : let's create a substitution based on erasures
+      TypeSubstitution ts = new TypeSubstitution();
+      ((JavaSymbol.TypeJavaSymbol) symbol).typeVariableTypes.forEach(t -> ts.add(t, t.erasure()));
+      substitution = ts;
+    }
 
     result.addAll(interfacesWithSubstitution(symbol, substitution));
 
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java b/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
index 28b270c2bc..11eaca23b4 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/SecondPass.java
@@ -23,6 +23,9 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Sets;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
 import org.sonar.java.model.AbstractTypedTree;
 import org.sonar.java.model.declaration.VariableTreeImpl;
 import org.sonar.plugins.java.api.tree.ClassTree;
@@ -33,10 +36,6 @@
 import org.sonar.plugins.java.api.tree.TypeTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import java.util.List;
-import java.util.Objects;
-import java.util.Set;
-
 /**
  * Completes hierarchy of types.
  */
@@ -125,6 +124,7 @@ private void complete(JavaSymbol.TypeJavaSymbol symbol) {
       JavaSymbol.MethodJavaSymbol defaultConstructor = new JavaSymbol.MethodJavaSymbol(symbol.flags & Flags.ACCESS_FLAGS, CONSTRUCTOR_NAME, symbol);
       MethodJavaType defaultConstructorType = new MethodJavaType(argTypes, null, ImmutableList.of(), symbol);
       defaultConstructor.setMethodType(defaultConstructorType);
+      defaultConstructor.parameters = new Scope(defaultConstructor);
       symbol.members.enter(defaultConstructor);
     }
   }
@@ -249,6 +249,7 @@ private static boolean checkTypeOfTree(Tree tree) {
       Tree.Kind.ARRAY_TYPE,
       Tree.Kind.UNION_TYPE,
       Tree.Kind.PRIMITIVE_TYPE,
+      Tree.Kind.VAR_TYPE,
       Tree.Kind.INFERED_TYPE);
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/resolve/TypeAndReferenceSolver.java b/java-frontend/src/main/java/org/sonar/java/resolve/TypeAndReferenceSolver.java
index de4275ac8a..9d9ab17d0e 100755
--- a/java-frontend/src/main/java/org/sonar/java/resolve/TypeAndReferenceSolver.java
+++ b/java-frontend/src/main/java/org/sonar/java/resolve/TypeAndReferenceSolver.java
@@ -23,6 +23,15 @@
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Maps;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import javax.annotation.CheckForNull;
+import javax.annotation.Nullable;
 import org.sonar.java.ast.api.JavaKeyword;
 import org.sonar.java.model.AbstractTypedTree;
 import org.sonar.java.model.declaration.VariableTreeImpl;
@@ -79,17 +88,6 @@
 import org.sonar.plugins.java.api.tree.VariableTree;
 import org.sonar.plugins.java.api.tree.WildcardTree;
 
-import javax.annotation.CheckForNull;
-import javax.annotation.Nullable;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-import java.util.Optional;
-import java.util.stream.Collectors;
-import java.util.stream.IntStream;
-
 /**
  * Computes types and references of Identifier and MemberSelectExpression.
  */
@@ -395,7 +393,7 @@ public JavaSymbol resolveAs(Tree tree, int kind, Resolve.Env resolveEnv, boolean
     }
     tree.accept(this);
     JavaType type = getType(tree);
-    if (tree.is(Tree.Kind.INFERED_TYPE)) {
+    if (tree.is(Tree.Kind.INFERED_TYPE, Tree.Kind.VAR_TYPE)) {
       type = symbols.deferedType((AbstractTypedTree) tree);
       registerType(tree, type);
     }
diff --git a/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java b/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java
index 66fa184a8d..1dee7ac90c 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/ExplodedGraphWalker.java
@@ -808,12 +808,16 @@ private static boolean isCatchingUncheckedException(CFG.Block catchBlock) {
    * @see JLS8 4.12.5 for details
    */
   private void executeVariable(VariableTree variableTree, @Nullable Tree terminator) {
+    Symbol variableSymbol = variableTree.symbol();
     if (variableTree.initializer() == null) {
       SymbolicValue sv = null;
       if (terminator != null && terminator.is(Tree.Kind.FOR_EACH_STATEMENT)) {
         sv = constraintManager.createSymbolicValue(variableTree);
+        if (isAnnotatedNonNull(variableSymbol)) {
+          programState = programState.addConstraint(sv, ObjectConstraint.NOT_NULL);
+        }
       } else if (variableTree.parent().is(Tree.Kind.CATCH)) {
-        sv = handleCatchVariable(variableTree.symbol().type());
+        sv = handleCatchVariable(variableSymbol.type());
         // an exception have been thrown and caught, stack must be cleared
         // see notes in JVMS 8 - 6.5. - instruction "athrow"
         programState = programState.clearStack();
@@ -821,12 +825,12 @@ private void executeVariable(VariableTree variableTree, @Nullable Tree terminato
         programState = programState.addConstraint(sv, ObjectConstraint.NOT_NULL);
       }
       if (sv != null) {
-        programState = programState.put(variableTree.symbol(), sv);
+        programState = programState.put(variableSymbol, sv);
       }
     } else {
       ProgramState.Pop unstack = programState.unstackValue(1);
       programState = unstack.state;
-      programState = programState.put(variableTree.symbol(), unstack.values.get(0));
+      programState = programState.put(variableSymbol, unstack.values.get(0));
     }
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/se/SymbolicExecutionMode.java b/java-frontend/src/main/java/org/sonar/java/se/SymbolicExecutionMode.java
index 05f4eae7b5..b369fdb555 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/SymbolicExecutionMode.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/SymbolicExecutionMode.java
@@ -21,21 +21,21 @@
 
 import java.util.Arrays;
 import org.sonar.java.se.checks.SECheck;
-import org.sonar.squidbridge.api.CodeVisitor;
+import org.sonar.plugins.java.api.JavaCheck;
 
 public enum SymbolicExecutionMode {
   DISABLED,
   ENABLED_WITHOUT_X_FILE,
   ENABLED;
 
-  public static SymbolicExecutionMode getMode(CodeVisitor[] visitors, boolean xFileEnabled) {
+  public static SymbolicExecutionMode getMode(JavaCheck[] visitors, boolean xFileEnabled) {
     if (hasASymbolicExecutionCheck(visitors)) {
       return xFileEnabled ? SymbolicExecutionMode.ENABLED : SymbolicExecutionMode.ENABLED_WITHOUT_X_FILE;
     }
     return SymbolicExecutionMode.DISABLED;
   }
 
-  private static boolean hasASymbolicExecutionCheck(CodeVisitor[] visitors) {
+  private static boolean hasASymbolicExecutionCheck(JavaCheck[] visitors) {
     return Arrays.stream(visitors).anyMatch(v -> v instanceof SECheck);
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/se/checks/CustomUnclosedResourcesCheck.java b/java-frontend/src/main/java/org/sonar/java/se/checks/CustomUnclosedResourcesCheck.java
index 616ef86ebf..9048c71f7d 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/checks/CustomUnclosedResourcesCheck.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/checks/CustomUnclosedResourcesCheck.java
@@ -20,6 +20,8 @@
 package org.sonar.java.se.checks;
 
 import com.google.common.collect.Lists;
+import java.util.List;
+import javax.annotation.Nullable;
 import org.sonar.check.Rule;
 import org.sonar.check.RuleProperty;
 import org.sonar.java.matcher.MethodMatcherCollection;
@@ -38,14 +40,8 @@
 import org.sonar.plugins.java.api.tree.NewClassTree;
 import org.sonar.plugins.java.api.tree.ReturnStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
-import org.sonar.squidbridge.annotations.RuleTemplate;
-
-import javax.annotation.Nullable;
-
-import java.util.List;
 
 @Rule(key = "S3546")
-@RuleTemplate
 public class CustomUnclosedResourcesCheck extends SECheck {
 
   //see SONARJAVA-1624 class cannot be static, different classes are needed for every instance of this template rule
diff --git a/java-frontend/src/main/java/org/sonar/java/se/checks/NonNullSetToNullCheck.java b/java-frontend/src/main/java/org/sonar/java/se/checks/NonNullSetToNullCheck.java
index 3bbaf3e47d..9265960cde 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/checks/NonNullSetToNullCheck.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/checks/NonNullSetToNullCheck.java
@@ -28,7 +28,6 @@
 import org.sonar.java.cfg.CFG;
 import org.sonar.java.model.ExpressionUtils;
 import org.sonar.java.resolve.JavaSymbol;
-import org.sonar.java.resolve.Scope;
 import org.sonar.java.se.CheckerContext;
 import org.sonar.java.se.ProgramState;
 import org.sonar.java.se.constraint.ConstraintManager;
@@ -131,7 +130,7 @@ private static boolean callsThisConstructor(MethodTree constructor) {
 
   private void checkVariable(CheckerContext context, MethodTree tree, final Symbol symbol) {
     String nonNullAnnotation = nonNullAnnotation(symbol);
-    if (nonNullAnnotation == null) {
+    if (nonNullAnnotation == null || symbol.isStatic()) {
       return;
     }
     if (isUndefinedOrNull(context, symbol)) {
@@ -208,17 +207,14 @@ public void visitMethodInvocation(MethodInvocationTree syntaxTree) {
     }
 
     private void checkNullArguments(Tree syntaxTree, JavaSymbol.MethodJavaSymbol symbol, List<SymbolicValue> argumentValues) {
-      Scope parameters = symbol.getParameters();
-      if (parameters != null) {
-        List<JavaSymbol> scopeSymbols = parameters.scopeSymbols();
-        int parametersToTest = argumentValues.size();
-        if (scopeSymbols.size() < parametersToTest) {
-          // The last parameter is a variable length argument: the non-null condition does not apply to its values
-          parametersToTest = scopeSymbols.size() - 1;
-        }
-        for (int i = 0; i < parametersToTest; i++) {
-          checkNullArgument(syntaxTree, symbol, scopeSymbols.get(i), argumentValues.get(i), i);
-        }
+      List<JavaSymbol> scopeSymbols = symbol.getParameters().scopeSymbols();
+      int parametersToTest = argumentValues.size();
+      if (scopeSymbols.size() < parametersToTest) {
+        // The last parameter is a variable length argument: the non-null condition does not apply to its values
+        parametersToTest = scopeSymbols.size() - 1;
+      }
+      for (int i = 0; i < parametersToTest; i++) {
+        checkNullArgument(syntaxTree, symbol, scopeSymbols.get(i), argumentValues.get(i), i);
       }
     }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/se/checks/ParameterNullnessCheck.java b/java-frontend/src/main/java/org/sonar/java/se/checks/ParameterNullnessCheck.java
new file mode 100755
index 0000000000..07a9c781f8
--- /dev/null
+++ b/java-frontend/src/main/java/org/sonar/java/se/checks/ParameterNullnessCheck.java
@@ -0,0 +1,118 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.se.checks;
+
+import com.google.common.collect.Lists;
+import java.util.Collections;
+import java.util.List;
+import org.apache.commons.lang.StringUtils;
+import org.sonar.check.Rule;
+import org.sonar.java.model.ExpressionUtils;
+import org.sonar.java.resolve.JavaSymbol;
+import org.sonar.java.se.CheckerContext;
+import org.sonar.java.se.Flow;
+import org.sonar.java.se.ProgramState;
+import org.sonar.java.se.constraint.ObjectConstraint;
+import org.sonar.java.se.symbolicvalues.SymbolicValue;
+import org.sonar.plugins.java.api.JavaFileScannerContext;
+import org.sonar.plugins.java.api.semantic.Symbol;
+import org.sonar.plugins.java.api.tree.Arguments;
+import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.plugins.java.api.tree.MethodTree;
+import org.sonar.plugins.java.api.tree.NewClassTree;
+import org.sonar.plugins.java.api.tree.Tree;
+
+import static org.sonar.java.se.ExplodedGraphWalker.EQUALS_METHODS;
+import static org.sonar.java.se.NullableAnnotationUtils.isAnnotatedNullable;
+import static org.sonar.java.se.NullableAnnotationUtils.nonNullAnnotationOnParameters;
+
+@Rule(key = "S4449")
+public class ParameterNullnessCheck extends SECheck {
+
+  @Override
+  public ProgramState checkPreStatement(CheckerContext context, Tree syntaxNode) {
+    ProgramState state = context.getState();
+    if (syntaxNode.is(Tree.Kind.METHOD_INVOCATION)) {
+      MethodInvocationTree mit = (MethodInvocationTree) syntaxNode;
+      checkParameters(mit, mit.symbol(), mit.arguments(), state);
+    } else if (syntaxNode.is(Tree.Kind.NEW_CLASS)) {
+      NewClassTree nct = (NewClassTree) syntaxNode;
+      checkParameters(nct, nct.constructorSymbol(), nct.arguments(), state);
+    }
+    return state;
+  }
+
+  private void checkParameters(Tree syntaxNode, Symbol symbol, Arguments arguments, ProgramState state) {
+    if (!symbol.isMethodSymbol() || arguments.isEmpty()) {
+      return;
+    }
+    JavaSymbol.MethodJavaSymbol methodSymbol = (JavaSymbol.MethodJavaSymbol) symbol;
+    if (nonNullAnnotationOnParameters(methodSymbol) == null) {
+      // method is not annotated (locally or globally)
+      return;
+    }
+    int nbArguments = arguments.size();
+    List<SymbolicValue> argumentSVs = getArgumentSVs(state, syntaxNode, nbArguments);
+    List<JavaSymbol> argumentSymbols = methodSymbol.getParameters().scopeSymbols();
+    int nbArgumentToCheck = Math.min(nbArguments, argumentSymbols.size() - (methodSymbol.isVarArgs() ? 1 : 0));
+    for (int i = 0; i < nbArgumentToCheck; i++) {
+      ObjectConstraint constraint = state.getConstraint(argumentSVs.get(i), ObjectConstraint.class);
+      if (constraint != null && constraint.isNull() && !parameterIsNullable(methodSymbol, argumentSymbols.get(i))) {
+        reportIssue(syntaxNode, arguments.get(i), methodSymbol);
+      }
+    }
+  }
+
+  private void reportIssue(Tree syntaxNode, ExpressionTree argument, JavaSymbol.MethodJavaSymbol methodSymbol) {
+    String declarationMessage = "constructor declaration";
+    if (!methodSymbol.isConstructor()) {
+      declarationMessage = "method '" + methodSymbol.getName() + "' declaration";
+    }
+    String message = String.format("Annotate the parameter with @javax.annotation.Nullable in %s, or make sure that null can not be passed as argument.", declarationMessage);
+
+    Tree reportTree;
+    if (syntaxNode.is(Tree.Kind.METHOD_INVOCATION)) {
+      reportTree = ExpressionUtils.methodName((MethodInvocationTree) syntaxNode);
+    } else {
+      reportTree = ((NewClassTree) syntaxNode).identifier();
+    }
+
+    Flow.Builder secondaryBuilder = Flow.builder();
+    MethodTree declarationTree = methodSymbol.declaration();
+    if (declarationTree != null) {
+      secondaryBuilder.add(new JavaFileScannerContext.Location(StringUtils.capitalize(declarationMessage) + ".", declarationTree.simpleName()));
+    }
+    secondaryBuilder.add(new JavaFileScannerContext.Location("Argument can be null.", argument));
+
+    reportIssue(reportTree, message, Collections.singleton(secondaryBuilder.build()));
+  }
+
+  private static List<SymbolicValue> getArgumentSVs(ProgramState state, Tree syntaxNode, int nbArguments) {
+    if (syntaxNode.is(Tree.Kind.METHOD_INVOCATION)) {
+      return Lists.reverse(state.peekValues(nbArguments + 1).subList(0, nbArguments));
+    }
+    return Lists.reverse(state.peekValues(nbArguments));
+  }
+
+  private static boolean parameterIsNullable(Symbol.MethodSymbol method, Symbol argumentSymbol) {
+    return isAnnotatedNullable(argumentSymbol) || EQUALS_METHODS.anyMatch(method);
+  }
+}
diff --git a/java-frontend/src/main/java/org/sonar/java/se/xproc/BehaviorCache.java b/java-frontend/src/main/java/org/sonar/java/se/xproc/BehaviorCache.java
index bef8ff240a..0085ce79a6 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/xproc/BehaviorCache.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/xproc/BehaviorCache.java
@@ -87,7 +87,9 @@
     "com.google.common.base.Preconditions#checkNotNull",
     "com.google.common.base.Preconditions#checkArgument",
     "com.google.common.base.Preconditions#checkState",
+
     "com.google.common.base.Strings#isNullOrEmpty",
+    "com.google.common.base.Platform#stringIsNullOrEmpty",
 
     "org.eclipse.core.runtime.Assert#");
 
diff --git a/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYield.java b/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYield.java
index 8ce117ba10..4adb59f2f2 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYield.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYield.java
@@ -56,7 +56,7 @@ public ExceptionalCheckBasedYield(SymbolicValue svCausingException, String excep
     this.svCausingException = svCausingException;
     this.isMethodVarargs = behavior.isMethodVarArgs();
     Preconditions.checkArgument(exceptionType != null, "Exception type is required");
-    super.setExceptionType(exceptionType);
+    super.setExceptionTypeName(exceptionType);
   }
 
   @Override
@@ -123,7 +123,12 @@ private static ConstraintsByDomain argumentConstraint(List<SymbolicValue> invoca
   }
 
   @Override
-  public void setExceptionType(String exceptionType) {
+  public void setExceptionTypeName(String exceptionType) {
+    throw new UnsupportedOperationException("Exception type can not be changed");
+  }
+
+  @Override
+  public void setExceptionType(Type exceptionType) {
     throw new UnsupportedOperationException("Exception type can not be changed");
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalYield.java b/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalYield.java
index 42291d2d35..05554c59fd 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalYield.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/xproc/ExceptionalYield.java
@@ -37,7 +37,10 @@
 public class ExceptionalYield extends MethodYield {
 
   @Nullable
-  private String exceptionType;
+  private Type exceptionType;
+
+  @Nullable
+  private String exceptionTypeName;
 
   public ExceptionalYield(MethodBehavior behavior) {
     super(behavior);
@@ -57,23 +60,38 @@ public ExceptionalYield(ExplodedGraph.Node node, MethodBehavior behavior) {
       .distinct();
   }
 
-  public void setExceptionType(String exceptionType) {
+  public void setExceptionType(Type exceptionType) {
     this.exceptionType = exceptionType;
+    this.exceptionTypeName = null;
+  }
+
+  public void setExceptionTypeName(String exceptionTypeName) {
+    this.exceptionTypeName = exceptionTypeName;
+    this.exceptionType = null;
   }
 
   public Type exceptionType(SemanticModel semanticModel) {
-    if (exceptionType == null) {
-      return Symbols.unknownType;
+    if (exceptionType != null) {
+      return exceptionType;
+    }
+    if (exceptionTypeName != null) {
+      Type type = semanticModel.getClassType(this.exceptionTypeName);
+      return type == null ? Symbols.unknownType : type;
     }
-    Type type = semanticModel.getClassType(this.exceptionType);
-    return type == null ? Symbols.unknownType : type;
+    return Symbols.unknownType;
   }
 
   @Override
   public String toString() {
+    String typeName = "";
+    if (exceptionType != null) {
+      typeName = " (" + exceptionType.fullyQualifiedName() + ")";
+    } else if (exceptionTypeName != null) {
+      typeName = " (" + exceptionTypeName + ")";
+    }
     return String.format("{params: %s, exceptional%s}",
       parametersConstraints.stream().map(constraints -> constraints.stream().map(Constraint::toString).collect(Collectors.toList())).collect(Collectors.toList()),
-      exceptionType == null ? "" : (" (" + exceptionType + ")"));
+      typeName);
   }
 
   @Override
@@ -81,6 +99,7 @@ public int hashCode() {
     return new HashCodeBuilder(3, 1295)
       .appendSuper(super.hashCode())
       .append(exceptionType)
+      .append(exceptionTypeName)
       .hashCode();
   }
 
@@ -96,6 +115,7 @@ public boolean equals(Object obj) {
     return new EqualsBuilder()
       .appendSuper(super.equals(obj))
       .append(exceptionType, other.exceptionType)
+      .append(exceptionTypeName, other.exceptionTypeName)
       .isEquals();
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/java/se/xproc/MethodBehavior.java b/java-frontend/src/main/java/org/sonar/java/se/xproc/MethodBehavior.java
index 7e118dbc93..ccfd098fd6 100755
--- a/java-frontend/src/main/java/org/sonar/java/se/xproc/MethodBehavior.java
+++ b/java-frontend/src/main/java/org/sonar/java/se/xproc/MethodBehavior.java
@@ -84,11 +84,7 @@ public void createYield(ExplodedGraph.Node node, boolean storeNodeForReporting)
       ExceptionalYield exceptionalYield = new ExceptionalYield(nodeForYield, this);
       if (resultSV != null) {
         Type type = ((SymbolicValue.ExceptionalSymbolicValue) resultSV).exceptionType();
-        String typeName = null;
-        if(type != null) {
-          typeName = type.fullyQualifiedName();
-        }
-        exceptionalYield.setExceptionType(typeName);
+        exceptionalYield.setExceptionType(type);
       }
       yield = exceptionalYield;
     } else {
diff --git a/java-frontend/src/main/java/org/sonar/java/xml/XmlAnalyzer.java b/java-frontend/src/main/java/org/sonar/java/xml/XmlAnalyzer.java
index 9f072aef3d..ca702f6b52 100755
--- a/java-frontend/src/main/java/org/sonar/java/xml/XmlAnalyzer.java
+++ b/java-frontend/src/main/java/org/sonar/java/xml/XmlAnalyzer.java
@@ -20,8 +20,13 @@
 package org.sonar.java.xml;
 
 import com.google.common.collect.ImmutableList;
-import com.google.common.collect.Iterables;
-import com.google.common.collect.Lists;
+import java.io.File;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
+import java.util.stream.Collectors;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathFactory;
 import org.sonar.api.utils.log.Logger;
 import org.sonar.api.utils.log.Loggers;
 import org.sonar.java.SonarComponents;
@@ -30,17 +35,10 @@
 import org.sonar.java.xml.maven.PomCheckContextImpl;
 import org.sonar.java.xml.maven.PomParser;
 import org.sonar.maven.model.maven2.MavenProject;
+import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.squidbridge.ProgressReport;
-import org.sonar.squidbridge.api.CodeVisitor;
 import org.w3c.dom.Document;
 
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathFactory;
-
-import java.io.File;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
 public class XmlAnalyzer {
 
   private static final Logger LOG = Loggers.get(XmlAnalyzer.class);
@@ -49,10 +47,10 @@
   private final List<PomCheck> pomChecks;
   private final XPath xPath;
 
-  public XmlAnalyzer(SonarComponents sonarComponents, CodeVisitor... visitors) {
+  public XmlAnalyzer(SonarComponents sonarComponents, JavaCheck... visitors) {
     ImmutableList.Builder<XmlCheck> xmlChecksBuilder = ImmutableList.builder();
     ImmutableList.Builder<PomCheck> pomChecksBuilder = ImmutableList.builder();
-    for (CodeVisitor visitor : visitors) {
+    for (JavaCheck visitor : visitors) {
       if (visitor instanceof XmlCheck) {
         xmlChecksBuilder.add((XmlCheck) visitor);
       } else if (visitor instanceof PomCheck) {
@@ -65,15 +63,15 @@ public XmlAnalyzer(SonarComponents sonarComponents, CodeVisitor... visitors) {
     this.xPath = XPathFactory.newInstance().newXPath();
   }
 
-  public void scan(Iterable<File> files) {
+  public void scan(Collection<File> files) {
     boolean hasChecks = !xmlChecks.isEmpty() || !pomChecks.isEmpty();
-    if (hasChecks && Iterables.isEmpty(files)) {
+    if (hasChecks && files.isEmpty()) {
       LOG.warn("No 'xml' file have been indexed.");
       return;
     }
 
     ProgressReport progressReport = new ProgressReport("Report about progress of Xml analyzer", TimeUnit.SECONDS.toMillis(10));
-    progressReport.start(Lists.newArrayList(files));
+    progressReport.start(files.stream().map(File::getAbsolutePath).collect(Collectors.toList()));
 
     boolean successfulyCompleted = false;
     try {
diff --git a/java-frontend/src/main/java/org/sonar/java/xml/XmlCheckContextImpl.java b/java-frontend/src/main/java/org/sonar/java/xml/XmlCheckContextImpl.java
index ec72f904f5..f3b59668bb 100755
--- a/java-frontend/src/main/java/org/sonar/java/xml/XmlCheckContextImpl.java
+++ b/java-frontend/src/main/java/org/sonar/java/xml/XmlCheckContextImpl.java
@@ -20,27 +20,25 @@
 package org.sonar.java.xml;
 
 import com.google.common.collect.ImmutableList;
+import java.io.File;
+import java.util.Collections;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import javax.annotation.CheckForNull;
+import javax.annotation.Nullable;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathConstants;
+import javax.xml.xpath.XPathExpression;
+import javax.xml.xpath.XPathExpressionException;
+import org.sonar.java.AnalysisException;
 import org.sonar.java.AnalyzerMessage;
 import org.sonar.java.AnalyzerMessage.TextSpan;
 import org.sonar.java.SonarComponents;
 import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.squidbridge.api.AnalysisException;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 
-import javax.annotation.CheckForNull;
-import javax.annotation.Nullable;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathConstants;
-import javax.xml.xpath.XPathExpression;
-import javax.xml.xpath.XPathExpressionException;
-
-import java.io.File;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
 import static org.sonar.java.xml.XmlCheckUtils.nodeLine;
 
 public class XmlCheckContextImpl implements XmlCheckContext {
diff --git a/java-frontend/src/main/java/org/sonar/plugins/java/api/JavaCheck.java b/java-frontend/src/main/java/org/sonar/plugins/java/api/JavaCheck.java
index f1e97a59a6..027e544c7e 100755
--- a/java-frontend/src/main/java/org/sonar/plugins/java/api/JavaCheck.java
+++ b/java-frontend/src/main/java/org/sonar/plugins/java/api/JavaCheck.java
@@ -19,10 +19,8 @@
  */
 package org.sonar.plugins.java.api;
 
-import org.sonar.squidbridge.api.CodeVisitor;
-
 /**
  * Marker interface for all checks of the java analyzer.
  */
-public interface JavaCheck extends CodeVisitor{
+public interface JavaCheck {
 }
diff --git a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/BaseTreeVisitor.java b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/BaseTreeVisitor.java
index 64095504ab..620b16ea6e 100755
--- a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/BaseTreeVisitor.java
+++ b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/BaseTreeVisitor.java
@@ -20,11 +20,9 @@
 package org.sonar.plugins.java.api.tree;
 
 import com.google.common.annotations.Beta;
-import org.sonar.java.model.expression.TypeArgumentListTreeImpl;
-
-import javax.annotation.Nullable;
-
 import java.util.List;
+import javax.annotation.Nullable;
+import org.sonar.java.model.expression.TypeArgumentListTreeImpl;
 
 /**
  * Default implementation of {@link TreeVisitor}.
@@ -64,6 +62,7 @@ public void visitImport(ImportTree tree) {
   @Override
   public void visitClass(ClassTree tree) {
     scan(tree.modifiers());
+    scan(tree.simpleName());
     scan(tree.typeParameters());
     scan(tree.superClass());
     scan(tree.superInterfaces());
@@ -75,6 +74,7 @@ public void visitMethod(MethodTree tree) {
     scan(tree.modifiers());
     scan(tree.typeParameters());
     scan(tree.returnType());
+    scan(tree.simpleName());
     scan(tree.parameters());
     scan(tree.defaultValue());
     scan(tree.throwsClauses());
@@ -286,10 +286,16 @@ public void visitIdentifier(IdentifierTree tree) {
     scan(tree.annotations());
   }
 
+  @Override
+  public void visitVarType(VarTypeTree tree) {
+    scan(tree.annotations());
+  }
+
   @Override
   public void visitVariable(VariableTree tree) {
     scan(tree.modifiers());
     scan(tree.type());
+    scan(tree.simpleName());
     scan(tree.initializer());
   }
 
@@ -306,6 +312,7 @@ public void visitArrayType(ArrayTypeTree tree) {
   @Override
   public void visitEnumConstant(EnumConstantTree tree) {
     scan(tree.modifiers());
+    scan(tree.simpleName());
     scan(tree.initializer());
   }
 
diff --git a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/Tree.java b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/Tree.java
index dc5b5a625a..2b1faea1ea 100755
--- a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/Tree.java
+++ b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/Tree.java
@@ -20,9 +20,8 @@
 package org.sonar.plugins.java.api.tree;
 
 import com.google.common.annotations.Beta;
-import org.sonar.sslr.grammar.GrammarRuleKey;
-
 import javax.annotation.Nullable;
+import org.sonar.sslr.grammar.GrammarRuleKey;
 
 /**
  * Common interface for all nodes in a syntax tree.
@@ -537,6 +536,11 @@
      */
     IDENTIFIER(IdentifierTree.class),
 
+    /**
+     * {@link VarTypeTree}
+     */
+    VAR_TYPE(VarTypeTree.class),
+
     /**
      * {@link VariableTree}
      */
diff --git a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/TreeVisitor.java b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/TreeVisitor.java
index a09225af0d..85f489de02 100755
--- a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/TreeVisitor.java
+++ b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/TreeVisitor.java
@@ -104,6 +104,8 @@
 
   void visitIdentifier(IdentifierTree tree);
 
+  void visitVarType(VarTypeTree tree);
+
   void visitVariable(VariableTree tree);
 
   void visitEnumConstant(EnumConstantTree tree);
diff --git a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/VarTypeTree.java b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/VarTypeTree.java
new file mode 100755
index 0000000000..14b0b64d5b
--- /dev/null
+++ b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/VarTypeTree.java
@@ -0,0 +1,40 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.plugins.java.api.tree;
+
+import com.google.common.annotations.Beta;
+
+/**
+ * 'var' type tree used for local variables.
+ *
+ * JLS 10 - 14.4
+ *
+ * <pre>
+ *   {@link #varToken()}
+ * </pre>
+ *
+ * @since Java 10
+ */
+@Beta
+public interface VarTypeTree extends TypeTree {
+
+  SyntaxToken varToken();
+
+}
diff --git a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/WildcardTree.java b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/WildcardTree.java
index 8173beb8c6..6f3ef84ca0 100755
--- a/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/WildcardTree.java
+++ b/java-frontend/src/main/java/org/sonar/plugins/java/api/tree/WildcardTree.java
@@ -20,10 +20,8 @@
 package org.sonar.plugins.java.api.tree;
 
 import com.google.common.annotations.Beta;
-
-import javax.annotation.Nullable;
-
 import java.util.List;
+import javax.annotation.Nullable;
 
 /**
  * Wildcard type argument.
@@ -47,8 +45,9 @@
  * @since Java 1.5
  */
 @Beta
-public interface WildcardTree extends Tree {
+public interface WildcardTree extends TypeTree {
 
+  @Override
   List<AnnotationTree> annotations();
 
   SyntaxToken queryToken();
diff --git a/java-frontend/src/test/files/highlighter/Java10Var.java b/java-frontend/src/test/files/highlighter/Java10Var.java
new file mode 100755
index 0000000000..487f8953ee
--- /dev/null
+++ b/java-frontend/src/test/files/highlighter/Java10Var.java
@@ -0,0 +1,53 @@
+import java.util.ArrayList;
+import java.net.URL;
+import java.io.BufferedReader;
+import java.io.InputStreamReader;
+
+class A {
+
+  void foo() throws Exception {
+    // various usages of 'var'
+    var a = 2;
+
+    var list = new ArrayList<String>();
+
+    list.add("hello");
+    list.add("world");
+
+    for (var counter = 0; counter < list.size(); counter++) {
+      var value = list.get(counter);
+    }
+
+    for (var value : list) {
+      value.length();
+    }
+
+    var url = new URL("http://www.oracle.com/");
+    var conn = url.openConnection();
+    try (var reader = new BufferedReader(new InputStreamReader(conn.getInputStream()))) {
+      var stream = reader.lines();
+    }
+
+    // anonymous class with new members are visible from context of declaration
+    var myA = new A() {
+
+      Object myField;
+
+      @Override
+      public void foo() {
+        this.myField = bar();
+      }
+
+      String bar() {
+        return "42";
+      }
+    };
+
+    myA.bar();
+    if (myA.myField != null) {
+      myA.foo();
+    }
+
+    Object var;
+  }
+}
diff --git a/java-frontend/src/test/files/model/ExpressionUtilsMethodNameTest.java b/java-frontend/src/test/files/model/ExpressionUtilsMethodNameTest.java
new file mode 100755
index 0000000000..122d13999d
--- /dev/null
+++ b/java-frontend/src/test/files/model/ExpressionUtilsMethodNameTest.java
@@ -0,0 +1,6 @@
+class MethodName {
+  public void foo() {
+    foo();
+    this.foo();
+  }
+}
diff --git a/java-frontend/src/test/files/se/NonNullSetToNullCheck.java b/java-frontend/src/test/files/se/NonNullSetToNullCheck.java
index 61ea0c4d24..b0ea3eb155 100755
--- a/java-frontend/src/test/files/se/NonNullSetToNullCheck.java
+++ b/java-frontend/src/test/files/se/NonNullSetToNullCheck.java
@@ -12,6 +12,10 @@
   private String primary;
   private String secondary;
 
+  @Nonnull
+  private static final Integer STATIC_FIELD; // Compliant as static fields are not reported
+  private static final Integer STATIC_FIELD_NO_ANNOTATION;
+
   public MainClass(String color) {
     if (color != null) {
       secondary = null;
@@ -218,6 +222,9 @@ public JpaMappedSuperclass(String name) {
 }
 
 class FieldWithInitializer {
+  @Nonnull
+  private static final Integer STATIC_FIELD = null; // Compliant as static fields are not reported
+  private static final Integer STATIC_FIELD_NO_ANNOTATION = null;
   @Nonnull
   private final Integer val1 = calculate();
   @Nonnull
diff --git a/java-frontend/src/test/files/se/NullDereferenceCheck.java b/java-frontend/src/test/files/se/NullDereferenceCheck.java
index 35833b25a0..3cb5759283 100755
--- a/java-frontend/src/test/files/se/NullDereferenceCheck.java
+++ b/java-frontend/src/test/files/se/NullDereferenceCheck.java
@@ -777,3 +777,23 @@ void fun(java.util.Optional<String> opt) {
      s.toString(); // Noncompliant
   }
 }
+
+abstract class NonNullAnnotationOnForEach {
+  void foo(List<Object> items) {
+    for (@Nonnull Object item : items) {
+      Object o = qix(bar(item)); // 'bar' can only be called with non-null constraint
+      if ("foo".equals(o.toString())) {
+        item.toString(); // Compliant
+      }
+    }
+  }
+
+  private static String bar(Object item) {
+    if (item != null) { // defensive programming
+      return item.toString();
+    }
+    return null;
+  }
+
+  abstract Object qix(String s);
+}
diff --git a/java-frontend/src/test/files/se/ParameterNullnessCheck.java b/java-frontend/src/test/files/se/ParameterNullnessCheck.java
new file mode 100755
index 0000000000..f2985a7140
--- /dev/null
+++ b/java-frontend/src/test/files/se/ParameterNullnessCheck.java
@@ -0,0 +1,53 @@
+import com.google.common.base.Preconditions;
+import javax.annotation.Nullable;
+import javax.annotation.ParametersAreNonnullByDefault;
+
+@ParametersAreNonnullByDefault
+abstract class A {
+
+  A(String s) { }
+  A(Object o1, Object o2) { } // flow@A [[order=2]] {{Constructor declaration.}}
+
+  Object field;
+
+  void foo(Object o) { // flow@foo [[order=2]] {{Method 'foo' declaration.}}
+    foo( // Noncompliant [[sc=5;ec=8;flows=foo]] {{Annotate the parameter with @javax.annotation.Nullable in method 'foo' declaration, or make sure that null can not be passed as argument.}}
+      null); // flow@foo [[order=1]] {{Argument can be null.}}
+    bar(o, null);
+    bar(null, o); // Noncompliant [[sc=5;ec=8]]
+
+    equals(null);
+    unknownMethod(null);
+    B.foo(null);
+    if (o != null) {
+      foo(o);
+    }
+    foo(field);
+    qix();
+
+    gul(null, o, null, o); // Compliant - ignore variadic argument
+    gul2(null, o, null, o); // Noncompliant [[sc=5;ec=9]] - first parameter is not variadic
+
+    A a1 = new A(null); // Noncompliant
+    A a2 = new A(o, // Noncompliant [[sc=16;ec=17;flows=A]] {{Annotate the parameter with @javax.annotation.Nullable in constructor declaration, or make sure that null can not be passed as argument.}}
+      null); // flow@A [[order=1]] {{Argument can be null.}}
+    B b = new B();
+
+    Preconditions.checkNotNull( // Noncompliant [[sc=19;ec=31;flows=checkNotNull]] 
+      null); // flow@checkNotNull [[order=1]] {{Argument can be null.}}
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    return super.equals(obj);
+  }
+
+  abstract void bar(Object o1, @Nullable Object o2);
+  abstract void qix();
+  abstract void gul(Object ... objects);
+  abstract void gul2(String s, Object ... objects);
+}
+
+class B {
+  static void foo(Object o) { }
+}
diff --git a/java-frontend/src/test/files/sym/ConditionalOperator.java b/java-frontend/src/test/files/sym/ConditionalOperator.java
new file mode 100755
index 0000000000..c2c6457c45
--- /dev/null
+++ b/java-frontend/src/test/files/sym/ConditionalOperator.java
@@ -0,0 +1,10 @@
+import java.util.List;
+public class App {
+  public class Foo<F extends List<Object>> {
+  }
+  public class Bar<G extends List<Object>> extends Foo<G> {
+  }
+  private <H extends List<Object>> Foo fun() {
+    return true ? new Bar() : new Foo<List<Object>>(); // triggers computation of least upper bound
+  }
+}
diff --git a/java-frontend/src/test/java/com/sonar/plugins/security/api/JavaRules.java b/java-frontend/src/test/java/com/sonar/plugins/security/api/JavaRules.java
new file mode 100755
index 0000000000..45c5e7fd1c
--- /dev/null
+++ b/java-frontend/src/test/java/com/sonar/plugins/security/api/JavaRules.java
@@ -0,0 +1,35 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package com.sonar.plugins.security.api;
+
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Class required to test SonarComponents
+ */
+public class JavaRules {
+
+  public static Set<String> ruleKeys = new HashSet<>();
+
+  public static Set<String> getRuleKeys() {
+    return ruleKeys;
+  }
+}
diff --git a/java-frontend/src/test/java/org/sonar/java/CommonsCollectionsTest.java b/java-frontend/src/test/java/org/sonar/java/CommonsCollectionsTest.java
index dda286bb0e..f0989ba850 100755
--- a/java-frontend/src/test/java/org/sonar/java/CommonsCollectionsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/CommonsCollectionsTest.java
@@ -20,6 +20,11 @@
 package org.sonar.java;
 
 import com.google.common.collect.Maps;
+import java.io.File;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import org.apache.commons.io.FileUtils;
 import org.junit.Test;
 import org.sonar.api.batch.fs.InputFile;
@@ -28,15 +33,9 @@
 import org.sonar.api.batch.sensor.internal.SensorContextTester;
 import org.sonar.api.issue.NoSonarFilter;
 import org.sonar.java.model.JavaVersionImpl;
+import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
 import org.sonar.plugins.java.api.JavaResourceLocator;
-import org.sonar.squidbridge.api.CodeVisitor;
-
-import java.io.File;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -90,7 +89,7 @@ public void scanFile(JavaFileScannerContext context) {
         }
       }
     };
-    squid = new JavaSquid(new JavaVersionImpl(), null, measurer, javaResourceLocator, null, new CodeVisitor[0]);
+    squid = new JavaSquid(new JavaVersionImpl(), null, measurer, javaResourceLocator, null, new JavaCheck[0]);
     squid.scan(files, Collections.<File>emptyList());
   }
 
diff --git a/java-frontend/src/test/java/org/sonar/java/JavaClasspathTest.java b/java-frontend/src/test/java/org/sonar/java/JavaClasspathTest.java
index ff963ea26c..3c0610f2ec 100755
--- a/java-frontend/src/test/java/org/sonar/java/JavaClasspathTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/JavaClasspathTest.java
@@ -30,7 +30,6 @@
 import org.sonar.api.config.internal.MapSettings;
 import org.sonar.api.utils.log.LogTester;
 import org.sonar.api.utils.log.LoggerLevel;
-import org.sonar.squidbridge.api.AnalysisException;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.Assert.fail;
diff --git a/java-frontend/src/test/java/org/sonar/java/JavaSquidTest.java b/java-frontend/src/test/java/org/sonar/java/JavaSquidTest.java
index c0badae072..ef435def33 100755
--- a/java-frontend/src/test/java/org/sonar/java/JavaSquidTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/JavaSquidTest.java
@@ -59,15 +59,8 @@
   public void number_of_visitors_in_sonarLint_context_LTS() throws Exception {
     SensorContextTester context = SensorContextTester.create(temp.getRoot().getAbsoluteFile());
 
-    // set up a file to analyze
-    File file = temp.newFile().getAbsoluteFile();
-    Files.write("/***/\nclass A {\n String foo() {\n  return foo();\n }\n}", file, StandardCharsets.UTF_8);
-    DefaultInputFile defaultFile = new TestInputFileBuilder(temp.getRoot().getAbsolutePath(), file.getName())
-      .setLanguage("java")
-      .initMetadata(new String(java.nio.file.Files.readAllBytes(file.getAbsoluteFile().toPath()), StandardCharsets.UTF_8))
-      .setCharset(StandardCharsets.UTF_8)
-      .build();
-    context.fileSystem().add(defaultFile);
+    String code = "/***/\nclass A {\n String foo() {\n  return foo();\n }\n}";
+    DefaultInputFile defaultFile = addFile(code, context);
 
     // Set sonarLint runtime
     context.setRuntime(SonarRuntimeImpl.forSonarLint(Version.create(6, 7)));
@@ -80,10 +73,10 @@ public void number_of_visitors_in_sonarLint_context_LTS() throws Exception {
     FileSystem fs = context.fileSystem();
     JavaClasspath javaClasspath = mock(JavaClasspath.class);
     JavaTestClasspath javaTestClasspath = mock(JavaTestClasspath.class);
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, mock(CheckFactory.class), mock(Server.class));
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, mock(CheckFactory.class));
     sonarComponents.setSensorContext(context);
     JavaSquid javaSquid = new JavaSquid(new JavaVersionImpl(), sonarComponents, new Measurer(fs, context, mock(NoSonarFilter.class)), mock(JavaResourceLocator.class), null);
-    javaSquid.scan(Collections.singletonList(file), Collections.emptyList());
+    javaSquid.scan(Collections.singletonList(defaultFile.file()), Collections.emptyList());
 
     // No symbol table : check reference to foo is empty.
     assertThat(context.referencesForSymbolAt(defaultFile.key(), 3, 8)).isNull();
@@ -125,14 +118,7 @@ public void verify_analysis_errors_are_collected_on_semantic_error() throws Exce
 
   private SonarComponents collectAnalysisErrors(String code) throws IOException {
     SensorContextTester context = SensorContextTester.create(temp.getRoot().getAbsoluteFile());
-    File file = temp.newFile().getAbsoluteFile();
-    Files.write(code, file, StandardCharsets.UTF_8);
-    DefaultInputFile defaultFile = new TestInputFileBuilder(temp.getRoot().getAbsolutePath(), file.getName())
-      .setLanguage("java")
-      .initMetadata(new String(java.nio.file.Files.readAllBytes(file.getAbsoluteFile().toPath()), StandardCharsets.UTF_8))
-      .setCharset(StandardCharsets.UTF_8)
-      .build();
-    context.fileSystem().add(defaultFile);
+    DefaultInputFile defaultFile = addFile(code, context);
 
     context.setRuntime(SonarRuntimeImpl.forSonarLint(Version.create(6, 7)));
     // Mock visitor for metrics.
@@ -146,10 +132,61 @@ private SonarComponents collectAnalysisErrors(String code) throws IOException {
     FileSystem fs = context.fileSystem();
     JavaClasspath javaClasspath = mock(JavaClasspath.class);
     JavaTestClasspath javaTestClasspath = mock(JavaTestClasspath.class);
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, mock(CheckFactory.class), server);
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, mock(CheckFactory.class));
     sonarComponents.setSensorContext(context);
     JavaSquid javaSquid = new JavaSquid(new JavaVersionImpl(), sonarComponents, new Measurer(fs, context, mock(NoSonarFilter.class)), mock(JavaResourceLocator.class), null);
-    javaSquid.scan(Collections.singletonList(file), Collections.emptyList());
+    javaSquid.scan(Collections.singletonList(defaultFile.file()), Collections.emptyList());
     return sonarComponents;
   }
+
+  @Test
+  public void parsing_errors_should_be_reported_to_sonarlint() throws Exception {
+    SensorContextTester context = setupAnalysisError("class A {");
+
+    assertThat(context.allAnalysisErrors()).hasSize(1);
+    assertThat(context.allAnalysisErrors().iterator().next().message()).startsWith("Parse error at line 1 column 10");
+  }
+
+  @Test
+  public void semantic_errors_should_be_reported_to_sonarlint() throws Exception {
+    SensorContextTester context = setupAnalysisError("class A {} class A {}");
+
+    assertThat(context.allAnalysisErrors()).hasSize(1);
+    assertThat(context.allAnalysisErrors().iterator().next().message()).isEqualTo("Registering class 2 times : A");
+  }
+
+  private SensorContextTester setupAnalysisError(String code) throws IOException {
+    SensorContextTester context = SensorContextTester.create(temp.getRoot().getAbsoluteFile());
+
+    DefaultInputFile inputFile = addFile(code, context);
+
+    // Set sonarLint runtime
+    context.setRuntime(SonarRuntimeImpl.forSonarLint(Version.create(6, 7)));
+
+    // Mock visitor for metrics.
+    FileLinesContext fileLinesContext = mock(FileLinesContext.class);
+    FileLinesContextFactory fileLinesContextFactory = mock(FileLinesContextFactory.class);
+    when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext);
+
+    FileSystem fs = context.fileSystem();
+    JavaClasspath javaClasspath = mock(JavaClasspath.class);
+    JavaTestClasspath javaTestClasspath = mock(JavaTestClasspath.class);
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, mock(CheckFactory.class));
+    sonarComponents.setSensorContext(context);
+    JavaSquid javaSquid = new JavaSquid(new JavaVersionImpl(), sonarComponents, new Measurer(fs, context, mock(NoSonarFilter.class)), mock(JavaResourceLocator.class), null);
+    javaSquid.scan(Collections.singletonList(inputFile.file()), Collections.emptyList());
+    return context;
+  }
+
+  private DefaultInputFile addFile(String code, SensorContextTester context) throws IOException {
+    File file = temp.newFile().getAbsoluteFile();
+    Files.write(code, file, StandardCharsets.UTF_8);
+    DefaultInputFile defaultFile = new TestInputFileBuilder(temp.getRoot().getAbsolutePath(), file.getName())
+      .setLanguage("java")
+      .initMetadata(new String(java.nio.file.Files.readAllBytes(file.getAbsoluteFile().toPath()), StandardCharsets.UTF_8))
+      .setCharset(StandardCharsets.UTF_8)
+      .build();
+    context.fileSystem().add(defaultFile);
+    return defaultFile;
+  }
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/MeasurerTest.java b/java-frontend/src/test/java/org/sonar/java/MeasurerTest.java
index 74e07a7561..398b320666 100755
--- a/java-frontend/src/test/java/org/sonar/java/MeasurerTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/MeasurerTest.java
@@ -33,7 +33,7 @@
 import org.sonar.api.issue.NoSonarFilter;
 import org.sonar.api.utils.PathUtils;
 import org.sonar.java.model.JavaVersionImpl;
-import org.sonar.squidbridge.api.CodeVisitor;
+import org.sonar.plugins.java.api.JavaCheck;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -112,7 +112,7 @@ private void checkMetric(String filename, String metric, @Nullable Number expect
     inputFile.setModuleBaseDir(fs.baseDirPath());
     fs.add(inputFile.build());
     Measurer measurer = new Measurer(fs, context, mock(NoSonarFilter.class));
-    JavaSquid squid = new JavaSquid(new JavaVersionImpl(), null, measurer, null, null, new CodeVisitor[0]);
+    JavaSquid squid = new JavaSquid(new JavaVersionImpl(), null, measurer, null, null, new JavaCheck[0]);
     squid.scan(Lists.newArrayList(new File(baseDir, filename)), Collections.emptyList());
     assertThat(context.measures("projectKey:" + relativePath)).hasSize(numberOfMetrics);
     Measure<Serializable> measure = context.measure("projectKey:" + relativePath, metric);
diff --git a/java-frontend/src/test/java/org/sonar/java/SonarComponentsTest.java b/java-frontend/src/test/java/org/sonar/java/SonarComponentsTest.java
index c135267418..7ce02f92b3 100755
--- a/java-frontend/src/test/java/org/sonar/java/SonarComponentsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/SonarComponentsTest.java
@@ -23,13 +23,16 @@
 import com.google.common.collect.Lists;
 import com.google.gson.Gson;
 import com.google.gson.reflect.TypeToken;
+import com.sonar.plugins.security.api.JavaRules;
 import com.sonar.sslr.api.RecognitionException;
 import com.sonar.sslr.impl.LexerException;
 import java.io.File;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.NoSuchFileException;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 import org.junit.Before;
 import org.junit.Test;
@@ -41,24 +44,24 @@
 import org.sonar.api.batch.fs.internal.DefaultFileSystem;
 import org.sonar.api.batch.fs.internal.DefaultInputFile;
 import org.sonar.api.batch.fs.internal.TestInputFileBuilder;
+import org.sonar.api.batch.rule.ActiveRules;
 import org.sonar.api.batch.rule.CheckFactory;
 import org.sonar.api.batch.rule.Checks;
+import org.sonar.api.batch.rule.internal.ActiveRulesBuilder;
 import org.sonar.api.batch.sensor.SensorContext;
 import org.sonar.api.batch.sensor.highlighting.NewHighlighting;
 import org.sonar.api.batch.sensor.internal.SensorContextTester;
+import org.sonar.api.batch.sensor.measure.Measure;
 import org.sonar.api.batch.sensor.symbol.NewSymbolTable;
 import org.sonar.api.internal.SonarRuntimeImpl;
 import org.sonar.api.issue.Issuable;
 import org.sonar.api.issue.Issue;
 import org.sonar.api.measures.FileLinesContext;
 import org.sonar.api.measures.FileLinesContextFactory;
-import org.sonar.api.platform.Server;
 import org.sonar.api.rule.RuleKey;
 import org.sonar.api.utils.Version;
 import org.sonar.plugins.java.api.CheckRegistrar;
 import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.squidbridge.api.AnalysisException;
-import org.sonar.squidbridge.api.CodeVisitor;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
@@ -92,9 +95,6 @@
   @Mock
   private SensorContext context;
 
-  @Mock
-  private Server server;
-
   @Before
   public void setUp() {
     // configure mocks that need verification
@@ -122,10 +122,10 @@ public void test_sonar_components() {
     FileLinesContext fileLinesContext = mock(FileLinesContext.class);
     when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext);
 
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, null, javaTestClasspath, checkFactory, server);
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, null, javaTestClasspath, checkFactory);
     sonarComponents.setSensorContext(sensorContextTester);
 
-    CodeVisitor[] visitors = sonarComponents.checkClasses();
+    JavaCheck[] visitors = sonarComponents.checkClasses();
     assertThat(visitors).hasSize(0);
     Collection<JavaCheck> testChecks = sonarComponents.testCheckClasses();
     assertThat(testChecks).hasSize(0);
@@ -143,7 +143,7 @@ public void test_sonar_components() {
     JavaClasspath javaClasspath = mock(JavaClasspath.class);
     List<File> list = mock(List.class);
     when(javaClasspath.getElements()).thenReturn(list);
-    sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory, server);
+    sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory);
     assertThat(sonarComponents.getJavaClasspath()).isEqualTo(list);
   }
 
@@ -153,12 +153,12 @@ public void creation_of_custom_checks() {
     CheckRegistrar expectedRegistrar = getRegistrar(expectedCheck);
 
     when(this.checks.all()).thenReturn(Lists.newArrayList(expectedCheck)).thenReturn(new ArrayList<>());
-    SonarComponents sonarComponents = new SonarComponents(this.fileLinesContextFactory, null, null, null, this.checkFactory, server, new CheckRegistrar[] {
+    SonarComponents sonarComponents = new SonarComponents(this.fileLinesContextFactory, null, null, null, this.checkFactory, new CheckRegistrar[] {
       expectedRegistrar
     });
     sonarComponents.setSensorContext(context);
 
-    CodeVisitor[] visitors = sonarComponents.checkClasses();
+    JavaCheck[] visitors = sonarComponents.checkClasses();
     assertThat(visitors).hasSize(1);
     assertThat(visitors[0]).isEqualTo(expectedCheck);
     Collection<JavaCheck> testChecks = sonarComponents.testCheckClasses();
@@ -173,12 +173,12 @@ public void creation_of_custom_test_checks() {
     CheckRegistrar expectedRegistrar = getRegistrar(expectedCheck);
 
     when(checks.all()).thenReturn(new ArrayList<>()).thenReturn(Lists.newArrayList(expectedCheck));
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, null, null, null, checkFactory, server, new CheckRegistrar[] {
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, null, null, null, checkFactory, new CheckRegistrar[] {
       expectedRegistrar
     });
     sonarComponents.setSensorContext(context);
 
-    CodeVisitor[] visitors = sonarComponents.checkClasses();
+    JavaCheck[] visitors = sonarComponents.checkClasses();
     assertThat(visitors).hasSize(0);
     Collection<JavaCheck> testChecks = sonarComponents.testCheckClasses();
     assertThat(testChecks).hasSize(1);
@@ -197,12 +197,12 @@ public void creation_of_both_types_test_checks() {
       Lists.<Class<? extends JavaCheck>>newArrayList(CustomTestCheck.class));
 
     when(this.checks.all()).thenReturn(Lists.newArrayList(expectedCheck)).thenReturn(Lists.newArrayList(expectedTestCheck));
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, null, null, null, checkFactory, server, new CheckRegistrar[] {
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, null, null, null, checkFactory, new CheckRegistrar[] {
       expectedRegistrar
     });
     sonarComponents.setSensorContext(context);
 
-    CodeVisitor[] visitors = sonarComponents.checkClasses();
+    JavaCheck[] visitors = sonarComponents.checkClasses();
     assertThat(visitors).hasSize(1);
     assertThat(visitors[0]).isEqualTo(expectedCheck);
     Collection<JavaCheck> testChecks = sonarComponents.testCheckClasses();
@@ -221,7 +221,7 @@ public void no_issue_when_check_not_found() throws Exception {
     Issuable issuable = mock(Issuable.class);
 
     when(this.checks.ruleKey(any(JavaCheck.class))).thenReturn(null);
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, null, null, null, checkFactory, server, new CheckRegistrar[] {
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, null, null, null, checkFactory, new CheckRegistrar[] {
       expectedRegistrar
     });
     sonarComponents.setSensorContext(context);
@@ -239,7 +239,7 @@ public void no_issue_if_file_not_found() throws Exception {
     File file = new File("file.java");
 
     when(this.checks.ruleKey(any(JavaCheck.class))).thenReturn(mock(RuleKey.class));
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fileSystem, null, null, checkFactory, server, new CheckRegistrar[] {
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fileSystem, null, null, checkFactory, new CheckRegistrar[] {
       expectedRegistrar
     });
     sonarComponents.setSensorContext(context);
@@ -266,7 +266,7 @@ public void add_issue_or_parse_error() throws Exception {
 
     when(this.checks.ruleKey(any(JavaCheck.class))).thenReturn(mock(RuleKey.class));
 
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fileSystem, null, null, checkFactory, server, new CheckRegistrar[] {
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fileSystem, null, null, checkFactory, new CheckRegistrar[] {
       expectedRegistrar
     });
     sonarComponents.setSensorContext(context);
@@ -305,7 +305,7 @@ public void fail_on_empty_location() {
 
     SensorContextTester context = SensorContextTester.create(new File(""));
     DefaultFileSystem fileSystem = context.fileSystem();
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fileSystem, null, null, checkFactory, server, new CheckRegistrar[] {expectedRegistrar});
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fileSystem, null, null, checkFactory, new CheckRegistrar[] {expectedRegistrar});
     sonarComponents.setSensorContext(context);
 
     AnalyzerMessage.TextSpan emptyTextSpan = new AnalyzerMessage.TextSpan(3, 10, 3, 10);
@@ -408,8 +408,15 @@ private static CheckRegistrar getRegistrar(final JavaCheck expectedCheck) {
   public void sonarcloud_feedback_metric_should_not_exceed_roughly_200ko() {
     File file = new File("src/test/files/ParseError.java");
     SensorContextTester sensorContext = SensorContextTester.create(file.getParentFile().getAbsoluteFile());
-    when(server.getPublicRootUrl()).thenReturn("https://sonarcloud.io");
-    SonarComponents sonarComponents = new SonarComponents(null, null, null, null, null, server);
+    sensorContext.settings().setProperty(SonarComponents.COLLECT_ANALYSIS_ERRORS_KEY, true);
+    Measure<String> feedback = analysisWithAnError(sensorContext);
+    Collection<AnalysisError> analysisErrorsDeserialized = new Gson().fromJson(feedback.value(), new TypeToken<Collection<AnalysisError>>(){}.getType());
+    assertThat(analysisErrorsDeserialized.size()).isBetween(35, 45);
+    assertThat(analysisErrorsDeserialized.iterator().next().getKind()).isEqualTo(AnalysisError.Kind.PARSE_ERROR);
+  }
+
+  private Measure<String> analysisWithAnError(SensorContextTester sensorContext) {
+    SonarComponents sonarComponents = new SonarComponents(null, null, null, null, null);
     sonarComponents.setSensorContext(sensorContext);
 
     AnalysisError analysisError;
@@ -425,9 +432,46 @@ public void sonarcloud_feedback_metric_should_not_exceed_roughly_200ko() {
 
     sonarComponents.saveAnalysisErrors();
 
-    String feedback = sensorContext.<String>measure("projectKey", "sonarjava_feedback").value();
-    Collection<AnalysisError> analysisErrorsDeserialized = new Gson().fromJson(feedback, new TypeToken<Collection<AnalysisError>>(){}.getType());
-    assertThat(analysisErrorsDeserialized.size()).isBetween(35, 45);
-    assertThat(analysisErrorsDeserialized.iterator().next().getKind()).isEqualTo(AnalysisError.Kind.PARSE_ERROR);
+    return sensorContext.measure("projectKey", "sonarjava_feedback");
+  }
+
+  @Test
+  public void feedback_should_not_be_sent_in_sonarLintContext_or_when_collecting_is_disabled_or_when_no_errors() {
+    File file = new File("src/test/files/ParseError.java");
+    SensorContextTester sensorContext = SensorContextTester.create(file.getParentFile().getAbsoluteFile());
+    Measure<String> feedback = analysisWithAnError(sensorContext);
+    assertThat(feedback).isNull();
+
+    sensorContext = SensorContextTester.create(file.getParentFile().getAbsoluteFile());
+    sensorContext.settings().setProperty(SonarComponents.COLLECT_ANALYSIS_ERRORS_KEY, true);
+    sensorContext.setRuntime(SonarRuntimeImpl.forSonarLint(Version.create(6, 7)));
+    feedback = analysisWithAnError(sensorContext);
+    assertThat(feedback).isNull();
+
+    //analysis with no error
+    sensorContext = SensorContextTester.create(file.getParentFile().getAbsoluteFile());
+    SonarComponents sonarComponents = new SonarComponents(null, null, null, null, null);
+    sonarComponents.setSensorContext(sensorContext);
+    sonarComponents.saveAnalysisErrors();
+    assertThat(sensorContext.measure("projectKey", "sonarjava_feedback")).isNull();
+
+  }
+
+  @Test
+  public void ucfg_activation_should_rely_on_active_rules() {
+    File file = new File("src/test/files/ParseError.java");
+    SensorContextTester sensorContext = SensorContextTester.create(file.getParentFile().getAbsoluteFile());
+    SonarComponents sonarComponents = new SonarComponents(null, null, null, null, null);
+    sonarComponents.setRuleRepositoryKey("squid");
+    sonarComponents.setSensorContext(sensorContext);
+    // no security rules available
+    JavaRules.ruleKeys = new HashSet<>();
+    assertThat(sonarComponents.shouldGenerateUCFG()).isFalse();
+
+    ActiveRules activeRules = new ActiveRulesBuilder().create(RuleKey.of("squid", "S3649")).activate().build();
+    // one security rule available
+    JavaRules.ruleKeys = new HashSet<>(Arrays.asList("S3649"));
+    sensorContext.setActiveRules(activeRules);
+    assertThat(sonarComponents.shouldGenerateUCFG()).isTrue();
   }
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/StrutsTest.java b/java-frontend/src/test/java/org/sonar/java/StrutsTest.java
index d3fb722f50..ff1bb632b8 100755
--- a/java-frontend/src/test/java/org/sonar/java/StrutsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/StrutsTest.java
@@ -19,6 +19,11 @@
  */
 package org.sonar.java;
 
+import java.io.File;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
 import org.apache.commons.io.FileUtils;
 import org.junit.Test;
 import org.sonar.api.batch.fs.InputFile;
@@ -28,14 +33,8 @@
 import org.sonar.api.batch.sensor.measure.Measure;
 import org.sonar.api.issue.NoSonarFilter;
 import org.sonar.java.model.JavaVersionImpl;
+import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.plugins.java.api.JavaResourceLocator;
-import org.sonar.squidbridge.api.CodeVisitor;
-
-import java.io.File;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -56,7 +55,7 @@ private static void initAndScan() {
     }
     Measurer measurer = new Measurer(fs, context, mock(NoSonarFilter.class));
     JavaResourceLocator javaResourceLocator = mock(JavaResourceLocator.class);
-    JavaSquid squid = new JavaSquid(new JavaVersionImpl(), null, measurer, javaResourceLocator, null, new CodeVisitor[0]);
+    JavaSquid squid = new JavaSquid(new JavaVersionImpl(), null, measurer, javaResourceLocator, null, new JavaCheck[0]);
     squid.scan(files, Collections.<File>emptyList());
   }
 
diff --git a/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java b/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
new file mode 100755
index 0000000000..6d2b9da926
--- /dev/null
+++ b/java-frontend/src/test/java/org/sonar/java/UCFGJavaVisitorTest.java
@@ -0,0 +1,365 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+package org.sonar.java;
+
+import java.io.File;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
+import org.sonar.java.ast.parser.JavaParser;
+import org.sonar.java.bytecode.loader.SquidClassLoader;
+import org.sonar.java.resolve.SemanticModel;
+import org.sonar.java.resolve.Symbols;
+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;
+import org.sonar.plugins.java.api.tree.CompilationUnitTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
+import org.sonar.ucfg.BasicBlock;
+import org.sonar.ucfg.Expression;
+import org.sonar.ucfg.Instruction;
+import org.sonar.ucfg.LocationInFile;
+import org.sonar.ucfg.UCFG;
+import org.sonar.ucfg.UCFGBuilder;
+import org.sonar.ucfg.UCFGtoProtobuf;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.sonar.ucfg.UCFGBuilder.call;
+import static org.sonar.ucfg.UCFGBuilder.constant;
+import static org.sonar.ucfg.UCFGBuilder.newBasicBlock;
+
+public class UCFGJavaVisitorTest {
+
+  private static final String FILE_KEY = "someRandomFileKey.java";
+  private static SquidClassLoader squidClassLoader;
+
+  @Rule
+  public final TemporaryFolder tmp = new TemporaryFolder();
+
+  @BeforeClass
+  public static void setUp() {
+    File testJarsDir = new File("target/test-jars/");
+    squidClassLoader = new SquidClassLoader(Arrays.asList(testJarsDir.listFiles()));
+  }
+
+  @Test
+  public void visit_java_file() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").ret(arg, new LocationInFile(FILE_KEY, 1,37,1,48)))
+      .build();
+    assertCodeToUCfg("class A { String method(String arg) {return arg;}}", expectedUCFG);
+  }
+
+  @Test
+  public void assign_to_field() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").ret(arg, new LocationInFile(FILE_KEY, 1,69,1,80)))
+      .build();
+    assertCodeToUCfg("class A { String field; String method(String arg) {this.field = arg; return arg;}}", expectedUCFG);
+  }
+
+  @Test
+  public void void_method_with_flow() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable var0 = UCFGBuilder.variableWithId("%0");
+    Expression.Variable var1 = UCFGBuilder.variableWithId("%1");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)V").addMethodParam(arg)
+      .addStartingBlock(newBasicBlock("1").assignTo(var1, call("java.lang.String#toString()Ljava/lang/String;").withArgs(arg), new LocationInFile(FILE_KEY, 1,72,1,86))
+        .jumpTo(UCFGBuilder.createLabel("0")))
+      .addStartingBlock(newBasicBlock("2").assignTo(var0, call("java.lang.String#toString()Ljava/lang/String;").withArgs(arg), new LocationInFile(FILE_KEY, 1,54,1,68))
+        .jumpTo(UCFGBuilder.createLabel("1")))
+      .addBasicBlock(newBasicBlock("0").ret(constant("implicit return"), new LocationInFile(FILE_KEY, 1,87,1,88)))
+      .build();
+    assertCodeToUCfg("class A { public void method(String arg) { if(cond) { arg.toString(); } arg.toString();}}", expectedUCFG);
+  }
+
+  @Test
+  public void create_assign_call_for_method_invocation() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable var = UCFGBuilder.variableWithId("%0");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/Object;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").assignTo(var, call("java.lang.Object#toString()Ljava/lang/String;"), new LocationInFile(FILE_KEY, 1,44,1,58))
+        .ret(var, new LocationInFile(FILE_KEY, 1,37,1,59)))
+      .build();
+    assertCodeToUCfg("class A { String method(Object arg) {return arg.toString();}}", expectedUCFG);
+  }
+
+  @Test
+  public void filter_invocation_unrelated_to_string() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").ret(arg, new LocationInFile(FILE_KEY, 1,61,1,72)))
+      .build();
+    assertCodeToUCfg("class A { String method(String arg) {Object o; o.hashCode(); return arg;}}", expectedUCFG);
+  }
+
+  @Test
+  public void build_concatenate_elements() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable var = UCFGBuilder.variableWithId("%0");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").assignTo(var, call("__concat").withArgs(constant("Myconst"), arg), new LocationInFile(FILE_KEY, 1,43,1,56))
+        .ret(var,new LocationInFile(FILE_KEY, 1,36,1,57)))
+      .build();
+    assertCodeToUCfg("class A {String method(String arg) {return \"Myconst\"+arg;}}", expectedUCFG);
+
+    expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").assignTo(arg, call("__concat").withArgs(arg, constant("someConst")), new LocationInFile(FILE_KEY, 1,43,1,59))
+        .ret(arg, new LocationInFile(FILE_KEY, 1,36,1,60)))
+      .build();
+    assertCodeToUCfg("class A {String method(String arg) {return arg+=\"someConst\";}}", expectedUCFG);
+  }
+
+  @Test
+  public void build_parameter_annotations() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable aux0 = UCFGBuilder.variableWithId("%0");
+    Expression.Variable aux1 = UCFGBuilder.variableWithId("%1");
+    Expression.Variable aux2 = UCFGBuilder.variableWithId("%2");
+
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("paramAnnotations")
+        .assignTo(aux0, call("javax.annotation.Nullable").withArgs(arg), new LocationInFile(FILE_KEY, 1, 24, 1, 50))
+        .assignTo(aux1, call("org.springframework.web.bind.annotation.RequestParam").withArgs(arg), new LocationInFile(FILE_KEY, 1, 51, 1, 106))
+        .assignTo(aux2, call("org.springframework.format.annotation.DateTimeFormat").withArgs(arg), new LocationInFile(FILE_KEY, 1, 107, 1, 160))
+        .assignTo(arg, call("__annotation").withArgs(aux0, aux1, aux2), new LocationInFile(FILE_KEY, 1, 168, 1, 171))
+        .jumpTo(UCFGBuilder.createLabel("1")))
+      .addBasicBlock(
+        newBasicBlock("1")
+          .ret(constant("foo"), new LocationInFile(FILE_KEY, 1, 175, 1, 188)))
+      .build();
+    assertCodeToUCfg("class A { String method(@javax.annotation.Nullable @org.springframework.web.bind.annotation.RequestParam() @org.springframework.format.annotation.DateTimeFormat String arg) { return \"foo\";}}", expectedUCFG);
+  }
+
+  @Test
+  public void unknown_method() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/util/Set;)V").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("0")
+        .ret(constant("implicit return"), new LocationInFile(FILE_KEY, 9, 2, 9, 3)))
+      .build();
+
+    String source = "import java.util.Set;\n" +
+      "import java.util.Collection;\n" +
+      "import java.util.stream.Collectors;\n" +
+      "public class A {\n" +
+      "  void method(Set<String> arg) { \n" +
+      "    arg.stream()\n" +
+      "      .flatMap(Collection::stream)\n" +
+      "      .collect(Collectors.toCollection(LinkedHashSet::new)); \n" +
+      "  }\n" +
+      "}";
+
+    // Semantic model creates 2 kinds of "unknown" symbols: "Symbols.unknownSymbol" and "JavaSymbolNotFound"
+    // We need to test first case
+    // To make sure that code contains "Symbols.unknownSymbol" this assertion is there
+    // Note that if Semantic model is improved somehow that "Symbols.unknownSymbol" is not anymore generated in this case
+    // this test might be removed
+    assertUnknownMethodCalled(source);
+    assertCodeToUCfg(source, expectedUCFG);
+  }
+
+  private void assertUnknownMethodCalled(String source) {
+    CompilationUnitTree cut = getCompilationUnitTreeWithSemantics(source);
+    UnknownMethodVisitor unknownMethodVisitor = new UnknownMethodVisitor();
+    unknownMethodVisitor.visitCompilationUnit(cut);
+    assertThat(unknownMethodVisitor.unknownMethodCount).isGreaterThan(0);
+  }
+
+  @Test
+  public void build_two_parameters_annotations() {
+    Expression.Variable arg0 = UCFGBuilder.variableWithId("arg0");
+    Expression.Variable arg1 = UCFGBuilder.variableWithId("arg1");
+    Expression.Variable aux0 = UCFGBuilder.variableWithId("%0");
+    Expression.Variable aux1 = UCFGBuilder.variableWithId("%1");
+
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg0).addMethodParam(arg1)
+      .addBasicBlock(newBasicBlock("paramAnnotations")
+        .assignTo(aux0, call("javax.annotation.Nullable").withArgs(arg0), new LocationInFile(FILE_KEY, 1, 24, 1, 50))
+        .assignTo(arg0, call("__annotation").withArgs(aux0), new LocationInFile(FILE_KEY, 1, 58, 1, 62))
+        .assignTo(aux1, call("javax.annotation.Nullable").withArgs(arg1), new LocationInFile(FILE_KEY, 1, 64, 1, 90))
+        .assignTo(arg1, call("__annotation").withArgs(aux1), new LocationInFile(FILE_KEY, 1, 98, 1, 102))
+        .jumpTo(UCFGBuilder.createLabel("1")))
+      .addBasicBlock(
+        newBasicBlock("1")
+          .ret(constant("foo"), new LocationInFile(FILE_KEY, 1, 106, 1, 119)))
+      .build();
+    assertCodeToUCfg("class A { String method(@javax.annotation.Nullable String arg0, @javax.annotation.Nullable String arg1) { return \"foo\";}}", expectedUCFG);
+  }
+
+  @Test
+  public void ignore_parameter_annotations_for_non_string() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/Integer;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1")
+        .ret(constant("foo"), new LocationInFile(FILE_KEY, 1, 66, 1, 79)))
+      .build();
+    assertCodeToUCfg("class A { String method(@javax.annotation.Nullable Integer arg) { return \"foo\";}}", expectedUCFG);
+  }
+
+  @Test
+  public void build_assignment_for_string() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable arg2 = UCFGBuilder.variableWithId("arg2");
+    Expression.Variable var1 = UCFGBuilder.variableWithId("var1");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1")
+        .assignTo(var1, call("__id").withArgs(arg), new LocationInFile(FILE_KEY, 1,49,1,67))
+        .assignTo(var1, call("__id").withArgs(arg2), new LocationInFile(FILE_KEY, 1,88,1,99))
+        .ret(var1, new LocationInFile(FILE_KEY, 1,114,1,126)))
+      .build();
+    assertCodeToUCfg("class A {String method(String arg, String arg2) {String var1 = arg; int var2; int var3; var1 = arg2; var2 = var3; return var1;}}", expectedUCFG);
+  }
+
+  @Test
+  public void constructor_with_return() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#<init>(Ljava/lang/String;)V").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1")
+        .ret(constant("\"\""), new LocationInFile(FILE_KEY, 3,4,3,11)))
+      .build();
+    assertCodeToUCfg("class A { \n" +
+      "  A(String arg) { \n" +
+      "    return;\n" +
+      "  }\n" +
+      "}", expectedUCFG);
+  }
+
+  @Test
+  public void location_in_source_file_should_be_preserved() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable var = UCFGBuilder.variableWithId("%0");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1")
+        .assignTo(var, call("java.lang.String#toString()Ljava/lang/String;").withArgs(arg), new LocationInFile(FILE_KEY, 2,0,2,14))
+        .ret(arg, new LocationInFile(FILE_KEY, 3, 2, 3, 13)))
+      .build();
+    assertCodeToUCfgAndLocations("class A { String method(String arg) {\narg.toString();\n  return arg;\n}}", expectedUCFG);
+  }
+
+  @Test
+  public void basic_block_location() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)Ljava/lang/String;").addMethodParam(arg)
+      .addBasicBlock(newBasicBlock("1").ret(arg, new LocationInFile(FILE_KEY, 3,5,3,16)))
+      .build();
+    UCFG ucfg = assertCodeToUCfg("class A {\n  String method(String arg) {\n     return arg;\n}}", expectedUCFG);
+    assertThat(ucfg.entryBlocks()).hasSize(1);
+    assertThat(ucfg.entryBlocks().iterator().next().locationInFile()).isEqualTo(new LocationInFile(FILE_KEY, 3, 12, 3, 15));
+  }
+
+  @Test
+  public void string_length_invocation() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable var0 = UCFGBuilder.variableWithId("%0");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/String;)I").addMethodParam(arg)
+      .addStartingBlock(newBasicBlock("1").assignTo(var0, call("java.lang.String#length()I").withArgs(arg), new LocationInFile(FILE_KEY, 1,41,1,53))
+        .ret(constant("\"\""), new LocationInFile(FILE_KEY, 1,34,1,54)))
+      .build();
+    assertCodeToUCfg("class A { int method(String arg) {return arg.length();}}", expectedUCFG);
+  }
+
+  @Test
+  public void static_method_call_without_object() {
+    Expression.Variable arg = UCFGBuilder.variableWithId("arg");
+    Expression.Variable var0 = UCFGBuilder.variableWithId("%0");
+    UCFG expectedUCFG = UCFGBuilder.createUCFGForMethod("A#method(Ljava/lang/Integer;)I").addMethodParam(arg)
+      .addStartingBlock(
+        newBasicBlock("1")
+          .assignTo(var0, call("java.lang.String#valueOf(Ljava/lang/Object;)Ljava/lang/String;").withArgs(arg),
+            new LocationInFile(FILE_KEY, 4,11,4,23))
+        .ret(constant("\"\""), new LocationInFile(FILE_KEY, 4,4,4,24)))
+      .build();
+    assertCodeToUCfg("import static java.lang.String.valueOf; \n" +
+      "class A { \n" +
+      "  int method(Integer arg) {\n" +
+      "    return valueOf(arg);\n" +
+      "  }\n" +
+      "}", expectedUCFG);
+  }
+
+  private void assertCodeToUCfgAndLocations(String source, UCFG expectedUCFG) {
+    assertCodeToUCfg(source, expectedUCFG, true);
+  }
+
+  private UCFG assertCodeToUCfg(String source, UCFG expectedUCFG) {
+    return assertCodeToUCfg(source, expectedUCFG, false);
+  }
+
+  private UCFG assertCodeToUCfg(String source, UCFG expectedUCFG, boolean testLocations) {
+    CompilationUnitTree cut = getCompilationUnitTreeWithSemantics(source);
+    UCFGJavaVisitor UCFGJavaVisitor = new UCFGJavaVisitor(tmp.getRoot());
+    UCFGJavaVisitor.fileKey = FILE_KEY;
+    UCFGJavaVisitor.visitCompilationUnit(cut);
+
+    UCFG actualUCFG = null;
+    try {
+      File java_ucfg_dir = new File(new File(tmp.getRoot(), "ucfg"), "java");
+      File ucfg = new File(java_ucfg_dir, "ucfg_0.proto");
+      actualUCFG = UCFGtoProtobuf.fromProtobufFile(ucfg);
+    } catch (IOException e) {
+      e.printStackTrace();
+    }
+    assertThat(actualUCFG.methodId()).isEqualTo(expectedUCFG.methodId());
+    assertThat(actualUCFG.basicBlocks()).isEqualTo(expectedUCFG.basicBlocks());
+    assertThat(actualUCFG.basicBlocks().values().stream().flatMap(b->b.calls().stream()))
+      .containsExactlyElementsOf(expectedUCFG.basicBlocks().values().stream().flatMap(b->b.calls().stream()).collect(Collectors.toList()));
+    assertThat(actualUCFG.basicBlocks().values().stream().map(BasicBlock::terminator))
+      .containsExactlyElementsOf(expectedUCFG.basicBlocks().values().stream().map(BasicBlock::terminator).collect(Collectors.toList()));
+    assertThat(actualUCFG.entryBlocks()).isEqualTo(expectedUCFG.entryBlocks());
+    assertThat(toLocationStream(actualUCFG).noneMatch(l->l == UCFGBuilder.LOC)).isTrue();
+    if(testLocations) {
+      Stream<LocationInFile> locStream = toLocationStream(actualUCFG);
+      assertThat(locStream).containsExactlyElementsOf(toLocationStream(expectedUCFG).collect(Collectors.toList()));
+    }
+    return actualUCFG;
+  }
+
+  private CompilationUnitTree getCompilationUnitTreeWithSemantics(String source) {
+    CompilationUnitTree cut = (CompilationUnitTree) JavaParser.createParser().parse(source);
+    SemanticModel.createFor(cut, squidClassLoader);
+    return cut;
+  }
+
+  private Stream<LocationInFile> toLocationStream(UCFG UCFG) {
+    return UCFG.basicBlocks().values().stream().flatMap(b -> Stream.concat(b.calls().stream().map(Instruction::location), Stream.of(b.terminator().location())));
+  }
+
+  private static class UnknownMethodVisitor extends BaseTreeVisitor {
+
+    int unknownMethodCount = 0;
+
+    @Override
+    public void visitMethodInvocation(MethodInvocationTree tree) {
+      if (tree.symbol().equals(Symbols.unknownSymbol)) {
+        unknownMethodCount++;
+      }
+      super.visitMethodInvocation(tree);
+    }
+  }
+}
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/JavaAstScannerTest.java b/java-frontend/src/test/java/org/sonar/java/ast/JavaAstScannerTest.java
index 0701508441..fa25680573 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/JavaAstScannerTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/JavaAstScannerTest.java
@@ -46,6 +46,8 @@
 import org.sonar.api.utils.log.LogTester;
 import org.sonar.api.utils.log.LoggerLevel;
 import org.sonar.java.AnalysisError;
+import org.sonar.java.AnalysisException;
+import org.sonar.java.ExceptionHandler;
 import org.sonar.java.Measurer;
 import org.sonar.java.SonarComponents;
 import org.sonar.java.ast.parser.JavaNodeBuilder;
@@ -62,8 +64,6 @@
 import org.sonar.plugins.java.api.tree.SyntaxToken;
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.TreeVisitor;
-import org.sonar.squidbridge.AstScannerExceptionHandler;
-import org.sonar.squidbridge.api.AnalysisException;
 import org.sonar.sslr.grammar.GrammarRuleKey;
 import org.sonar.sslr.grammar.LexerlessGrammarBuilder;
 
@@ -285,7 +285,7 @@ public void describeTo(Description description) {
 
   }
 
-  private static class FakeAuditListener implements JavaFileScanner, AstScannerExceptionHandler {
+  private static class FakeAuditListener implements JavaFileScanner, ExceptionHandler {
 
     @Override
     public void processRecognitionException(RecognitionException e) {
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/ForStatementTest.java b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/ForStatementTest.java
index a966fe82bf..d345426e4c 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/ForStatementTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/ForStatementTest.java
@@ -30,10 +30,12 @@
   public void realLife() {
     assertThat(JavaLexer.FOR_STATEMENT)
       .matches("for (int i = 0; i < 10; i++) {}")
+      .matches("for (var i = 0; i < 10; i++) {}")
       .matches("for (; i < 10; i++) {}")
       .matches("for (;; i++) {}")
       .matches("for (;;) {}")
-      .matches("for (File file : files) {}");
+      .matches("for (File file : files) {}")
+      .matches("for (var file : files) {}");
   }
 
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/LocalVariableDeclarationStatementTest.java b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/LocalVariableDeclarationStatementTest.java
index c39a14f4cd..db19fa1566 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/LocalVariableDeclarationStatementTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/LocalVariableDeclarationStatementTest.java
@@ -34,7 +34,8 @@ public void ok() {
     assertThat(b, JavaLexer.LOCAL_VARIABLE_DECLARATION_STATEMENT)
       .matches("final int a ;")
       .matches("@Foo List<Integer> a, b ;")
-      .matches("int a;");
+      .matches("int a;")
+      .matches("var a;");
   }
 
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/TryStatementTest.java b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/TryStatementTest.java
index d51c35353e..9deb5576fe 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/TryStatementTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/statements/TryStatementTest.java
@@ -52,13 +52,18 @@ public void realLife() {
   }
 
   @Test
-  public void java9() {
+  public void java9_resources_without_initializer() {
     assertThat(JavaLexer.STATEMENT)
       .matches("try (resource) {}")
       .matches("try (new A().field) {}")
       .matches("try (super.resource;) {}")
       .matches("try (super.resource; Resource resource = new Resource()) {}")
-      .matches("try (super.resource; Resource resource = new Resource();) {}")
-    ;
+      .matches("try (super.resource; Resource resource = new Resource();) {}");
+  }
+
+  @Test
+  public void java10_resources_declared_with_var() {
+    assertThat(JavaLexer.STATEMENT)
+      .matches("try (var resource = new Resource()) {}");
   }
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/types/TypeTest.java b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/types/TypeTest.java
index 93e2efa5fd..91cb72548a 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/types/TypeTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/parser/grammar/types/TypeTest.java
@@ -30,6 +30,7 @@
   public void ok() {
     assertThat(JavaLexer.TYPE)
       .matches("int")
+      .matches("var")
       .matches("classType")
       .matches("int []")
       .matches("classType []")
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/visitors/SonarSymbolTableVisitorTest.java b/java-frontend/src/test/java/org/sonar/java/ast/visitors/SonarSymbolTableVisitorTest.java
index d6a24b0961..409c5e7bb2 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/visitors/SonarSymbolTableVisitorTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/visitors/SonarSymbolTableVisitorTest.java
@@ -22,6 +22,11 @@
 import com.google.common.base.Joiner;
 import com.google.common.collect.ImmutableList;
 import com.google.common.io.Files;
+import java.io.File;
+import java.nio.charset.StandardCharsets;
+import java.util.Collection;
+import java.util.List;
+import java.util.stream.Collectors;
 import org.junit.Before;
 import org.junit.Rule;
 import org.junit.Test;
@@ -34,19 +39,12 @@
 import org.sonar.api.batch.rule.CheckFactory;
 import org.sonar.api.batch.sensor.internal.SensorContextTester;
 import org.sonar.api.measures.FileLinesContextFactory;
-import org.sonar.api.platform.Server;
 import org.sonar.java.JavaClasspath;
 import org.sonar.java.JavaTestClasspath;
 import org.sonar.java.SonarComponents;
 import org.sonar.java.ast.JavaAstScanner;
 import org.sonar.java.model.VisitorsBridge;
 
-import java.io.File;
-import java.nio.charset.StandardCharsets;
-import java.util.Collection;
-import java.util.List;
-import java.util.stream.Collectors;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 
@@ -61,11 +59,11 @@
   private SonarComponents sonarComponents;
 
   @Before
-  public void setUp() throws Exception {
+  public void setUp() {
     context = SensorContextTester.create(temp.getRoot());
     fs = context.fileSystem();
     sonarComponents = new SonarComponents(mock(FileLinesContextFactory.class), fs,
-      mock(JavaClasspath.class), mock(JavaTestClasspath.class), mock(CheckFactory.class), mock(Server.class));
+      mock(JavaClasspath.class), mock(JavaTestClasspath.class), mock(CheckFactory.class));
     sonarComponents.setSensorContext(context);
   }
 
diff --git a/java-frontend/src/test/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitorTest.java b/java-frontend/src/test/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitorTest.java
index 17bad85a20..a5152b74a2 100755
--- a/java-frontend/src/test/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitorTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/ast/visitors/SyntaxHighlighterVisitorTest.java
@@ -37,13 +37,12 @@
 import org.sonar.api.batch.sensor.highlighting.TypeOfText;
 import org.sonar.api.batch.sensor.internal.SensorContextTester;
 import org.sonar.api.measures.FileLinesContextFactory;
-import org.sonar.api.platform.Server;
 import org.sonar.java.JavaClasspath;
 import org.sonar.java.JavaSquid;
 import org.sonar.java.JavaTestClasspath;
 import org.sonar.java.SonarComponents;
 import org.sonar.java.model.JavaVersionImpl;
-import org.sonar.squidbridge.api.CodeVisitor;
+import org.sonar.plugins.java.api.JavaCheck;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
@@ -70,7 +69,7 @@ public void setUp() throws Exception {
     context = SensorContextTester.create(temp.getRoot());
     fs = context.fileSystem();
     sonarComponents = new SonarComponents(mock(FileLinesContextFactory.class), fs,
-      mock(JavaClasspath.class), mock(JavaTestClasspath.class), mock(CheckFactory.class), mock(Server.class));
+      mock(JavaClasspath.class), mock(JavaTestClasspath.class), mock(CheckFactory.class));
     sonarComponents.setSensorContext(context);
     syntaxHighlighterVisitor = new SyntaxHighlighterVisitor(sonarComponents);
   }
@@ -184,8 +183,24 @@ public void test_restricted_keywords_outside_module() throws Exception {
     assertThatHasNotBeenHighlighted(componentKey, 20, 17, 20, 25); // provides
   }
 
+  @Test
+  public void test_java10_var() throws Exception {
+    this.eol = "\n";
+    File file = generateTestFile("src/test/files/highlighter/Java10Var.java");
+    scan(file);
+
+    String componentKey = ":" + file.getName();
+    assertThatHasBeenHighlighted(componentKey, 10, 5, 10, 8, TypeOfText.KEYWORD); // var a = ...
+    assertThatHasBeenHighlighted(componentKey, 12, 5, 12, 8, TypeOfText.KEYWORD); // var list = ...
+    assertThatHasBeenHighlighted(componentKey, 17, 10, 17, 13, TypeOfText.KEYWORD); // for (var counter = ...
+    assertThatHasBeenHighlighted(componentKey, 21, 10, 21, 13, TypeOfText.KEYWORD); // for (var value : ...
+    assertThatHasBeenHighlighted(componentKey, 27, 10, 27, 13, TypeOfText.KEYWORD); // try (var reader = ...
+    assertThatHasBeenHighlighted(componentKey, 32, 5, 32, 8, TypeOfText.KEYWORD); // var myA = new A() { ...
+    assertThatHasNotBeenHighlighted(componentKey, 51, 12, 51, 15); // Object var;
+  }
+
   private void scan(File file) {
-    JavaSquid squid = new JavaSquid(new JavaVersionImpl(), null, null, null, null, new CodeVisitor[] {syntaxHighlighterVisitor});
+    JavaSquid squid = new JavaSquid(new JavaVersionImpl(), null, null, null, null, new JavaCheck[] {syntaxHighlighterVisitor});
     squid.scan(Lists.newArrayList(file), Collections.<File>emptyList());
   }
 
diff --git a/java-frontend/src/test/java/org/sonar/java/cfg/VariableReadExtractorTest.java b/java-frontend/src/test/java/org/sonar/java/cfg/VariableReadExtractorTest.java
index 4884e3b568..183dccd77b 100755
--- a/java-frontend/src/test/java/org/sonar/java/cfg/VariableReadExtractorTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/cfg/VariableReadExtractorTest.java
@@ -20,6 +20,7 @@
 package org.sonar.java.cfg;
 
 import com.sonar.sslr.api.typed.ActionParser;
+import java.util.Collections;
 import org.junit.Test;
 import org.sonar.java.ast.parser.JavaParser;
 import org.sonar.java.bytecode.loader.SquidClassLoader;
@@ -30,8 +31,6 @@
 import org.sonar.plugins.java.api.tree.StatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.util.Collections;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
 public class VariableReadExtractorTest {
@@ -88,6 +87,16 @@ public void should_not_extract_fields_written() throws Exception {
     assertThat(extractor.usedVariables()).isEmpty();
   }
 
+  @Test
+  public void should_not_extract_variable_declared() throws Exception {
+    MethodTree methodTree = buildMethodTree("void foo(boolean a) { boolean b = a; }");
+    StatementTree statementTree = methodTree.block().body().get(0);
+    VariableReadExtractor extractor = new VariableReadExtractor(methodTree.symbol(), true);
+    statementTree.accept(extractor);
+    // only "a" should be detected
+    assertThat(extractor.usedVariables()).hasSize(1);
+  }
+
   @Test
   public void should_return_symbol_once() {
     MethodTree methodTree = buildMethodTree("void foo(boolean a) { new Object() { void foo() { foo(a); bar(a); } }; }");
diff --git a/java-frontend/src/test/java/org/sonar/java/model/ExpressionUtilsTest.java b/java-frontend/src/test/java/org/sonar/java/model/ExpressionUtilsTest.java
index 1cf2eba605..0546c0ae3e 100755
--- a/java-frontend/src/test/java/org/sonar/java/model/ExpressionUtilsTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/model/ExpressionUtilsTest.java
@@ -19,6 +19,10 @@
  */
 package org.sonar.java.model;
 
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.util.List;
+import java.util.stream.Collectors;
 import org.junit.Test;
 import org.sonar.java.ast.parser.JavaParser;
 import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;
@@ -27,15 +31,11 @@
 import org.sonar.plugins.java.api.tree.CompilationUnitTree;
 import org.sonar.plugins.java.api.tree.ExpressionStatementTree;
 import org.sonar.plugins.java.api.tree.ExpressionTree;
+import org.sonar.plugins.java.api.tree.MethodInvocationTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.ReturnStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
 
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.util.List;
-import java.util.stream.Collectors;
-
 import static java.lang.reflect.Modifier.isFinal;
 import static java.lang.reflect.Modifier.isPrivate;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -83,6 +83,19 @@ public void test_simple_assignments() throws Exception {
     assertThat(ExpressionUtils.isSimpleAssignment(assignments.get(3))).isFalse();
   }
 
+  @Test
+  public void method_name() throws Exception {
+    File file = new File("src/test/files/model/ExpressionUtilsMethodNameTest.java");
+    CompilationUnitTree tree = (CompilationUnitTree) JavaParser.createParser().parse(file);
+    MethodTree methodTree = (MethodTree) ((ClassTree) tree.types().get(0)).members().get(0);
+
+    MethodInvocationTree firstMIT = (MethodInvocationTree) ((ExpressionStatementTree) methodTree.block().body().get(0)).expression();
+    MethodInvocationTree secondMIT = (MethodInvocationTree) ((ExpressionStatementTree) methodTree.block().body().get(1)).expression();
+
+    assertThat(ExpressionUtils.methodName(firstMIT).name()).isEqualTo("foo");
+    assertThat(ExpressionUtils.methodName(secondMIT).name()).isEqualTo("foo");
+  }
+
   @Test
   public void private_constructor() throws Exception {
     assertThat(isFinal(ExpressionUtils.class.getModifiers())).isTrue();
diff --git a/java-frontend/src/test/java/org/sonar/java/model/TestDefaultJavaFileScannerContextWithSensorContextTester.java b/java-frontend/src/test/java/org/sonar/java/model/TestDefaultJavaFileScannerContextWithSensorContextTester.java
index 9c71046e9d..0a16de5e34 100755
--- a/java-frontend/src/test/java/org/sonar/java/model/TestDefaultJavaFileScannerContextWithSensorContextTester.java
+++ b/java-frontend/src/test/java/org/sonar/java/model/TestDefaultJavaFileScannerContextWithSensorContextTester.java
@@ -88,7 +88,7 @@ public void setup() throws IOException {
         .initMetadata(new String(Files.readAllBytes(JAVA_FILE.toPath()), StandardCharsets.UTF_8))
         .build()
     );
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, sensorContext.fileSystem(), javaClasspath, javaTestClasspath, checkFactory, server);
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, sensorContext.fileSystem(), javaClasspath, javaTestClasspath, checkFactory);
     sonarComponents.setSensorContext(sensorContext);
 
     // spy getRuleKey call, to avoid mocking CheckFactory and Checks
diff --git a/java-frontend/src/test/java/org/sonar/java/model/VisitorsBridgeTest.java b/java-frontend/src/test/java/org/sonar/java/model/VisitorsBridgeTest.java
index 5025a9cdec..969018f40a 100755
--- a/java-frontend/src/test/java/org/sonar/java/model/VisitorsBridgeTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/model/VisitorsBridgeTest.java
@@ -127,7 +127,7 @@ public void rethrow_exception_when_hidden_property_set_to_true() {
     JavaFileScanner visitor = c -> {throw npe;};
     File currentFile = new File("");
     SensorContextTester sensorContextTester = SensorContextTester.create(currentFile);
-    SonarComponents sonarComponents = new SonarComponents(null, null, null, null, null, null, null);
+    SonarComponents sonarComponents = new SonarComponents(null, null, null, null, null, null);
     sonarComponents.setSensorContext(sensorContextTester);
     VisitorsBridge visitorsBridge = new VisitorsBridge(Collections.singleton(visitor), new ArrayList<>(), sonarComponents);
     visitorsBridge.setCurrentFile(currentFile);
@@ -139,7 +139,7 @@ public void rethrow_exception_when_hidden_property_set_to_true() {
       Fail.fail("Exception should be swallowed when property is not set");
     }
 
-    sensorContextTester.settings().appendProperty("sonar.java.failOnException", "true");
+    sensorContextTester.settings().appendProperty(SonarComponents.FAIL_ON_EXCEPTION_KEY, "true");
     try {
       visitorsBridge.visitFile(null);
       Fail.fail("scanning of file should have raise an exception");
diff --git a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
index 569ef863fd..56943d84d3 100755
--- a/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/resolve/SymbolTableTest.java
@@ -20,6 +20,12 @@
 package org.sonar.java.resolve;
 
 import com.google.common.collect.Iterables;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
 import org.assertj.core.api.SoftAssertions;
 import org.junit.Rule;
 import org.junit.Test;
@@ -42,13 +48,6 @@
 import org.sonar.plugins.java.api.tree.Tree;
 import org.sonar.plugins.java.api.tree.VariableTree;
 
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.Collectors;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
 
@@ -510,6 +509,8 @@ public void Enum() {
     assertThat(valuesMethod.declaration).isNull();
     assertThat(valuesMethod.isStatic()).isTrue();
     assertThat(valuesMethod.parameterTypes()).isEmpty();
+    assertThat(valuesMethod.getParameters()).isNotNull();
+    assertThat(valuesMethod.getParameters().scopeSymbols()).isEmpty();
     assertThat(((MethodJavaType) valuesMethod.type).resultType).isInstanceOf(ArrayJavaType.class);
     assertThat(((ArrayJavaType) (((MethodJavaType) valuesMethod.type).resultType)).elementType).isSameAs(enumSymbol.type);
     assertThat(result.reference(9, 19)).isSameAs(valuesMethod);
@@ -520,6 +521,8 @@ public void Enum() {
     assertThat(valueOfMethod.isStatic()).isTrue();
     assertThat(valueOfMethod.parameterTypes()).hasSize(1);
     assertThat(valueOfMethod.parameterTypes().get(0).is("java.lang.String")).isTrue();
+    assertThat(valueOfMethod.getParameters()).isNotNull();
+    assertThat(valueOfMethod.getParameters().scopeSymbols()).hasSize(1);
     assertThat(((MethodJavaType) valueOfMethod.type).resultType).isSameAs(enumSymbol.type);
     assertThat(result.reference(10, 20)).isSameAs(valueOfMethod);
     assertThat(result.reference(10, 5)).isSameAs(result.symbol("useValueOf", 14));
@@ -633,7 +636,8 @@ public void ConstructorDeclaration() {
     assertThat(defaultConstructor.owner).isSameAs(result.symbol("ParameterType"));
     defaultConstructor = result.reference(28, 7);
     assertThat(defaultConstructor.isAbstract()).isFalse();
-
+    assertThat(((JavaSymbol.MethodJavaSymbol) defaultConstructor).getParameters()).isNotNull();
+    assertThat(((JavaSymbol.MethodJavaSymbol) defaultConstructor).getParameters().scopeSymbols()).isEmpty();
   }
 
   @Test
@@ -1602,4 +1606,17 @@ public void fieldType_in_parameterized_hierarchy() throws Exception {
     softly.assertThat(res.referenceTree(17, 9).symbolType().fullyQualifiedName()).isEqualTo("java.lang.Integer");
     softly.assertAll();
   }
+
+  @Test
+  public void conditional_operator_expression_type() {
+    Result res = Result.createFor("ConditionalOperator");
+    ExpressionTree conditional = ((ReturnStatementTree) ((MethodTree) res.symbol("fun").declaration()).block().body().get(0)).expression();
+    Type conditionalExpressionType = conditional.symbolType();
+    assertThat(conditionalExpressionType.is("App$Foo")).isTrue();
+    assertThat(((JavaType) conditionalExpressionType).isParameterized()).isTrue();
+    List<JavaType> substitutedTypes = ((ParametrizedTypeJavaType) conditionalExpressionType).typeSubstitution.substitutedTypes();
+    assertThat(substitutedTypes).hasSize(1);
+    assertThat(substitutedTypes.get(0).isTagged(JavaType.WILDCARD)).isTrue();
+    assertThat(((WildCardType) substitutedTypes.get(0)).bound.is("java.util.List")).isTrue();
+  }
 }
diff --git a/java-frontend/src/test/java/org/sonar/java/resolve/TypeAndReferenceSolverTest.java b/java-frontend/src/test/java/org/sonar/java/resolve/TypeAndReferenceSolverTest.java
index c31502b370..ef3b7f6ccd 100755
--- a/java-frontend/src/test/java/org/sonar/java/resolve/TypeAndReferenceSolverTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/resolve/TypeAndReferenceSolverTest.java
@@ -21,6 +21,10 @@
 
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.Lists;
+import java.io.File;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
 import org.assertj.core.api.AbstractObjectAssert;
 import org.junit.Before;
 import org.junit.Test;
@@ -38,14 +42,12 @@
 import org.sonar.plugins.java.api.tree.ExpressionTree;
 import org.sonar.plugins.java.api.tree.MethodTree;
 import org.sonar.plugins.java.api.tree.NewClassTree;
+import org.sonar.plugins.java.api.tree.ParameterizedTypeTree;
 import org.sonar.plugins.java.api.tree.ReturnStatementTree;
 import org.sonar.plugins.java.api.tree.Tree;
+import org.sonar.plugins.java.api.tree.TypeTree;
 import org.sonar.plugins.java.api.tree.VariableTree;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
+import org.sonar.plugins.java.api.tree.WildcardTree;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
@@ -556,6 +558,21 @@ public void assignment_expression() {
     assertThat(typeOf("var = 1")).isSameAs(variableSymbol.type);
   }
 
+  @Test
+  public void wildcard_type_tree_have_a_widlcard_type() {
+    CompilationUnitTree cut = treeOf("abstract class A<T> { abstract A<? extends Runnable> foo(); }");
+    TypeTree returnType = ((MethodTree) ((ClassTree) cut.types().get(0)).members().get(0)).returnType();
+    assertThat(returnType.is(Tree.Kind.PARAMETERIZED_TYPE)).isTrue();
+    Tree typeArg = ((ParameterizedTypeTree) returnType).typeArguments().get(0);
+    assertThat(typeArg.is(Tree.Kind.EXTENDS_WILDCARD)).isTrue();
+    JavaType javaType = (JavaType) ((WildcardTree) typeArg).symbolType();
+    assertThat(javaType).isInstanceOf(WildCardType.class);
+    WildCardType wildCardType = (WildCardType) javaType;
+    assertThat(wildCardType.isSubtypeOf("java.lang.Runnable")).isTrue();
+    assertThat(wildCardType.bound.is("java.lang.Runnable")).isTrue();
+    assertThat(wildCardType.boundType).isEqualTo(WildCardType.BoundType.EXTENDS);
+  }
+
   @Test
   public void parametrized_method_return_type_is_array() {
     Type arrayType = returnTypeOf("<T> T[] foo(T t) { return null; }", "this.<String>foo(\"hello\");");
diff --git a/java-frontend/src/test/java/org/sonar/java/se/ExplodedGraphWalkerTest.java b/java-frontend/src/test/java/org/sonar/java/se/ExplodedGraphWalkerTest.java
index f87c58c0e1..8f40501850 100755
--- a/java-frontend/src/test/java/org/sonar/java/se/ExplodedGraphWalkerTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/se/ExplodedGraphWalkerTest.java
@@ -43,6 +43,7 @@
 import org.sonar.java.se.checks.NonNullSetToNullCheck;
 import org.sonar.java.se.checks.NullDereferenceCheck;
 import org.sonar.java.se.checks.OptionalGetBeforeIsPresentCheck;
+import org.sonar.java.se.checks.ParameterNullnessCheck;
 import org.sonar.java.se.checks.RedundantAssignmentsCheck;
 import org.sonar.java.se.checks.SECheck;
 import org.sonar.java.se.checks.StreamNotConsumedCheck;
@@ -455,7 +456,8 @@ public void eg_walker_factory_default_checks() throws IOException {
       InvariantReturnCheck.class,
       StreamNotConsumedCheck.class,
       MapComputeIfAbsentOrPresentCheck.class,
-      DebugMethodYieldsCheck.class
+      DebugMethodYieldsCheck.class,
+      ParameterNullnessCheck.class
       )
       .map(Class::getSimpleName)
       .collect(Collectors.toList());
diff --git a/java-frontend/src/test/java/org/sonar/java/se/checks/ParameterNullnessCheckTest.java b/java-frontend/src/test/java/org/sonar/java/se/checks/ParameterNullnessCheckTest.java
new file mode 100755
index 0000000000..ab51f2686f
--- /dev/null
+++ b/java-frontend/src/test/java/org/sonar/java/se/checks/ParameterNullnessCheckTest.java
@@ -0,0 +1,32 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.java.se.checks;
+
+import org.junit.Test;
+import org.sonar.java.se.JavaCheckVerifier;
+
+public class ParameterNullnessCheckTest {
+
+  @Test
+  public void test() {
+    JavaCheckVerifier.verify("src/test/files/se/ParameterNullnessCheck.java", new ParameterNullnessCheck());
+  }
+
+}
diff --git a/java-frontend/src/test/java/org/sonar/java/se/checks/UnclosedResourcesCheckTest.java b/java-frontend/src/test/java/org/sonar/java/se/checks/UnclosedResourcesCheckTest.java
index 83b04d451e..f8f46bbea2 100755
--- a/java-frontend/src/test/java/org/sonar/java/se/checks/UnclosedResourcesCheckTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/se/checks/UnclosedResourcesCheckTest.java
@@ -34,7 +34,7 @@ public void test() {
   @Test
   public void test_supertype_resolution() {
     String file = "src/test/java/org/sonar/java/resolve/targets/TestSupertypeResolution.java";
-    JavaCheckVerifier.verify(file, new UnclosedResourcesCheck());
+    JavaCheckVerifier.verifyNoIssue(file, new UnclosedResourcesCheck());
   }
 
   @Test
diff --git a/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYieldTest.java b/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYieldTest.java
index 0945e0a81d..54dd397f79 100755
--- a/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYieldTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalCheckBasedYieldTest.java
@@ -143,7 +143,7 @@ public void exceptionType_cannot_be_changed() {
     }.getClass();
     String exceptionType = "someException";
     ExceptionalCheckBasedYield yield = new ExceptionalCheckBasedYield(SV_CAUSING_EXCEPTION, exceptionType, seCheckClass, null, mockMethodBehavior());
-    yield.setExceptionType("anotherException");
+    yield.setExceptionTypeName("anotherException");
   }
 
   @Test
@@ -174,7 +174,7 @@ public void test_equals() {
 
     // same exception, but simple exceptional yield
     otherYield = new ExceptionalYield(null, mb);
-    otherYield.setExceptionType(mockedExceptionType1);
+    otherYield.setExceptionTypeName(mockedExceptionType1);
     assertThat(yield).isNotEqualTo(otherYield);
 
     // same exception, different SV
diff --git a/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalYieldTest.java b/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalYieldTest.java
index ce4ad5bc46..dd0bbe7f80 100755
--- a/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalYieldTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/se/xproc/ExceptionalYieldTest.java
@@ -29,7 +29,6 @@
 import org.sonar.java.bytecode.loader.SquidClassLoader;
 import org.sonar.java.resolve.SemanticModel;
 import org.sonar.java.se.Pair;
-import org.sonar.java.se.SETestUtils;
 import org.sonar.java.se.SymbolicExecutionVisitor;
 import org.sonar.java.se.constraint.BooleanConstraint;
 import org.sonar.java.se.constraint.ObjectConstraint;
@@ -54,10 +53,10 @@ public void test_equals() {
     assertThat(yield).isEqualTo(yield);
     assertThat(yield).isEqualTo(otherYield);
 
-    otherYield.setExceptionType("java.lang.Exception");
+    otherYield.setExceptionTypeName("java.lang.Exception");
     assertThat(yield).isNotEqualTo(otherYield);
 
-    yield.setExceptionType("java.lang.Exception");
+    yield.setExceptionTypeName("java.lang.Exception");
     assertThat(yield).isEqualTo(otherYield);
     SemanticModel semanticModel = SemanticModel.createFor((CompilationUnitTree) JavaParser.createParser().parse("class A{}"), new SquidClassLoader(new ArrayList<>()));
     assertThat(yield.exceptionType(semanticModel)).isEqualTo(otherYield.exceptionType(semanticModel));
@@ -77,7 +76,7 @@ public void test_hashCode() {
     assertThat(methodYield.hashCode()).isEqualTo(other.hashCode());
 
     // different values for different yields
-    other.setExceptionType("java.lang.Exception");
+    other.setExceptionTypeName("java.lang.Exception");
     assertThat(methodYield.hashCode()).isNotEqualTo(other.hashCode());
 
     // happy Path Yield method yield
diff --git a/java-frontend/src/test/java/org/sonar/java/xml/XmlAnalyzerTest.java b/java-frontend/src/test/java/org/sonar/java/xml/XmlAnalyzerTest.java
index 88b8df1330..3981e9ef86 100755
--- a/java-frontend/src/test/java/org/sonar/java/xml/XmlAnalyzerTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/xml/XmlAnalyzerTest.java
@@ -20,6 +20,7 @@
 package org.sonar.java.xml;
 
 import com.google.common.collect.Lists;
+import java.io.File;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
@@ -34,9 +35,6 @@
 import org.sonar.plugins.java.api.JavaCheck;
 import org.sonar.plugins.java.api.JavaFileScanner;
 import org.sonar.plugins.java.api.JavaFileScannerContext;
-import org.sonar.squidbridge.api.CodeVisitor;
-
-import java.io.File;
 
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyString;
@@ -232,9 +230,9 @@ public void should_not_scan_when_no_xml_check_provided() {
     verify(sonarComponents, never()).reportIssue(any(AnalyzerMessage.class));
   }
 
-  private static SonarComponents createSonarComponentsMock(DefaultFileSystem fs, CodeVisitor... codeVisitor) {
+  private static SonarComponents createSonarComponentsMock(DefaultFileSystem fs, JavaCheck... visitors) {
     SonarComponents sonarComponents = mock(SonarComponents.class);
-    when(sonarComponents.checkClasses()).thenReturn(codeVisitor);
+    when(sonarComponents.checkClasses()).thenReturn(visitors);
 
     when(sonarComponents.getFileSystem()).thenReturn(fs);
 
diff --git a/java-frontend/src/test/java/org/sonar/java/xml/XmlCheckContextImplTest.java b/java-frontend/src/test/java/org/sonar/java/xml/XmlCheckContextImplTest.java
index 3e7a4546e1..821bfc90dc 100755
--- a/java-frontend/src/test/java/org/sonar/java/xml/XmlCheckContextImplTest.java
+++ b/java-frontend/src/test/java/org/sonar/java/xml/XmlCheckContextImplTest.java
@@ -22,31 +22,28 @@
 import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import com.google.common.io.Files;
-
+import java.io.File;
+import java.nio.charset.StandardCharsets;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+import java.util.stream.Collectors;
+import javax.xml.parsers.DocumentBuilderFactory;
+import javax.xml.xpath.XPath;
+import javax.xml.xpath.XPathExpression;
+import javax.xml.xpath.XPathExpressionException;
+import javax.xml.xpath.XPathFactory;
 import org.junit.Before;
 import org.junit.Test;
 import org.mockito.Mockito;
 import org.mockito.invocation.InvocationOnMock;
 import org.mockito.stubbing.Answer;
+import org.sonar.java.AnalysisException;
 import org.sonar.java.AnalyzerMessage;
 import org.sonar.java.SonarComponents;
 import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.squidbridge.api.AnalysisException;
 import org.w3c.dom.Document;
 import org.w3c.dom.Node;
 
-import javax.xml.parsers.DocumentBuilderFactory;
-import javax.xml.xpath.XPath;
-import javax.xml.xpath.XPathExpression;
-import javax.xml.xpath.XPathExpressionException;
-import javax.xml.xpath.XPathFactory;
-
-import java.io.File;
-import java.nio.charset.StandardCharsets;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-import java.util.stream.Collectors;
-
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyInt;
diff --git a/java-frontend/src/test/java/org/sonar/plugins/java/api/tree/TreeTest.java b/java-frontend/src/test/java/org/sonar/plugins/java/api/tree/TreeTest.java
index b17b904bc0..ddba9fbdb3 100755
--- a/java-frontend/src/test/java/org/sonar/plugins/java/api/tree/TreeTest.java
+++ b/java-frontend/src/test/java/org/sonar/plugins/java/api/tree/TreeTest.java
@@ -27,7 +27,7 @@
 
   @Test
   public void test() {
-    assertThat(Tree.Kind.values()).hasSize(117);
+    assertThat(Tree.Kind.values()).hasSize(118);
   }
 
 }
diff --git a/java-jacoco-previous/pom.xml b/java-jacoco-previous/pom.xml
index 2a4f8ec52a..53d1930c3b 100755
--- a/java-jacoco-previous/pom.xml
+++ b/java-jacoco-previous/pom.xml
@@ -4,7 +4,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-jacoco-previous</artifactId>
diff --git a/java-jacoco/pom.xml b/java-jacoco/pom.xml
index bd088f2416..1cc3a9eaf2 100755
--- a/java-jacoco/pom.xml
+++ b/java-jacoco/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
   <artifactId>java-jacoco</artifactId>
 
@@ -52,6 +52,14 @@
       <artifactId>java-jacoco-previous</artifactId>
       <version>${project.version}</version>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+    </dependency>
     <!-- Would be provided by environment -->
     <dependency>
       <groupId>org.apache.ant</groupId>
diff --git a/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JaCoCoReportMerger.java b/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JaCoCoReportMerger.java
index f12d703def..61bef2deb9 100755
--- a/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JaCoCoReportMerger.java
+++ b/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JaCoCoReportMerger.java
@@ -19,19 +19,18 @@
  */
 package org.sonar.plugins.jacoco;
 
+import java.io.BufferedOutputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.util.Map;
 import org.apache.commons.lang.BooleanUtils;
 import org.jacoco.core.data.ExecutionDataStore;
 import org.jacoco.core.data.ExecutionDataWriter;
 import org.jacoco.core.data.IExecutionDataVisitor;
 import org.jacoco.core.data.ISessionInfoVisitor;
 import org.jacoco.core.data.SessionInfo;
-import org.sonar.squidbridge.api.AnalysisException;
-
-import java.io.BufferedOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.util.Map;
+import org.sonar.java.AnalysisException;
 
 /**
  * Utility class to merge JaCoCo reports.
diff --git a/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JacocoReportReader.java b/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JacocoReportReader.java
index f5566b428d..152b819fc4 100755
--- a/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JacocoReportReader.java
+++ b/java-jacoco/src/main/java/org/sonar/plugins/jacoco/JacocoReportReader.java
@@ -20,23 +20,25 @@
 package org.sonar.plugins.jacoco;
 
 import com.google.common.base.Preconditions;
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.Collection;
+import javax.annotation.Nullable;
 import org.jacoco.core.analysis.Analyzer;
 import org.jacoco.core.analysis.CoverageBuilder;
+import org.jacoco.core.analysis.IClassCoverage;
 import org.jacoco.core.data.ExecutionDataReader;
 import org.jacoco.core.data.ExecutionDataStore;
 import org.jacoco.core.data.ExecutionDataWriter;
 import org.jacoco.core.data.IExecutionDataVisitor;
 import org.jacoco.core.data.ISessionInfoVisitor;
-import org.sonar.squidbridge.api.AnalysisException;
+import org.sonar.java.AnalysisException;
 
-import javax.annotation.Nullable;
-import java.io.BufferedInputStream;
-import java.io.DataInputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Collection;
+import static org.sonar.plugins.jacoco.JaCoCoExtensions.LOG;
 
 public class JacocoReportReader {
 
@@ -61,7 +63,7 @@ public JacocoReportReader readJacocoReport(IExecutionDataVisitor executionDataVi
       return this;
     }
 
-    JaCoCoExtensions.LOG.info("Analysing {}", jacocoExecutionData);
+    LOG.info("Analysing {}", jacocoExecutionData);
     try (InputStream inputStream = new BufferedInputStream(new FileInputStream(jacocoExecutionData))) {
       if (useCurrentBinaryFormat) {
         ExecutionDataReader reader = new ExecutionDataReader(inputStream);
@@ -91,7 +93,7 @@ private static boolean isCurrentReportFormat(@Nullable File jacocoExecutionData)
       char version = dis.readChar();
       boolean isCurrentFormat = version == ExecutionDataWriter.FORMAT_VERSION;
       if (!isCurrentFormat) {
-        JaCoCoExtensions.LOG.warn("You are not using the latest JaCoCo binary format version, please consider upgrading to latest JaCoCo version.");
+        LOG.warn("You are not using the latest JaCoCo binary format version, please consider upgrading to latest JaCoCo version.");
       }
       return isCurrentFormat;
     } catch (IOException | IllegalStateException e) {
@@ -119,9 +121,21 @@ public CoverageBuilder analyzeFiles(ExecutionDataStore executionDataStore, Colle
         analyzeClassFile(analyzer, classFile);
       }
     }
+    logNoMatchClasses(coverageBuilder.getNoMatchClasses());
     return coverageBuilder;
   }
 
+  private static void logNoMatchClasses(Collection<IClassCoverage> noMatchClasses) {
+    if (noMatchClasses.isEmpty()) {
+      return;
+    }
+    LOG.warn("The following class(es) did not match with execution data:");
+    for (IClassCoverage iClassCoverage : noMatchClasses) {
+      LOG.warn(String.format("> '%s'", iClassCoverage.getName()));
+    }
+    LOG.warn("In order to have accurate coverage measures, the same class files must be used as at runtime for report generation.");
+  }
+
   /**
    * Caller must guarantee that {@code classFile} is actually class file.
    */
@@ -130,7 +144,7 @@ private static void analyzeClassFile(org.jacoco.previous.core.analysis.Analyzer
       analyzer.analyzeClass(inputStream, classFile.getPath());
     } catch (IOException e) {
       // (Godin): in fact JaCoCo includes name into exception
-      JaCoCoExtensions.LOG.warn("Exception during analysis of file " + classFile.getAbsolutePath(), e);
+      LOG.warn("Exception during analysis of file " + classFile.getAbsolutePath(), e);
     }
   }
 
@@ -139,7 +153,7 @@ private static void analyzeClassFile(Analyzer analyzer, File classFile) {
       analyzer.analyzeClass(inputStream, classFile.getPath());
     } catch (IOException e) {
       // (Godin): in fact JaCoCo includes name into exception
-      JaCoCoExtensions.LOG.warn("Exception during analysis of file " + classFile.getAbsolutePath(), e);
+      LOG.warn("Exception during analysis of file " + classFile.getAbsolutePath(), e);
     }
   }
 
diff --git a/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoReportMergerTest.java b/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoReportMergerTest.java
index bfef6fe196..ade3794b98 100755
--- a/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoReportMergerTest.java
+++ b/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoReportMergerTest.java
@@ -19,16 +19,15 @@
  */
 package org.sonar.plugins.jacoco;
 
+import java.io.File;
+import java.lang.reflect.Constructor;
+import java.util.Map;
 import org.jacoco.core.data.ExecutionDataStore;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TemporaryFolder;
-import org.sonar.squidbridge.api.AnalysisException;
-
-import java.io.File;
-import java.lang.reflect.Constructor;
-import java.util.Map;
+import org.sonar.java.AnalysisException;
 
 import static java.lang.reflect.Modifier.isFinal;
 import static java.lang.reflect.Modifier.isPrivate;
diff --git a/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoSensorTest.java b/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoSensorTest.java
index 91a60a1e2c..d89826ff14 100755
--- a/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoSensorTest.java
+++ b/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JaCoCoSensorTest.java
@@ -34,6 +34,7 @@
 import org.sonar.api.batch.fs.internal.TestInputFileBuilder;
 import org.sonar.api.batch.sensor.internal.SensorContextTester;
 import org.sonar.api.component.ResourcePerspectives;
+import org.sonar.api.config.internal.MapSettings;
 import org.sonar.api.internal.SonarRuntimeImpl;
 import org.sonar.api.test.MutableTestCase;
 import org.sonar.api.test.MutableTestPlan;
@@ -271,4 +272,33 @@ public void should_do_nothing_if_output_dir_does_not_exists() {
     assertThat(logTester.logs(LoggerLevel.INFO)).contains("No JaCoCo analysis of project coverage can be done since there is no class files.");
   }
 
+  @Test
+  public void should_log_when_class_are_not_matching_with_report() throws Exception {
+    String testDir = "/org/sonar/plugins/jacoco/JaCoCoNoMatch/";
+    outputDir = TestUtils.getResource(testDir);
+    jacocoExecutionData = new File(outputDir, "jacoco.exec");
+
+    Files.copy(TestUtils.getResource(testDir + "org/foo/bar/Example2.class.toCopy"), new File(outputDir, "org/foo/bar/Example2.class"));
+    Files.copy(TestUtils.getResource(testDir + "Example.class.toCopy"), new File(outputDir, "Example.class"));
+
+    DefaultInputFile resource = new TestInputFileBuilder("", "").setLines(10).build();
+
+    when(javaResourceLocator.findResourceByClassName(anyString())).thenReturn(resource);
+    when(javaClasspath.getBinaryDirs()).thenReturn(ImmutableList.of(outputDir));
+
+    SensorContextTester context = SensorContextTester.create(outputDir);
+    context.setRuntime(SonarRuntimeImpl.forSonarQube(SQ_6_7, SonarQubeSide.SCANNER));
+    context.fileSystem().setWorkDir(temp.newFolder().toPath());
+    context.setSettings(new MapSettings().setProperty(REPORT_PATHS_PROPERTY, jacocoExecutionData.getAbsolutePath()));
+
+    sensor.execute(context);
+
+    List<String> warnLogs = logTester.logs(LoggerLevel.WARN);
+    assertThat(warnLogs).contains(
+      "The following class(es) did not match with execution data:",
+      "> 'org/foo/bar/Example2'",
+      "> 'Example'",
+      "In order to have accurate coverage measures, the same class files must be used as at runtime for report generation.");
+  }
+
 }
diff --git a/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JacocoReportReaderTest.java b/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JacocoReportReaderTest.java
index 53d0026832..1ee054b6ad 100755
--- a/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JacocoReportReaderTest.java
+++ b/java-jacoco/src/test/java/org/sonar/plugins/jacoco/JacocoReportReaderTest.java
@@ -20,16 +20,15 @@
 package org.sonar.plugins.jacoco;
 
 import com.google.common.collect.Lists;
+import java.io.File;
+import java.util.Collection;
 import org.apache.commons.io.FileUtils;
 import org.assertj.core.api.Fail;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.ExpectedException;
 import org.junit.rules.TemporaryFolder;
-import org.sonar.squidbridge.api.AnalysisException;
-
-import java.io.File;
-import java.util.Collection;
+import org.sonar.java.AnalysisException;
 
 public class JacocoReportReaderTest {
 
diff --git a/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/Example.class.toCopy b/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/Example.class.toCopy
new file mode 100755
index 0000000000..0275a25cde
Binary files /dev/null and b/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/Example.class.toCopy differ
diff --git a/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/jacoco.exec b/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/jacoco.exec
new file mode 100755
index 0000000000..ef6b4ab0f2
Binary files /dev/null and b/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/jacoco.exec differ
diff --git a/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/org/foo/bar/Example2.class.toCopy b/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/org/foo/bar/Example2.class.toCopy
new file mode 100755
index 0000000000..d080a0f682
Binary files /dev/null and b/java-jacoco/src/test/resources/org/sonar/plugins/jacoco/JaCoCoNoMatch/org/foo/bar/Example2.class.toCopy differ
diff --git a/java-maven-model/pom.xml b/java-maven-model/pom.xml
index 98b6203d20..1269ca54bb 100755
--- a/java-maven-model/pom.xml
+++ b/java-maven-model/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-maven-model</artifactId>
diff --git a/java-surefire/pom.xml b/java-surefire/pom.xml
index 26db410c5e..c2b059ddb4 100755
--- a/java-surefire/pom.xml
+++ b/java-surefire/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>java-surefire</artifactId>
@@ -28,6 +28,14 @@
       <artifactId>maven-project</artifactId>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>com.google.guava</groupId>
+      <artifactId>guava</artifactId>
+    </dependency>
+    <dependency>
+      <groupId>com.google.code.findbugs</groupId>
+      <artifactId>jsr305</artifactId>
+    </dependency>
 
     <!-- unit tests -->
     <dependency>
diff --git a/java-surefire/src/main/java/org/sonar/plugins/surefire/SurefireJavaParser.java b/java-surefire/src/main/java/org/sonar/plugins/surefire/SurefireJavaParser.java
index dc0af2613d..4c432cff09 100755
--- a/java-surefire/src/main/java/org/sonar/plugins/surefire/SurefireJavaParser.java
+++ b/java-surefire/src/main/java/org/sonar/plugins/surefire/SurefireJavaParser.java
@@ -40,11 +40,11 @@
 import org.sonar.api.test.TestCase;
 import org.sonar.api.utils.log.Logger;
 import org.sonar.api.utils.log.Loggers;
+import org.sonar.java.AnalysisException;
 import org.sonar.plugins.java.api.JavaResourceLocator;
 import org.sonar.plugins.surefire.data.UnitTestClassReport;
 import org.sonar.plugins.surefire.data.UnitTestIndex;
 import org.sonar.plugins.surefire.data.UnitTestResult;
-import org.sonar.squidbridge.api.AnalysisException;
 
 /**
  * @since 2.4
diff --git a/pom.xml b/pom.xml
index 72478e2a67..b94d9bd2b5 100755
--- a/pom.xml
+++ b/pom.xml
@@ -10,7 +10,7 @@
 
   <groupId>org.sonarsource.java</groupId>
   <artifactId>java</artifactId>
-  <version>5.2.0-SNAPSHOT</version>
+  <version>5.3.0-SNAPSHOT</version>
   <packaging>pom</packaging>
   <name>SonarJava</name>
   <description>Code Analyzer for Java</description>
@@ -88,7 +88,7 @@
     <orchestrator.version>3.14.0.887</orchestrator.version>
     <sslr.version>1.22</sslr.version>
     <jacoco.previous.version>0.7.4.201502262128</jacoco.previous.version>
-    <jacoco.version>0.8.0</jacoco.version>
+    <jacoco.version>0.8.1</jacoco.version>
     <asm.version>6.0</asm.version>
     <argLine>-Xmx512m</argLine>
     <gitRepositoryName>sonar-java</gitRepositoryName>
@@ -126,6 +126,11 @@
         <artifactId>guava</artifactId>
         <version>19.0</version>
       </dependency>
+      <dependency>
+        <groupId>com.google.code.findbugs</groupId>
+        <artifactId>jsr305</artifactId>
+        <version>1.3.9</version>
+      </dependency>
       <dependency>
         <groupId>org.sonarsource.sslr</groupId>
         <artifactId>sslr-testing-harness</artifactId>
@@ -141,7 +146,7 @@
       <dependency>
         <groupId>org.sonarsource.sslr-squid-bridge</groupId>
         <artifactId>sslr-squid-bridge</artifactId>
-        <version>2.6.1</version>
+        <version>2.7.0.377</version>
         <exclusions>
           <exclusion>
             <groupId>org.codehaus.sonar.sslr</groupId>
@@ -156,8 +161,12 @@
             <artifactId>sslr-xpath</artifactId>
           </exclusion>
           <exclusion>
-            <groupId>org.slf4j</groupId>
-            <artifactId>jcl-over-slf4j</artifactId>
+            <groupId>com.google.guava</groupId>
+            <artifactId>guava</artifactId>
+          </exclusion>
+          <exclusion>
+            <groupId>com.google.code.findbugs</groupId>
+            <artifactId>jsr305</artifactId>
           </exclusion>
         </exclusions>
       </dependency>
diff --git a/sonar-jacoco-listeners/pom.xml b/sonar-jacoco-listeners/pom.xml
index cebf0dc9fc..86fc23c9df 100755
--- a/sonar-jacoco-listeners/pom.xml
+++ b/sonar-jacoco-listeners/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>sonar-jacoco-listeners</artifactId>
diff --git a/sonar-java-plugin/pom.xml b/sonar-java-plugin/pom.xml
index 986c528ee4..a5bc80db6b 100755
--- a/sonar-java-plugin/pom.xml
+++ b/sonar-java-plugin/pom.xml
@@ -5,7 +5,7 @@
   <parent>
     <groupId>org.sonarsource.java</groupId>
     <artifactId>java</artifactId>
-    <version>5.2.0-SNAPSHOT</version>
+    <version>5.3.0-SNAPSHOT</version>
   </parent>
 
   <artifactId>sonar-java-plugin</artifactId>
@@ -107,7 +107,7 @@
             <configuration>
               <rules>
                 <requireFilesSize>
-                  <maxsize>7000000</maxsize>
+                  <maxsize>8200000</maxsize>
                   <minsize>4500000</minsize>
                   <files>
                     <file>${project.build.directory}/${project.build.finalName}.jar</file>
diff --git a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaMetricDefinition.java b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaMetricDefinition.java
new file mode 100755
index 0000000000..8e191631f8
--- /dev/null
+++ b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaMetricDefinition.java
@@ -0,0 +1,34 @@
+/*
+ * SonarQube Java
+ * Copyright (C) 2012-2018 SonarSource SA
+ * mailto:info AT sonarsource DOT com
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 3 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+package org.sonar.plugins.java;
+
+import java.util.Collections;
+import java.util.List;
+import org.sonar.api.measures.Metric;
+import org.sonar.api.measures.Metrics;
+import org.sonar.java.SonarComponents;
+
+public class JavaMetricDefinition implements Metrics {
+
+  @Override
+  public List<Metric> getMetrics() {
+    return Collections.singletonList(SonarComponents.FEEDBACK_METRIC);
+  }
+}
diff --git a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaPlugin.java b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaPlugin.java
index ac4c43a599..b046b508ac 100755
--- a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaPlugin.java
+++ b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaPlugin.java
@@ -47,12 +47,19 @@ public void define(Context context) {
       builder.addAll(JaCoCoExtensions.getExtensions());
       builder.add(JavaSonarWayProfile.class);
       builder.add(JavaClasspath.class);
-      builder.add(PropertyDefinition.builder("sonar.java.failOnException")
+      builder.add(PropertyDefinition.builder(SonarComponents.FAIL_ON_EXCEPTION_KEY)
         .defaultValue("false")
         .hidden()
         .name("Fail on exceptions")
         .description("when set to true, if an exception is thrown by the analyzer the analysis will fail")
         .build());
+      builder.add(PropertyDefinition.builder(SonarComponents.COLLECT_ANALYSIS_ERRORS_KEY)
+        .defaultValue("false")
+        .hidden()
+        .name("Collect analysis error")
+        .description("when set to true, if an exception is thrown by the analyzer, feedback will be collected and sent to server")
+        .build());
+      builder.add(JavaMetricDefinition.class);
     }
     builder.addAll(JavaClasspathProperties.getProperties());
     builder.add(
diff --git a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaRulesDefinition.java b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaRulesDefinition.java
index f11248a1e2..ca4c84815c 100755
--- a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaRulesDefinition.java
+++ b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaRulesDefinition.java
@@ -21,6 +21,7 @@
 
 import com.google.common.annotations.VisibleForTesting;
 import com.google.common.collect.ImmutableList;
+import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterables;
 import com.google.common.io.Resources;
 import com.google.gson.Gson;
@@ -29,6 +30,7 @@
 import java.nio.charset.StandardCharsets;
 import java.util.List;
 import java.util.Locale;
+import java.util.Set;
 import javax.annotation.Nullable;
 import org.apache.commons.lang.StringUtils;
 import org.sonar.api.config.Configuration;
@@ -39,7 +41,6 @@
 import org.sonar.api.server.rule.RulesDefinitionAnnotationLoader;
 import org.sonar.api.utils.AnnotationUtils;
 import org.sonar.java.checks.CheckList;
-import org.sonar.squidbridge.annotations.RuleTemplate;
 
 /**
  * Definition of rules.
@@ -48,6 +49,17 @@
 
   private final boolean isDebugEnabled;
 
+  /**
+   * Rule templates have to be manually defined
+   */
+  private static final Set<String> TEMPLATE_RULE_KEY = ImmutableSet.of(
+    "S124",
+    "S2253",
+    "S3417",
+    "S3688",
+    "S3546",
+    "S4011");
+
   /**
    * 'Configuration' does exists yet in SonarLint context, consequently, in standalone mode, this constructor will be used.
    * See {@link https://jira.sonarsource.com/browse/SLCORE-159}
@@ -103,7 +115,7 @@ protected void newRule(Class<?> ruleClass, NewRepository repository, JavaSonarWa
     String metadataKey = ruleMetadata(ruleClass, rule);
     // 'setActivatedByDefault' is used by SonarLint standalone, to define which rules will be active
     rule.setActivatedByDefault(profile.ruleKeys.contains(ruleKey) || profile.ruleKeys.contains(metadataKey));
-    rule.setTemplate(AnnotationUtils.getAnnotation(ruleClass, RuleTemplate.class) != null);
+    rule.setTemplate(TEMPLATE_RULE_KEY.contains(ruleKey));
   }
 
   private String ruleMetadata(Class<?> ruleClass, NewRule rule) {
diff --git a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSonarWayProfile.java b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSonarWayProfile.java
index 2c349f282d..0c50695518 100755
--- a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSonarWayProfile.java
+++ b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSonarWayProfile.java
@@ -29,6 +29,7 @@
 import java.util.Map;
 import org.sonar.api.server.profile.BuiltInQualityProfilesDefinition;
 import org.sonar.api.utils.AnnotationUtils;
+import org.sonar.java.SonarComponents;
 import org.sonar.java.checks.CheckList;
 import org.sonarsource.api.sonarlint.SonarLintSide;
 
@@ -47,9 +48,13 @@ public void define(Context context) {
     for (String key : jsonProfile.ruleKeys) {
       sonarWay.activateRule(CheckList.REPOSITORY_KEY, keys.get(key));
     }
+
+    SonarComponents.getSecurityRuleKeys().forEach(key -> sonarWay.activateRule(CheckList.REPOSITORY_KEY, key));
+
     sonarWay.done();
   }
 
+
   private static Map<String, String> legacyKeys() {
     Map<String, String> result = new HashMap<>();
     for (Class checkClass : CheckList.getChecks()) {
diff --git a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSquidSensor.java b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSquidSensor.java
index 7e3c353625..0721ebaf1e 100755
--- a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSquidSensor.java
+++ b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/JavaSquidSensor.java
@@ -21,6 +21,7 @@
 
 import com.google.common.collect.ImmutableList;
 import java.io.File;
+import java.util.Collection;
 import java.util.List;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
@@ -79,6 +80,7 @@ public void describe(SensorDescriptor descriptor) {
   public void execute(SensorContext context) {
     javaResourceLocator.setSensorContext(context);
     sonarComponents.setSensorContext(context);
+    sonarComponents.setRuleRepositoryKey(CheckList.REPOSITORY_KEY);
 
     List<Class<? extends JavaCheck>> checks = ImmutableList.<Class<? extends JavaCheck>>builder()
       .addAll(CheckList.getJavaChecks())
@@ -92,15 +94,15 @@ public void execute(SensorContext context) {
     sonarComponents.saveAnalysisErrors();
   }
 
-  private Iterable<File> getSourceFiles() {
+  private Collection<File> getSourceFiles() {
     return toFile(fs.inputFiles(fs.predicates().and(fs.predicates().hasLanguage(Java.KEY), fs.predicates().hasType(InputFile.Type.MAIN))));
   }
 
-  private Iterable<File> getTestFiles() {
+  private Collection<File> getTestFiles() {
     return toFile(fs.inputFiles(fs.predicates().and(fs.predicates().hasLanguage(Java.KEY), fs.predicates().hasType(InputFile.Type.TEST))));
   }
 
-  private static Iterable<File> toFile(Iterable<InputFile> inputFiles) {
+  private static Collection<File> toFile(Iterable<InputFile> inputFiles) {
     return StreamSupport.stream(inputFiles.spliterator(), false).map(InputFile::file).collect(Collectors.toList());
   }
 
diff --git a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/XmlFileSensor.java b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/XmlFileSensor.java
index 0861a46b5c..6a685ff619 100755
--- a/sonar-java-plugin/src/main/java/org/sonar/plugins/java/XmlFileSensor.java
+++ b/sonar-java-plugin/src/main/java/org/sonar/plugins/java/XmlFileSensor.java
@@ -20,6 +20,7 @@
 package org.sonar.plugins.java;
 
 import java.io.File;
+import java.util.Collection;
 import java.util.stream.Collectors;
 import java.util.stream.StreamSupport;
 import org.sonar.api.batch.fs.FilePredicate;
@@ -69,7 +70,7 @@ private boolean hasXmlFiles() {
     return fs.inputFiles(xmlFilePredicate);
   }
 
-  private static Iterable<File> toFile(Iterable<InputFile> inputFiles) {
+  private static Collection<File> toFile(Iterable<InputFile> inputFiles) {
     return StreamSupport.stream(inputFiles.spliterator(), false).map(InputFile::file).collect(Collectors.toList());
   }
 
diff --git a/java-checks/src/test/java/org/sonar/java/checks/helpers/MethodsHelperTest.java b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaMetricDefinitionTest.java
similarity index 72%
rename from java-checks/src/test/java/org/sonar/java/checks/helpers/MethodsHelperTest.java
rename to sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaMetricDefinitionTest.java
index 8215aa9690..3b604dc3ef 100755
--- a/java-checks/src/test/java/org/sonar/java/checks/helpers/MethodsHelperTest.java
+++ b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaMetricDefinitionTest.java
@@ -17,21 +17,16 @@
  * along with this program; if not, write to the Free Software Foundation,
  * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
-package org.sonar.java.checks.helpers;
+package org.sonar.plugins.java;
 
 import org.junit.Test;
 
-import java.lang.reflect.Constructor;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
-public class MethodsHelperTest {
+public class JavaMetricDefinitionTest {
 
   @Test
-  public void private_constructor() throws Exception {
-    Constructor constructor = MethodsHelper.class.getDeclaredConstructor();
-    assertThat(constructor.isAccessible()).isFalse();
-    constructor.setAccessible(true);
-    constructor.newInstance();
+  public void metrics_defined() {
+    assertThat(new JavaMetricDefinition().getMetrics()).hasSize(1);
   }
 }
diff --git a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaPluginTest.java b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaPluginTest.java
index 33b0ffe631..fb3606d97b 100755
--- a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaPluginTest.java
+++ b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaPluginTest.java
@@ -46,7 +46,7 @@ public void sonarqube_6_7_extensions() {
     SonarRuntime runtime = SonarRuntimeImpl.forSonarQube(VERSION_6_7, SonarQubeSide.SERVER);
     Plugin.Context context = new Plugin.Context(runtime);
     javaPlugin.define(context);
-    assertThat(context.getExtensions()).hasSize(22);
+    assertThat(context.getExtensions()).hasSize(24);
 
   }
 
diff --git a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaRulesDefinitionTest.java b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaRulesDefinitionTest.java
index 25f4a38554..faa247a42f 100755
--- a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaRulesDefinitionTest.java
+++ b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaRulesDefinitionTest.java
@@ -68,6 +68,11 @@ public void test_creation_of_rules() {
     RulesDefinition.Rule unusedPrivateMethodRule = repository.rule("UnusedPrivateMethod");
     assertThat(unusedPrivateMethodRule.activatedByDefault()).isEqualTo(true);
 
+    // rule templates are manually defined
+    assertThat(repository.rules().stream()
+      .filter(RulesDefinition.Rule::template)
+      .map(RulesDefinition.Rule::key)).containsOnly("S124", "S2253", "S3417", "S3688", "S3546", "S4011");
+
     // Calling definition multiple time should not lead to failure: thanks C# plugin !
     definition.define(new RulesDefinition.Context());
   }
diff --git a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaSquidSensorTest.java b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaSquidSensorTest.java
index 2a0f0383ef..90d0d60694 100755
--- a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaSquidSensorTest.java
+++ b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/JavaSquidSensorTest.java
@@ -27,9 +27,10 @@
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Files;
 import java.util.Collection;
+import org.junit.Rule;
 import org.junit.Test;
+import org.junit.rules.TemporaryFolder;
 import org.sonar.api.SonarQubeSide;
-import org.sonar.api.batch.fs.FileSystem;
 import org.sonar.api.batch.fs.InputFile;
 import org.sonar.api.batch.fs.internal.DefaultFileSystem;
 import org.sonar.api.batch.fs.internal.DefaultInputFile;
@@ -56,7 +57,6 @@
 import org.sonar.java.checks.naming.BadMethodNameCheck;
 import org.sonar.java.filters.PostAnalysisIssueFilter;
 import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.squidbridge.api.CodeVisitor;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
@@ -78,6 +78,10 @@
     when(checks.ruleKey(any(JavaCheck.class))).thenReturn(RuleKey.of("squid", RuleAnnotationUtils.getRuleKey(BadMethodNameCheck.class)));
     when(checkFactory.create(anyString())).thenReturn(checks);
   }
+
+  @Rule
+  public final TemporaryFolder tmp = new TemporaryFolder();
+
   @Test
   public void test_toString() {
     assertThat(new JavaSquidSensor(null, null, null, null, null, null).toString()).isEqualTo("JavaSquidSensor");
@@ -93,7 +97,6 @@ public void test_issues_creation_on_test_file() throws IOException { // NOSONAR
     testIssueCreation(InputFile.Type.TEST, 0);
   }
 
-
   private void testIssueCreation(InputFile.Type onType, int expectedIssues) throws IOException {
     MapSettings settings = new MapSettings();
     NoSonarFilter noSonarFilter = mock(NoSonarFilter.class);
@@ -105,7 +108,7 @@ private void testIssueCreation(InputFile.Type onType, int expectedIssues) throws
     JavaSquidSensor jss = new JavaSquidSensor(sonarComponents, fs, javaResourceLocator, settings.asConfig(), noSonarFilter, postAnalysisIssueFilter);
 
     jss.execute(context);
-    verify(noSonarFilter, times(1)).noSonarInFile(fs.inputFiles().iterator().next(), Sets.newHashSet(92));
+    verify(noSonarFilter, times(1)).noSonarInFile(fs.inputFiles().iterator().next(), Sets.newHashSet(96));
     verify(sonarComponents, times(expectedIssues)).reportIssue(any(AnalyzerMessage.class));
 
     settings.setProperty(Java.SOURCE_VERSION, "wrongFormat");
@@ -139,18 +142,18 @@ private static SonarComponents createSonarComponentsMock(SensorContextTester con
     FileLinesContext fileLinesContext = mock(FileLinesContext.class);
     FileLinesContextFactory fileLinesContextFactory = mock(FileLinesContextFactory.class);
     when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext);
-    SonarComponents sonarComponents = spy(new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory, server));
+    SonarComponents sonarComponents = spy(new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory));
     sonarComponents.setSensorContext(contextTester);
 
     BadMethodNameCheck check = new BadMethodNameCheck();
-    when(sonarComponents.checkClasses()).thenReturn(new CodeVisitor[]{check});
+    when(sonarComponents.checkClasses()).thenReturn(new JavaCheck[] {check});
     return sonarComponents;
   }
 
   @Test
   public void verify_analysis_errors_are_collected_on_parse_error() throws Exception {
     SensorContextTester context = createParseErrorContext();
-    when(server.getPublicRootUrl()).thenReturn("https://sonarcloud.io");
+    context.settings().setProperty(SonarComponents.COLLECT_ANALYSIS_ERRORS_KEY, true);
     executeJavaSquidSensor(context);
 
     String feedback = context.<String>measure("projectKey", "sonarjava_feedback").value();
@@ -179,16 +182,15 @@ private SensorContextTester createParseErrorContext() throws IOException {
   private void executeJavaSquidSensor(SensorContextTester context) {
 
     context.setRuntime(SonarRuntimeImpl.forSonarQube(Version.create(6, 7), SonarQubeSide.SCANNER));
-
     // Mock visitor for metrics.
     FileLinesContext fileLinesContext = mock(FileLinesContext.class);
     FileLinesContextFactory fileLinesContextFactory = mock(FileLinesContextFactory.class);
     when(fileLinesContextFactory.createFor(any(InputFile.class))).thenReturn(fileLinesContext);
 
-    FileSystem fs = context.fileSystem();
+    DefaultFileSystem fs = context.fileSystem().setWorkDir(tmp.getRoot().toPath());
     JavaClasspath javaClasspath = mock(JavaClasspath.class);
     JavaTestClasspath javaTestClasspath = mock(JavaTestClasspath.class);
-    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory, server);
+    SonarComponents sonarComponents = new SonarComponents(fileLinesContextFactory, fs, javaClasspath, javaTestClasspath, checkFactory);
     DefaultJavaResourceLocator javaResourceLocator = mock(DefaultJavaResourceLocator.class);
     NoSonarFilter noSonarFilter = mock(NoSonarFilter.class);
     PostAnalysisIssueFilter postAnalysisIssueFilter = new PostAnalysisIssueFilter(fs);
@@ -200,7 +202,7 @@ private void executeJavaSquidSensor(SensorContextTester context) {
   @Test
   public void feedbackShouldNotBeFedIfNoErrors() throws IOException {
     SensorContextTester context = createContext(InputFile.Type.MAIN);
-    when(server.getPublicRootUrl()).thenReturn("https://sonarcloud.io");
+    context.settings().setProperty(SonarComponents.COLLECT_ANALYSIS_ERRORS_KEY, true);
     executeJavaSquidSensor(context);
     assertThat(context.<String>measure("projectKey", "sonarjava_feedback")).isNull();
   }
@@ -208,7 +210,6 @@ public void feedbackShouldNotBeFedIfNoErrors() throws IOException {
   @Test
   public void feedbackShouldNotBeFedIfNotSonarCloudHost() throws IOException {
     SensorContextTester context = createParseErrorContext();
-    when(server.getPublicRootUrl()).thenReturn("https://somerandomurl.com");
     executeJavaSquidSensor(context);
     assertThat(context.<String>measure("projectKey", "sonarjava_feedback")).isNull();
   }
diff --git a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/XmlFileSensorTest.java b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/XmlFileSensorTest.java
index bbf3a6b5bd..e6ce832bed 100755
--- a/sonar-java-plugin/src/test/java/org/sonar/plugins/java/XmlFileSensorTest.java
+++ b/sonar-java-plugin/src/test/java/org/sonar/plugins/java/XmlFileSensorTest.java
@@ -39,7 +39,6 @@
 import org.sonar.java.SonarComponents;
 import org.sonar.java.checks.xml.maven.PomElementOrderCheck;
 import org.sonar.plugins.java.api.JavaCheck;
-import org.sonar.squidbridge.api.CodeVisitor;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.ArgumentMatchers.any;
@@ -118,7 +117,7 @@ private static SonarComponents createSonarComponentsMock(DefaultFileSystem fs) t
 
   private static SonarComponents createSonarComponentsMock(DefaultFileSystem fs, @Nullable File file) throws IOException {
     SonarComponents sonarComponents = mock(SonarComponents.class);
-    when(sonarComponents.checkClasses()).thenReturn(new CodeVisitor[] {new PomElementOrderCheck()});
+    when(sonarComponents.checkClasses()).thenReturn(new JavaCheck[] {new PomElementOrderCheck()});
 
     when(sonarComponents.getFileSystem()).thenReturn(fs);
     if (file != null) {
diff --git a/sonarpedia.json b/sonarpedia.json
index e024230602..c37c0270d7 100755
--- a/sonarpedia.json
+++ b/sonarpedia.json
@@ -3,5 +3,5 @@
   "languages": [
     "JAVA"
   ],
-  "latest-update": "2018-01-26T14:47:55.358Z"
+  "latest-update": "2018-03-16T13:47:19.824Z"
 }
\ No newline at end of file
diff --git a/travis.sh b/travis.sh
index 8a48af0b77..3c8b9d22d6 100755
--- a/travis.sh
+++ b/travis.sh
@@ -4,7 +4,7 @@ set -euo pipefail
 
 function configureTravis {
   mkdir -p ~/.local
-  curl -sSL https://github.com/SonarSource/travis-utils/tarball/v45 | tar zx --strip-components 1 -C ~/.local
+  curl -sSL https://github.com/SonarSource/travis-utils/tarball/v47 | tar zx --strip-components 1 -C ~/.local
   source ~/.local/bin/install
 }
 
