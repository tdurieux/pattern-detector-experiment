diff --git a/lucene/java/trunk/contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java b/lucene/java/trunk/contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java
index af229a92..3416db30 100644
--- a/lucene/java/trunk/contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java
+++ b/lucene/java/trunk/contrib/spellchecker/src/java/org/apache/lucene/search/spell/SpellChecker.java
@@ -32,6 +32,7 @@
 import org.apache.lucene.search.Query;
 import org.apache.lucene.search.ScoreDoc;
 import org.apache.lucene.search.TermQuery;
+import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
 
 /**
@@ -61,9 +62,13 @@
    */
   public static final String F_WORD = "word";
 
+  private static final Term F_WORD_TERM = new Term(F_WORD);
+
   /**
    * the spell index
    */
+  // don't modify the directory directly - see #swapSearcher()
+  // TODO: why is this package private?
   Directory spellIndex;
 
   /**
@@ -72,8 +77,23 @@
   private float bStart = 2.0f;
   private float bEnd = 1.0f;
 
+  // don't use this searcher directly - see #swapSearcher()
   private IndexSearcher searcher;
 
+  /*
+   * this locks all modifications to the current searcher. 
+   */
+  private final Object searcherLock = new Object();
+  
+  /*
+   * this lock synchronizes all possible modifications to the 
+   * current index directory. It should not be possible to try modifying
+   * the same index concurrently. Note: Do not acquire the searcher lock
+   * before acquiring this lock! 
+   */
+  private final Object modifyCurrentIndexLock = new Object();
+  private volatile boolean closed = false;
+
   // minimum score for hits generated by the spell checker query
   private float minScore = 0.5f;
   
@@ -82,15 +102,24 @@
   /**
    * Use the given directory as a spell checker index. The directory
    * is created if it doesn't exist yet.
+   * @param spellIndex the spell index directory
+   * @param sd the {@link StringDistance} measurement to use 
+   * @throws IOException if Spellchecker can not open the directory
+   */
+  public SpellChecker(Directory spellIndex, StringDistance sd) throws IOException {
+    setSpellIndex(spellIndex);
+    setStringDistance(sd);
+  }
+  /**
+   * Use the given directory as a spell checker index with a
+   * {@link LevensteinDistance} as the default {@link StringDistance}. The
+   * directory is created if it doesn't exist yet.
    * 
    * @param spellIndex
+   *          the spell index directory
    * @throws IOException
+   *           if spellchecker can not open the directory
    */
-  public SpellChecker(Directory spellIndex,StringDistance sd) throws IOException {
-    this.setSpellIndex(spellIndex);
-    this.setStringDistance(sd);
-  }
-
   public SpellChecker(Directory spellIndex) throws IOException {
     this(spellIndex, new LevensteinDistance());
   }
@@ -99,27 +128,41 @@ public SpellChecker(Directory spellIndex) throws IOException {
    * Use a different index as the spell checker index or re-open
    * the existing index if <code>spellIndex</code> is the same value
    * as given in the constructor.
-   * 
-   * @param spellIndex
-   * @throws IOException
+   * @param spellIndexDir the spell directory to use
+   * @throws AlreadyClosedException if the Spellchecker is already closed
+   * @throws  IOException if spellchecker can not open the directory
    */
-  public void setSpellIndex(Directory spellIndex) throws IOException {
-    this.spellIndex = spellIndex;
-    if (!IndexReader.indexExists(spellIndex)) {
-        IndexWriter writer = new IndexWriter(spellIndex, null, true, IndexWriter.MaxFieldLength.UNLIMITED);
+  // TODO: we should make this final as it is called in the constructor
+  public void setSpellIndex(Directory spellIndexDir) throws IOException {
+    // this could be the same directory as the current spellIndex
+    // modifications to the directory should be synchronized 
+    synchronized (modifyCurrentIndexLock) {
+      ensureOpen();
+      if (!IndexReader.indexExists(spellIndexDir)) {
+          IndexWriter writer = new IndexWriter(spellIndexDir, null, true,
+              IndexWriter.MaxFieldLength.UNLIMITED);
         writer.close();
     }
-    // close the old searcher, if there was one
-    if (searcher != null) {
-      searcher.close();
+      swapSearcher(spellIndexDir);
     }
-    searcher = new IndexSearcher(this.spellIndex, true);
   }
-  
+  /**
+   * Sets the {@link StringDistance} implementation for this
+   * {@link SpellChecker} instance.
+   * 
+   * @param sd the {@link StringDistance} implementation for this
+   * {@link SpellChecker} instance
+   */
   public void setStringDistance(StringDistance sd) {
     this.sd = sd;
   }
-
+  /**
+   * Returns the {@link StringDistance} instance used by this
+   * {@link SpellChecker} instance.
+   * 
+   * @return the {@link StringDistance} instance used by this
+   *         {@link SpellChecker} instance.
+   */
   public StringDistance getStringDistance() {
     return sd;
   }
@@ -144,7 +187,8 @@ public void setAccuracy(float minScore) {
    *
    * @param word the word you want a spell check done on
    * @param numSug the number of suggested words
-   * @throws IOException
+   * @throws IOException if the underlying index throws an {@link IOException}
+   * @throws AlreadyClosedException if the Spellchecker is already closed
    * @return String[]
    */
   public String[] suggestSimilar(String word, int numSug) throws IOException {
@@ -169,14 +213,17 @@ public void setAccuracy(float minScore) {
    * words are restricted to the words present in this field.
    * @param morePopular return only the suggest words that are as frequent or more frequent than the searched word
    * (only if restricted mode = (indexReader!=null and field!=null)
-   * @throws IOException
+   * @throws IOException if the underlying index throws an {@link IOException}
+   * @throws AlreadyClosedException if the Spellchecker is already closed
    * @return String[] the sorted list of the suggest words with these 2 criteria:
    * first criteria: the edit distance, second criteria (only if restricted mode): the popularity
    * of the suggest words in the field of the user index
    */
   public String[] suggestSimilar(String word, int numSug, IndexReader ir,
       String field, boolean morePopular) throws IOException {
-
+    // obtainSearcher calls ensureOpen
+    final IndexSearcher indexSearcher = obtainSearcher();
+    try{
     float min = this.minScore;
     final int lengthWord = word.length();
 
@@ -216,9 +263,9 @@ public void setAccuracy(float minScore) {
 
     int maxHits = 10 * numSug;
     
-//    System.out.println("Q: " + query);
-    ScoreDoc[] hits = searcher.search(query, null, maxHits).scoreDocs;
-//    System.out.println("HITS: " + hits.length());
+  //    System.out.println("Q: " + query);
+      ScoreDoc[] hits = indexSearcher.search(query, null, maxHits).scoreDocs;
+  //    System.out.println("HITS: " + hits.length());
     SuggestWordQueue sugQueue = new SuggestWordQueue(numSug);
 
     // go thru more than 'maxr' matches in case the distance filter triggers
@@ -226,7 +273,7 @@ public void setAccuracy(float minScore) {
     SuggestWord sugWord = new SuggestWord();
     for (int i = 0; i < stop; i++) {
 
-      sugWord.string = searcher.doc(hits[i].doc).get(F_WORD); // get orig word
+        sugWord.string = indexSearcher.doc(hits[i].doc).get(F_WORD); // get orig word
 
       // don't suggest a word for itself, that would be silly
       if (sugWord.string.equals(word)) {
@@ -261,6 +308,9 @@ public void setAccuracy(float minScore) {
     }
 
     return list;
+    } finally {
+      releaseSearcher(indexSearcher);
+    }
   }
 
   /**
@@ -297,24 +347,33 @@ private static void add(BooleanQuery q, String name, String value) {
   /**
    * Removes all terms from the spell check index.
    * @throws IOException
+   * @throws AlreadyClosedException if the Spellchecker is already closed
    */
   public void clearIndex() throws IOException {
-    IndexWriter writer = new IndexWriter(spellIndex, null, true, IndexWriter.MaxFieldLength.UNLIMITED);
+    synchronized (modifyCurrentIndexLock) {
+      ensureOpen();
+      final Directory dir = this.spellIndex;
+      final IndexWriter writer = new IndexWriter(dir, null, true, IndexWriter.MaxFieldLength.UNLIMITED);
     writer.close();
-    
-    //close the old searcher
-    searcher.close();
-    searcher = new IndexSearcher(this.spellIndex, true);
+      swapSearcher(dir);
+    }
   }
 
   /**
    * Check whether the word exists in the index.
    * @param word
    * @throws IOException
-   * @return true iff the word exists in the index
+   * @throws AlreadyClosedException if the Spellchecker is already closed
+   * @return true if the word exists in the index
    */
   public boolean exist(String word) throws IOException {
-    return searcher.docFreq(new Term(F_WORD, word)) > 0;
+    // obtainSearcher calls ensureOpen
+    final IndexSearcher indexSearcher = obtainSearcher();
+    try{
+      return indexSearcher.docFreq(F_WORD_TERM.createTerm(word)) > 0;
+    } finally {
+      releaseSearcher(indexSearcher);
+    }
   }
 
   /**
@@ -322,10 +381,15 @@ public boolean exist(String word) throws IOException {
    * @param dict Dictionary to index
    * @param mergeFactor mergeFactor to use when indexing
    * @param ramMB the max amount or memory in MB to use
+   * @throws AlreadyClosedException if the Spellchecker is already closed
    * @throws IOException
    */
   public void indexDictionary(Dictionary dict, int mergeFactor, int ramMB) throws IOException {
-    IndexWriter writer = new IndexWriter(spellIndex, new WhitespaceAnalyzer(), IndexWriter.MaxFieldLength.UNLIMITED);
+    synchronized (modifyCurrentIndexLock) {
+      ensureOpen();
+      final Directory dir = this.spellIndex;
+      final IndexWriter writer = new IndexWriter(dir, new WhitespaceAnalyzer(),
+          IndexWriter.MaxFieldLength.UNLIMITED);
     writer.setMergeFactor(mergeFactor);
     writer.setRAMBufferSizeMB(ramMB);
 
@@ -351,8 +415,8 @@ public void indexDictionary(Dictionary dict, int mergeFactor, int ramMB) throws
     writer.close();
     // also re-open the spell index to see our own changes when the next suggestion
     // is fetched:
-    searcher.close();
-    searcher = new IndexSearcher(this.spellIndex, true);
+      swapSearcher(dir);
+    }
   }
 
   /**
@@ -364,7 +428,7 @@ public void indexDictionary(Dictionary dict) throws IOException {
     indexDictionary(dict, 300, 10);
   }
 
-  private int getMin(int l) {
+  private static int getMin(int l) {
     if (l > 5) {
       return 3;
     }
@@ -374,7 +438,7 @@ private int getMin(int l) {
     return 1;
   }
 
-  private int getMax(int l) {
+  private static int getMax(int l) {
     if (l > 5) {
       return 4;
     }
@@ -410,11 +474,83 @@ private static void addGram(String text, Document doc, int ng1, int ng2) {
     }
   }
 
+  private IndexSearcher obtainSearcher() {
+    synchronized (searcherLock) {
+      ensureOpen();
+      searcher.getIndexReader().incRef();
+      return searcher;
+    }
+  }
+  
+  private void releaseSearcher(final IndexSearcher aSearcher) throws IOException{
+      // don't check if open - always decRef 
+      // don't decrement the private searcher - could have been swapped
+      aSearcher.getIndexReader().decRef();      
+  }
+  
+  private void ensureOpen() {
+    if (closed) {
+      throw new AlreadyClosedException("Spellchecker has been closed");
+    }
+  }
+  
   /**
-   * Close the IndexSearcher used by this SpellChecker.
+   * Close the IndexSearcher used by this SpellChecker
+   * @throws IOException if the close operation causes an {@link IOException}
+   * @throws AlreadyClosedException if the {@link SpellChecker} is already closed
    */
   public void close() throws IOException {
+    synchronized (searcherLock) {
+      ensureOpen();
+      closed = true;
+      if (searcher != null) {
     searcher.close();
+      }
     searcher = null;
   }
+  }
+  
+  private void swapSearcher(final Directory dir) throws IOException {
+    /*
+     * opening a searcher is possibly very expensive.
+     * We rather close it again if the Spellchecker was closed during
+     * this operation than block access to the current searcher while opening.
+     */
+    final IndexSearcher indexSearcher = createSearcher(dir);
+    synchronized (searcherLock) {
+      if(closed){
+        indexSearcher.close();
+        throw new AlreadyClosedException("Spellchecker has been closed");
+      }
+      if (searcher != null) {
+        searcher.close();
+      }
+      // set the spellindex in the sync block - ensure consistency.
+      searcher = indexSearcher;
+      this.spellIndex = dir;
+    }
+  }
+  
+  /**
+   * Creates a new read-only IndexSearcher 
+   * @param dir the directory used to open the searcher
+   * @return a new read-only IndexSearcher
+   * @throws IOException f there is a low-level IO error
+   */
+  // for testing purposes
+  IndexSearcher createSearcher(final Directory dir) throws IOException{
+    return new IndexSearcher(dir, true);
+  }
+  
+  /**
+   * Returns <code>true</code> if and only if the {@link SpellChecker} is
+   * closed, otherwise <code>false</code>.
+   * 
+   * @return <code>true</code> if and only if the {@link SpellChecker} is
+   *         closed, otherwise <code>false</code>.
+   */
+  boolean isClosed(){
+    return closed;
+  }
+  
 }
diff --git a/lucene/java/trunk/contrib/spellchecker/src/test/org/apache/lucene/search/spell/TestSpellChecker.java b/lucene/java/trunk/contrib/spellchecker/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
index 995ee1ae..02bb442e 100644
--- a/lucene/java/trunk/contrib/spellchecker/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
+++ b/lucene/java/trunk/contrib/spellchecker/src/test/org/apache/lucene/search/spell/TestSpellChecker.java
@@ -18,8 +18,13 @@
  */
 
 import java.io.IOException;
-
-import junit.framework.TestCase;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Random;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import java.util.concurrent.TimeUnit;
 
 import org.apache.lucene.analysis.SimpleAnalyzer;
 import org.apache.lucene.document.Document;
@@ -27,9 +32,12 @@
 import org.apache.lucene.index.CorruptIndexException;
 import org.apache.lucene.index.IndexReader;
 import org.apache.lucene.index.IndexWriter;
+import org.apache.lucene.search.IndexSearcher;
+import org.apache.lucene.store.AlreadyClosedException;
 import org.apache.lucene.store.Directory;
 import org.apache.lucene.store.RAMDirectory;
 import org.apache.lucene.util.English;
+import org.apache.lucene.util.LuceneTestCase;
 
 
 /**
@@ -37,9 +45,11 @@
  *
  *
  */
-public class TestSpellChecker extends TestCase {
-  private SpellChecker spellChecker;
+public class TestSpellChecker extends LuceneTestCase {
+  private SpellCheckerMock spellChecker;
   private Directory userindex, spellindex;
+  private final Random random = newRandom();
+  private List<IndexSearcher> searchers;
 
   @Override
   protected void setUp() throws Exception {
@@ -56,10 +66,10 @@ protected void setUp() throws Exception {
       writer.addDocument(doc);
     }
     writer.close();
-
+    searchers = Collections.synchronizedList(new ArrayList<IndexSearcher>());
     // create the spellChecker
     spellindex = new RAMDirectory();
-    spellChecker = new SpellChecker(spellindex);
+    spellChecker = new SpellCheckerMock(spellindex);
   }
 
 
@@ -76,6 +86,8 @@ public void testBuild() throws CorruptIndexException, IOException {
 
     assertEquals(num_field2, num_field1 + 1);
 
+    assertLastSearcherOpen(4);
+    
     checkCommonSuggestions(r);
     checkLevenshteinSuggestions(r);
     
@@ -201,4 +213,186 @@ private int numdoc() throws IOException {
     return num;
   }
   
+  public void testClose() throws IOException {
+    IndexReader r = IndexReader.open(userindex, true);
+    spellChecker.clearIndex();
+    String field = "field1";
+    addwords(r, "field1");
+    int num_field1 = this.numdoc();
+    addwords(r, "field2");
+    int num_field2 = this.numdoc();
+    assertEquals(num_field2, num_field1 + 1);
+    checkCommonSuggestions(r);
+    assertLastSearcherOpen(4);
+    spellChecker.close();
+    assertSearchersClosed();
+    try {
+      spellChecker.close();
+      fail("spellchecker was already closed");
+    } catch (AlreadyClosedException e) {
+      // expected
+    }
+    try {
+      checkCommonSuggestions(r);
+      fail("spellchecker was already closed");
+    } catch (AlreadyClosedException e) {
+      // expected
+    }
+    
+    try {
+      spellChecker.clearIndex();
+      fail("spellchecker was already closed");
+    } catch (AlreadyClosedException e) {
+      // expected
+    }
+    
+    try {
+      spellChecker.indexDictionary(new LuceneDictionary(r, field));
+      fail("spellchecker was already closed");
+    } catch (AlreadyClosedException e) {
+      // expected
+    }
+    
+    try {
+      spellChecker.setSpellIndex(spellindex);
+      fail("spellchecker was already closed");
+    } catch (AlreadyClosedException e) {
+      // expected
+    }
+    assertEquals(4, searchers.size());
+    assertSearchersClosed();
+  }
+  
+  /*
+   * tests if the internally shared indexsearcher is correctly closed 
+   * when the spellchecker is concurrently accessed and closed.
+   */
+  public void testConcurrentAccess() throws IOException, InterruptedException {
+    assertEquals(1, searchers.size());
+    final IndexReader r = IndexReader.open(userindex, true);
+    spellChecker.clearIndex();
+    assertEquals(2, searchers.size());
+    addwords(r, "field1");
+    assertEquals(3, searchers.size());
+    int num_field1 = this.numdoc();
+    addwords(r, "field2");
+    assertEquals(4, searchers.size());
+    int num_field2 = this.numdoc();
+    assertEquals(num_field2, num_field1 + 1);
+    int numThreads = 5 + this.random.nextInt(5);
+    ExecutorService executor = Executors.newFixedThreadPool(numThreads);
+    SpellCheckWorker[] workers = new SpellCheckWorker[numThreads];
+    for (int i = 0; i < numThreads; i++) {
+      SpellCheckWorker spellCheckWorker = new SpellCheckWorker(r);
+      executor.execute(spellCheckWorker);
+      workers[i] = spellCheckWorker;
+      
+    }
+    int iterations = 5 + random.nextInt(5);
+    for (int i = 0; i < iterations; i++) {
+      Thread.sleep(100);
+      // concurrently reset the spell index
+      spellChecker.setSpellIndex(this.spellindex);
+      // for debug - prints the internal open searchers 
+      // showSearchersOpen();
+    }
+    
+    spellChecker.close();
+    executor.shutdown();
+    executor.awaitTermination(5, TimeUnit.SECONDS);
+    
+    
+    for (int i = 0; i < workers.length; i++) {
+      assertFalse(workers[i].failed);
+      assertTrue(workers[i].terminated);
+    }
+    // 4 searchers more than iterations
+    // 1. at creation
+    // 2. clearIndex()
+    // 2. and 3. during addwords
+    assertEquals(iterations + 4, searchers.size());
+    assertSearchersClosed();
+    
+  }
+  
+  private void assertLastSearcherOpen(int numSearchers) {
+    assertEquals(numSearchers, searchers.size());
+    IndexSearcher[] searcherArray = searchers.toArray(new IndexSearcher[0]);
+    for (int i = 0; i < searcherArray.length; i++) {
+      if (i == searcherArray.length - 1) {
+        assertTrue("expected last searcher open but was closed",
+            searcherArray[i].getIndexReader().getRefCount() > 0);
+      } else {
+        assertFalse("expected closed searcher but was open - Index: " + i,
+            searcherArray[i].getIndexReader().getRefCount() > 0);
+      }
+    }
+  }
+  
+  private void assertSearchersClosed() {
+    for (IndexSearcher searcher : searchers) {
+      assertEquals(0, searcher.getIndexReader().getRefCount());
+    }
+  }
+  
+  private void showSearchersOpen() {
+    int count = 0;
+    for (IndexSearcher searcher : searchers) {
+      if(searcher.getIndexReader().getRefCount() > 0)
+        ++count;
+    } 
+    System.out.println(count);
+  }
+
+  
+  private class SpellCheckWorker implements Runnable {
+    private final IndexReader reader;
+    boolean terminated = false;
+    boolean failed = false;
+    
+    SpellCheckWorker(IndexReader reader) {
+      super();
+      this.reader = reader;
+    }
+    
+    public void run() {
+      try {
+        while (true) {
+          try {
+            checkCommonSuggestions(reader);
+          } catch (AlreadyClosedException e) {
+            
+            return;
+          } catch (Throwable e) {
+            
+            e.printStackTrace();
+            failed = true;
+            return;
+          }
+        }
+      } finally {
+        terminated = true;
+      }
+    }
+    
+  }
+  
+  class SpellCheckerMock extends SpellChecker {
+    public SpellCheckerMock(Directory spellIndex) throws IOException {
+      super(spellIndex);
+    }
+
+    public SpellCheckerMock(Directory spellIndex, StringDistance sd)
+        throws IOException {
+      super(spellIndex, sd);
+    }
+
+    @Override
+    IndexSearcher createSearcher(Directory dir) throws IOException {
+      IndexSearcher searcher = super.createSearcher(dir);
+      TestSpellChecker.this.searchers.add(searcher);
+      return searcher;
+    }
+  }
+  
 }
